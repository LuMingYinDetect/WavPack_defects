<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/project/WavPack/src/pack_utils.c": {"id": "/project/WavPack/src/pack_utils.c", "filePath": "/project/WavPack/src/pack_utils.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// pack_utils.c\n\n// This module provides the high-level API for creating WavPack files from\n// audio data. It manages the buffers used to deinterleave the data passed\n// in from the application into the individual streams and it handles the\n// generation of riff headers and the &quot;fixup&quot; on the first WavPack block\n// header for the case where the number of samples was unknown (or wrong).\n// The actual audio stream compression is handled in the pack.c module.\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n\n#include &quot;wavpack_local.h&quot;\n\n#ifdef ENABLE_THREADS\nstatic void worker_threads_create (WavpackContext *wpc);\nstatic void pack_samples_enqueue (WavpackStream *wps, int free_wps);\nstatic int write_completed_blocks (WavpackContext *wpc, int write_all_blocks, int result);\nstatic int worker_available (WavpackContext *wpc);\n#endif\n\n///////////////////////////// executable code ////////////////////////////////\n\n// Open context for writing WavPack files. The returned context pointer is used\n// in all following calls to the library. The &quot;blockout&quot; function will be used\n// to store the actual completed WavPack blocks and will be called with the id\n// pointers containing user defined data (one for the wv file and one for the\n// wvc file). A return value of NULL indicates that memory could not be\n// allocated for the context.\n\nWavpackContext *WavpackOpenFileOutput (WavpackBlockOutput blockout, void *wv_id, void *wvc_id)\n{\n    WavpackContext *wpc = malloc (sizeof (WavpackContext));\n\n    if (!wpc)\n        return NULL;\n\n    CLEAR (*wpc);\n    wpc-&gt;total_samples = -1;\n    wpc-&gt;stream_version = CUR_STREAM_VERS;\n    wpc-&gt;blockout = blockout;\n    wpc-&gt;wv_out = wv_id;\n    wpc-&gt;wvc_out = wvc_id;\n    return wpc;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id);\n\n// New for version 5.0, this function allows the application to store a file extension and a\n// file_format identification. The extension would be used by the unpacker if the user had not\n// specified the target filename, and specifically handles the case where the original file\n// had the &quot;wrong&quot; extension for the file format (e.g., a Wave64 file having a &quot;wav&quot; extension)\n// or an alternative (e.g., &quot;bwf&quot;) or where the file format is not known. Specifying a file\n// format besides the default WP_FORMAT_WAV will ensure that old decoders will not be able to\n// see the non-wav wrapper provided with WavpackAddWrapper() (which they would end up putting\n// on a file with a .wav extension).\n\nvoid WavpackSetFileInformation (WavpackContext *wpc, char *file_extension, unsigned char file_format)\n{\n    if (file_extension &amp;&amp; strlen (file_extension) &lt; sizeof (wpc-&gt;file_extension)) {\n        add_to_metadata (wpc, file_extension, (uint32_t) strlen (file_extension), ID_ALT_EXTENSION);\n        strcpy (wpc-&gt;file_extension, file_extension);\n    }\n\n    wpc-&gt;file_format = file_format;\n}\n\n// Set configuration for writing WavPack files. This must be done before\n// sending any actual samples, however it is okay to send wrapper or other\n// metadata before calling this. The &quot;config&quot; structure contains the following\n// required information:\n\n// config-&gt;bytes_per_sample     see WavpackGetBytesPerSample() for info\n// config-&gt;bits_per_sample      see WavpackGetBitsPerSample() for info\n// config-&gt;channel_mask         Microsoft standard (mono = 4, stereo = 3)\n// config-&gt;num_channels         self evident\n// config-&gt;sample_rate          self evident\n\n// In addition, the following fields and flags may be set:\n\n// config-&gt;flags:\n// --------------\n// o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate)\n// o CONFIG_JOINT_STEREO        select joint stereo (must set override also)\n// o CONFIG_JOINT_OVERRIDE      override default joint stereo selection\n// o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &amp;\n//                                                      shaping_weight != 0.0)\n// o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping\n//                               (set CONFIG_HYBRID_SHAPE and shaping_weight)\n// o CONFIG_FAST_FLAG           &quot;fast&quot; compression mode\n// o CONFIG_HIGH_FLAG           &quot;high&quot; compression mode\n// o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample\n// o CONFIG_CREATE_WVC          create correction file\n// o CONFIG_OPTIMIZE_WVC        maximize bybrid compression (-cc option)\n// o CONFIG_CALC_NOISE          calc noise in hybrid mode\n// o CONFIG_EXTRA_MODE          extra processing mode (slow!)\n// o CONFIG_SKIP_WVX            no wvx stream for floats &amp; large ints\n// o CONFIG_MD5_CHECKSUM        specify if you plan to store MD5 signature\n// o CONFIG_CREATE_EXE          specify if you plan to prepend sfx module\n// o CONFIG_OPTIMIZE_MONO       detect and optimize for mono files posing as\n//                               stereo (uses a more recent stream format that\n//                               is not compatible with decoders &lt; 4.3)\n\n// config-&gt;bitrate              hybrid bitrate in either bits/sample or kbps\n// config-&gt;shaping_weight       hybrid noise shaping coefficient override\n// config-&gt;block_samples        force samples per WavPack block (0 = use deflt)\n// config-&gt;float_norm_exp       select floating-point data (127 for +/-1.0)\n// config-&gt;xmode                extra mode processing value override\n// config-&gt;worker_threads       enable multithreading by specifying number of\n//                               worker threads (maximum 15), but be aware that\n//                               this only benefits multichannel files\n\n// If the number of samples to be written is known then it should be passed\n// here. If the duration is not known then pass -1. In the case that the size\n// is not known (or the writing is terminated early) then it is suggested that\n// the application retrieve the first block written and let the library update\n// the total samples indication. A function is provided to do this update and\n// it should be done to the &quot;correction&quot; file also. If this cannot be done\n// (because a pipe is being used, for instance) then a valid WavPack will still\n// be created, but when applications want to access that file they will have\n// to seek all the way to the end to determine the actual duration. Also, if\n// a RIFF header has been included then it should be updated as well or the\n// WavPack file will not be directly unpackable to a valid wav file (although\n// it will still be usable by itself). A return of FALSE indicates an error.\n//\n// The enhanced version of this function now allows setting the identities of\n// any channels that are NOT standard Microsoft channels and are therefore not\n// represented in the channel mask. WavPack files require that all the Microsoft\n// channels come first (and in Microsoft order) and these are followed by any\n// other channels (which can be in any order).\n//\n// The identities are provided in a NULL-terminated string (0x00 is not an allowed\n// channel ID). The Microsoft channels may be provided as well (and will be checked)\n// but it is really only necessary to provide the &quot;unknown&quot; channels. Any truly\n// unknown channels are indicated with a 0xFF.\n//\n// The channel IDs so far reserved are listed here:\n//\n// 0:           not allowed / terminator\n// 1 - 18:      Microsoft standard channels\n// 30, 31:      Stereo mix from RF64 (not really recommended, but RF64 specifies this)\n// 33 - 44:     Core Audio channels (see Core Audio specification)\n// 127 - 128:   Amio LeftHeight, Amio RightHeight\n// 138 - 142:   Amio BottomFrontLeft/Center/Right, Amio ProximityLeft/Right\n// 200 - 207:   Core Audio channels (see Core Audio specification)\n// 221 - 224:   Core Audio channels 301 - 305 (offset by 80)\n// 255:         Present but unknown or unused channel\n//\n// All other channel IDs are reserved. Ask if something you need is missing.\n\n// Table of channels that will automatically &quot;pair&quot; into a single stereo stream\n\nstatic const struct { unsigned char a, b; } stereo_pairs [] = {\n    { 1, 2 },       // FL, FR\n    { 5, 6 },       // BL, BR\n    { 7, 8 },       // FLC, FRC\n    { 10, 11 },     // SL, SR\n    { 13, 15 },     // TFL, TFR\n    { 16, 18 },     // TBL, TBR\n    { 30, 31 },     // stereo mix L,R (RF64)\n    { 33, 34 },     // Rls, Rrs\n    { 35, 36 },     // Lw, Rw\n    { 38, 39 },     // Lt, Rt\n    { 127, 128 },   // Lh, Rh\n    { 138, 140 },   // Bfl, Bfr\n    { 141, 142 },   // Pl, Pr\n    { 200, 201 },   // Amb_W, Amb_X\n    { 202, 203 },   // Amb_Y, Amb_Z\n    { 204, 205 },   // MS_Mid, MS_Side\n    { 206, 207 },   // XY_X, XY_Y\n    { 221, 222 },   // Hph_L, Hph_R\n};\n\n#define NUM_STEREO_PAIRS (sizeof (stereo_pairs) / sizeof (stereo_pairs [0]))\n\n// Legacy version of this function for compatibility with existing applications. Note that this version\n// also generates older streams to be compatible with all decoders back to 4.0, but of course cannot be\n// used with &gt; 2^32 samples or non-Microsoft channels. The older stream version only differs in that it\n// does not support the &quot;mono optimization&quot; feature where stereo blocks containing identical audio data\n// in both channels are encoded in mono for better efficiency.\n\nint WavpackSetConfiguration (WavpackContext *wpc, WavpackConfig *config, uint32_t total_samples)\n{\n    config-&gt;flags |= CONFIG_COMPATIBLE_WRITE;       // write earlier version streams\n\n    if (total_samples == (uint32_t) -1)\n        return WavpackSetConfiguration64 (wpc, config, -1, NULL);\n    else\n        return WavpackSetConfiguration64 (wpc, config, total_samples, NULL);\n}\n\nint WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)\n{\n    uint32_t flags, bps = 0;\n    uint32_t chan_mask = config-&gt;channel_mask;\n    int num_chans = config-&gt;num_channels;\n    int stream_index, i;\n\n    if (config-&gt;sample_rate &lt;= 0) {\n        strcpy (wpc-&gt;error_message, &quot;sample rate cannot be zero or negative!&quot;);\n        return FALSE;\n    }\n\n    if (!total_samples || total_samples &gt; MAX_WAVPACK_SAMPLES || total_samples &lt; -1) {\n        strcpy (wpc-&gt;error_message, &quot;invalid total sample count!&quot;);\n        return FALSE;\n    }\n\n    if (num_chans &lt;= 0 || num_chans &gt; WAVPACK_MAX_CHANS) {\n        strcpy (wpc-&gt;error_message, &quot;invalid channel count!&quot;);\n        return FALSE;\n    }\n\n    if (config-&gt;block_samples &amp;&amp; (config-&gt;block_samples &lt; 16 || config-&gt;block_samples &gt; 131072)) {\n        strcpy (wpc-&gt;error_message, &quot;invalid custom block samples!&quot;);\n        return FALSE;\n    }\n\n    wpc-&gt;stream_version = (config-&gt;flags &amp; CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n\n    if ((config-&gt;qmode &amp; QMODE_DSD_AUDIO) &amp;&amp; config-&gt;bytes_per_sample == 1 &amp;&amp; config-&gt;bits_per_sample == 8) {\n#ifdef ENABLE_DSD\n        wpc-&gt;dsd_multiplier = 1;\n        flags = DSD_FLAG;\n\n        for (i = 14; i &gt;= 0; --i)\n            if (config-&gt;sample_rate % sample_rates [i] == 0) {\n                int divisor = config-&gt;sample_rate / sample_rates [i];\n\n                if (divisor &amp;&amp; (divisor &amp; (divisor - 1)) == 0) {\n                    config-&gt;sample_rate /= divisor;\n                    wpc-&gt;dsd_multiplier = divisor;\n                    break;\n                }\n            }\n\n        // most options that don&#x27;t apply to DSD we can simply ignore for now, but NOT hybrid mode!\n        if (config-&gt;flags &amp; CONFIG_HYBRID_FLAG) {\n            strcpy (wpc-&gt;error_message, &quot;hybrid mode not available for DSD!&quot;);\n            return FALSE;\n        }\n\n        // with DSD, very few PCM options work (or make sense), so only allow those that do\n        config-&gt;flags &amp;= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);\n        config-&gt;float_norm_exp = config-&gt;xmode = 0;\n#else\n        strcpy (wpc-&gt;error_message, &quot;libwavpack not configured for DSD!&quot;);\n        return FALSE;\n#endif\n    }\n    else\n        flags = config-&gt;bytes_per_sample - 1;\n\n    wpc-&gt;total_samples = total_samples;\n    wpc-&gt;config.sample_rate = config-&gt;sample_rate;\n    wpc-&gt;config.num_channels = config-&gt;num_channels;\n    wpc-&gt;config.channel_mask = config-&gt;channel_mask;\n    wpc-&gt;config.bits_per_sample = config-&gt;bits_per_sample;\n    wpc-&gt;config.bytes_per_sample = config-&gt;bytes_per_sample;\n    wpc-&gt;config.worker_threads = config-&gt;worker_threads;\n    wpc-&gt;config.block_samples = config-&gt;block_samples;\n    wpc-&gt;config.flags = config-&gt;flags;\n    wpc-&gt;config.qmode = config-&gt;qmode;\n\n    if (config-&gt;flags &amp; CONFIG_VERY_HIGH_FLAG)\n        wpc-&gt;config.flags |= CONFIG_HIGH_FLAG;\n\n    for (i = 0; i &lt; 15; ++i)\n        if (wpc-&gt;config.sample_rate == sample_rates [i])\n            break;\n\n    flags |= i &lt;&lt; SRATE_LSB;\n\n    // all of this stuff only applies to PCM\n\n    if (!(flags &amp; DSD_FLAG)) {\n        if (config-&gt;float_norm_exp) {\n            if (config-&gt;bytes_per_sample != 4 || config-&gt;bits_per_sample != 32) {\n                strcpy (wpc-&gt;error_message, &quot;incorrect bits/bytes configuration for float data!&quot;);\n                return FALSE;\n            }\n\n            wpc-&gt;config.float_norm_exp = config-&gt;float_norm_exp;\n            wpc-&gt;config.flags |= CONFIG_FLOAT_DATA;\n            flags |= FLOAT_DATA;\n        }\n        else {\n            if (config-&gt;bytes_per_sample &lt; 1 || config-&gt;bytes_per_sample &gt; 4) {\n                strcpy (wpc-&gt;error_message, &quot;invalid bytes per sample!&quot;);\n                return FALSE;\n            }\n\n            if (config-&gt;bits_per_sample &lt; 1 || config-&gt;bits_per_sample &gt; config-&gt;bytes_per_sample * 8) {\n                strcpy (wpc-&gt;error_message, &quot;invalid bits per sample!&quot;);\n                return FALSE;\n            }\n\n            flags |= ((config-&gt;bytes_per_sample * 8) - config-&gt;bits_per_sample) &lt;&lt; SHIFT_LSB;\n        }\n\n        if (config-&gt;flags &amp; CONFIG_HYBRID_FLAG) {\n            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;\n\n            // the noise-shaping override is used to specify a fixed shaping value, or to select no shaping\n\n            if (config-&gt;flags &amp; CONFIG_SHAPE_OVERRIDE) {\n                if ((config-&gt;flags &amp; CONFIG_HYBRID_SHAPE) &amp;&amp; config-&gt;shaping_weight) {\n                    wpc-&gt;config.shaping_weight = config-&gt;shaping_weight;\n                    flags |= HYBRID_SHAPE | NEW_SHAPING;\n                }\n                else\n                    wpc-&gt;config.shaping_weight = 0.0;\n            }\n            else {\n                wpc-&gt;config.flags |= 0x4000;    // FIXME: just make identical files\n\n                if (!(config-&gt;flags &amp; CONFIG_DYNAMIC_SHAPING)) {    // if nothing specified, use defaults\n                    if (config-&gt;flags &amp; CONFIG_OPTIMIZE_WVC)\n                        wpc-&gt;config.shaping_weight = -0.5;\n                    else if (config-&gt;sample_rate &gt;= 64000)\n                        wpc-&gt;config.shaping_weight = 1.0;\n                    else\n                        wpc-&gt;config.flags |= CONFIG_DYNAMIC_SHAPING;\n                }\n\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n\n            if (wpc-&gt;config.flags &amp; (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))\n                flags |= CROSS_DECORR;\n\n            if (config-&gt;flags &amp; CONFIG_BITRATE_KBPS) {\n                bps = (uint32_t) floor (config-&gt;bitrate * 256000.0 / config-&gt;sample_rate / config-&gt;num_channels + 0.5);\n\n                if (bps &gt; (64 &lt;&lt; 8))\n                    bps = 64 &lt;&lt; 8;\n            }\n            else\n                bps = (uint32_t) floor (config-&gt;bitrate * 256.0 + 0.5);\n        }\n        else\n            flags |= CROSS_DECORR;\n\n        if (!(config-&gt;flags &amp; CONFIG_JOINT_OVERRIDE) || (config-&gt;flags &amp; CONFIG_JOINT_STEREO))\n            flags |= JOINT_STEREO;\n\n        if (config-&gt;flags &amp; CONFIG_CREATE_WVC)\n            wpc-&gt;wvc_flag = TRUE;\n    }\n\n    // if a channel-identities string was specified, process that here, otherwise all channels\n    // not present in the channel mask are considered &quot;unassigned&quot;\n\n    if (chan_ids) {\n        int lastchan = 0, mask_copy = chan_mask;\n\n        if ((int) strlen ((char *) chan_ids) &gt; num_chans) {          // can&#x27;t be more than num channels!\n            strcpy (wpc-&gt;error_message, &quot;chan_ids longer than num channels!&quot;);\n            return FALSE;\n        }\n\n        // skip past channels that are specified in the channel mask (no reason to store those)\n\n        while (*chan_ids)\n            if (*chan_ids &lt;= 32 &amp;&amp; *chan_ids &gt; lastchan &amp;&amp; (mask_copy &amp; (1U &lt;&lt; (*chan_ids-1)))) {\n                mask_copy &amp;= ~(1U &lt;&lt; (*chan_ids-1));\n                lastchan = *chan_ids++;\n            }\n            else\n                break;\n\n        // now scan the string for an actually defined channel (and don&#x27;t store if there aren&#x27;t any)\n\n        for (i = 0; chan_ids [i]; i++)\n            if (chan_ids [i] != 0xff) {\n                wpc-&gt;channel_identities = (unsigned char *) strdup ((char *) chan_ids);\n                break;\n            }\n    }\n\n    // This loop goes through all the channels and creates the Wavpack &quot;streams&quot; for them to go in.\n    // A stream can hold either one or two channels, so we have several rules to determine how many\n    // channels will go in each stream.\n\n    for (stream_index = 0; num_chans; stream_index++) {\n        WavpackStream *wps = calloc (1, sizeof (WavpackStream));\n        unsigned char left_chan_id = 0, right_chan_id = 0;\n        int pos, chans = 1;\n\n        // allocate the stream and initialize the pointer to it\n        wpc-&gt;streams = realloc (wpc-&gt;streams, (stream_index + 1) * sizeof (wpc-&gt;streams [0]));\n        wpc-&gt;streams [stream_index] = wps;\n        wps-&gt;stream_index = stream_index;\n        wps-&gt;wpc = wpc;\n\n        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there\n        if (chan_mask)\n            for (pos = 0; pos &lt; 32; ++pos)\n                if (chan_mask &amp; (1U &lt;&lt; pos)) {\n                    if (left_chan_id) {\n                        right_chan_id = pos + 1;\n                        break;\n                    }\n                    else {\n                        chan_mask &amp;= ~(1U &lt;&lt; pos);\n                        left_chan_id = pos + 1;\n                    }\n                }\n\n        // next check for any channels identified in the channel-identities string\n        while (!right_chan_id &amp;&amp; chan_ids &amp;&amp; *chan_ids)\n            if (left_chan_id)\n                right_chan_id = *chan_ids;\n            else\n                left_chan_id = *chan_ids++;\n\n        // assume anything we did not get is &quot;unassigned&quot;\n        if (!left_chan_id)\n            left_chan_id = right_chan_id = 0xff;\n        else if (!right_chan_id)\n            right_chan_id = 0xff;\n\n        // if we have 2 channels, this is where we decide if we can combine them into one stream:\n        // 1. they are &quot;unassigned&quot; and we&#x27;ve been told to combine unassigned pairs, or\n        // 2. they appear together in the valid &quot;pairings&quot; list\n        if (num_chans &gt;= 2) {\n            if ((config-&gt;flags &amp; CONFIG_PAIR_UNDEF_CHANS) &amp;&amp; left_chan_id == 0xff &amp;&amp; right_chan_id == 0xff)\n                chans = 2;\n            else\n                for (i = 0; i &lt; NUM_STEREO_PAIRS; ++i)\n                    if ((left_chan_id == stereo_pairs [i].a &amp;&amp; right_chan_id == stereo_pairs [i].b) ||\n                        (left_chan_id == stereo_pairs [i].b &amp;&amp; right_chan_id == stereo_pairs [i].a)) {\n                            if (right_chan_id &lt;= 32 &amp;&amp; (chan_mask &amp; (1U &lt;&lt; (right_chan_id-1))))\n                                chan_mask &amp;= ~(1U &lt;&lt; (right_chan_id-1));\n                            else if (chan_ids &amp;&amp; *chan_ids == right_chan_id)\n                                chan_ids++;\n\n                            chans = 2;\n                            break;\n                        }\n        }\n\n        num_chans -= chans;\n\n        if (num_chans &amp;&amp; stream_index == NEW_MAX_STREAMS - 1)\n            break;\n\n        memcpy (wps-&gt;wphdr.ckID, &quot;wvpk&quot;, 4);\n        wps-&gt;wphdr.ckSize = sizeof (WavpackHeader) - 8;\n        SET_TOTAL_SAMPLES (wps-&gt;wphdr, wpc-&gt;total_samples);\n        wps-&gt;wphdr.version = wpc-&gt;stream_version;\n        wps-&gt;wphdr.flags = flags;\n        wps-&gt;bits = bps;\n\n        if (!stream_index)\n            wps-&gt;wphdr.flags |= INITIAL_BLOCK;\n\n        if (!num_chans)\n            wps-&gt;wphdr.flags |= FINAL_BLOCK;\n\n        if (chans == 1) {\n            wps-&gt;wphdr.flags &amp;= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps-&gt;wphdr.flags |= MONO_FLAG;\n        }\n    }\n\n    wpc-&gt;num_streams = stream_index;\n\n    if (num_chans) {\n        strcpy (wpc-&gt;error_message, &quot;too many channels!&quot;);\n        return FALSE;\n    }\n\n#ifdef SKIP_DECORRELATION\n    wpc-&gt;config.xmode = 0;\n#else\n    if (config-&gt;flags &amp; CONFIG_EXTRA_MODE)\n        wpc-&gt;config.xmode = config-&gt;xmode ? config-&gt;xmode : 1;\n    else\n        wpc-&gt;config.xmode = 0;\n#endif\n\n    return TRUE;\n}\n\n// This function allows setting the Core Audio File channel layout, many of which do not\n// conform to the Microsoft ordering standard that Wavpack requires internally (at least for\n// those channels present in the &quot;channel mask&quot;). In addition to the layout tag, this function\n// allows a reordering string to be stored in the file to allow the unpacker to reorder the\n// channels back to the specified layout (if it is aware of this feature and wants to restore\n// the CAF order). The number of channels in the layout is specified in the lower nybble of\n// the layout word, and if a reorder string is specified it must be that long. Note that all\n// the reordering is actually done outside of this library, and that if reordering is done\n// then the appropriate qmode bit must be set to ensure that any MD5 sum is stored with a new\n// ID so that old decoders don&#x27;t try to verify it (and to let the decoder know that a reorder\n// might be required).\n//\n// Note: This function should only be used to encode Core Audio files in such a way that a\n// verbatim archive can be created. Applications can just include the chan_ids parameter in\n// the call to WavpackSetConfiguration64() if there are non-Microsoft channels to specify,\n// or do nothing special if only Microsoft channels are present (the vast majority of cases).\n\nint WavpackSetChannelLayout (WavpackContext *wpc, uint32_t layout_tag, const unsigned char *reorder)\n{\n    int nchans = layout_tag &amp; 0xff;\n\n    if ((layout_tag &amp; 0xff00ff00) || nchans &gt; wpc-&gt;config.num_channels)\n        return FALSE;\n\n    wpc-&gt;channel_layout = layout_tag;\n\n    if (wpc-&gt;channel_reordering) {\n        free (wpc-&gt;channel_reordering);\n        wpc-&gt;channel_reordering = NULL;\n    }\n\n    if (nchans &amp;&amp; reorder) {\n        int min_index = 256, i;\n\n        for (i = 0; i &lt; nchans; ++i)\n            if (reorder [i] &lt; min_index)\n                min_index = reorder [i];\n\n        wpc-&gt;channel_reordering = malloc (nchans);\n\n        if (wpc-&gt;channel_reordering)\n            for (i = 0; i &lt; nchans; ++i)\n                wpc-&gt;channel_reordering [i] = reorder [i] - min_index;\n    }\n\n    return TRUE;\n}\n\n// Prepare to actually pack samples by determining the size of the WavPack\n// blocks and allocating sample buffers and initializing each stream. Call\n// after WavpackSetConfiguration() and before WavpackPackSamples(). A return\n// of FALSE indicates an error.\n\nstatic int write_metadata_block (WavpackContext *wpc);\n\nint WavpackPackInit (WavpackContext *wpc)\n{\n    int stream_index;\n\n    if (wpc-&gt;metabytes &gt; 16384)             // 16384 bytes still leaves plenty of room for audio\n        write_metadata_block (wpc);         //  in this block (otherwise write a special one)\n\n#ifdef ENABLE_THREADS\n    // if multithreading is enabled and requested, configure and start the workers here\n\n    if (wpc-&gt;config.worker_threads) {\n        // for multichannel files, we use one less worker thread than there are streams\n        if (wpc-&gt;num_streams &gt; 1 &amp;&amp; wpc-&gt;config.worker_threads &gt; wpc-&gt;num_streams - 1)\n            wpc-&gt;num_workers = wpc-&gt;num_streams - 1;\n        else\n            wpc-&gt;num_workers = wpc-&gt;config.worker_threads;\n\n        if (wpc-&gt;num_workers &gt; 15)\n            wpc-&gt;num_workers = 15;\n\n        // FIXME: There are some situations where the number of samples in a block is truncated during the packing\n        // of the first stream. This can be either because of dynamic noise shaping used with correction files or with\n        // the &quot;merge blocks&quot; feature. Since this would not work with multithreaded compression, we&#x27;ll prohibit that\n        // for now, but in the future a better solution would be to simply calculate the truncation before starting\n        // the compression threads.\n\n        if (!(wpc-&gt;streams [0]-&gt;wphdr.flags &amp; FLOAT_DATA) &amp;&amp; wpc-&gt;config.bytes_per_sample &lt;= 3)\n            if ((wpc-&gt;wvc_flag &amp;&amp; (wpc-&gt;config.flags &amp; CONFIG_DYNAMIC_SHAPING) &amp;&amp; !wpc-&gt;config.block_samples) ||\n                wpc-&gt;config.flags &amp; CONFIG_MERGE_BLOCKS)\n                    wpc-&gt;num_workers = 0;\n\n        // Because of noise-shaping discontinuities between blocks and complications in measuring quantization noise,\n        // we don&#x27;t allow temporal multithreading in hybrid mode. In the future we might be able to loosen this up some.\n\n        if (wpc-&gt;num_workers &amp;&amp; wpc-&gt;num_streams == 1 &amp;&amp; (wpc-&gt;streams [0]-&gt;wphdr.flags &amp; HYBRID_FLAG))\n            wpc-&gt;num_workers = 0;\n\n        // DSD &quot;high&quot; mode performs much better with discontinuities if it has some &quot;pre samples&quot; to chew on first.\n        // DSD &quot;fast&quot; mode doesn&#x27;t care about discontinuities, and the PCM modes do a pack_init() to deal with them.\n\n        if (wpc-&gt;num_workers &amp;&amp; wpc-&gt;dsd_multiplier &amp;&amp; wpc-&gt;num_streams == 1 &amp;&amp; (wpc-&gt;config.flags &amp; CONFIG_HIGH_FLAG))\n            wpc-&gt;max_pre_samples = 512;\n\n        if (wpc-&gt;num_workers)\n            worker_threads_create (wpc);\n    }\n#endif\n\n    // The default block size is a compromise. Longer blocks provide better encoding efficiency,\n    // but longer blocks adversely affect memory requirements and seeking performance. For WavPack\n    // version 5.0, the default block sizes have been reduced by half from the previous version,\n    // but the difference in encoding efficiency will generally be less than 0.1 percent.\n\n    if (wpc-&gt;dsd_multiplier) {\n        wpc-&gt;block_samples = (wpc-&gt;config.sample_rate % 7) ? 48000 : 44100;\n\n        if (wpc-&gt;config.flags &amp; CONFIG_HIGH_FLAG)\n            wpc-&gt;block_samples /= 2;\n\n        if (wpc-&gt;config.num_channels == 1)\n            wpc-&gt;block_samples *= 2;\n\n        while (wpc-&gt;block_samples &gt; 12000 &amp;&amp; (int64_t) wpc-&gt;block_samples * wpc-&gt;config.num_channels &gt; 300000)\n            wpc-&gt;block_samples /= 2;\n    }\n    else {\n        int divisor = (wpc-&gt;config.flags &amp; CONFIG_HIGH_FLAG) ? 2 : 4;\n\n        while (wpc-&gt;config.sample_rate % divisor)\n            divisor--;\n\n        wpc-&gt;block_samples = wpc-&gt;config.sample_rate / divisor;\n\n        while (wpc-&gt;block_samples &gt; 12000 &amp;&amp; (int64_t) wpc-&gt;block_samples * wpc-&gt;config.num_channels &gt; 75000)\n            wpc-&gt;block_samples /= 2;\n\n        while ((int64_t) wpc-&gt;block_samples * wpc-&gt;config.num_channels &lt; 20000)\n            wpc-&gt;block_samples *= 2;\n    }\n\n    if (wpc-&gt;config.block_samples) {\n        if ((wpc-&gt;config.flags &amp; CONFIG_MERGE_BLOCKS) &amp;&amp;\n            wpc-&gt;block_samples &gt; (uint32_t) wpc-&gt;config.block_samples) {\n                wpc-&gt;block_boundary = wpc-&gt;config.block_samples;\n                wpc-&gt;block_samples /= wpc-&gt;config.block_samples;\n                wpc-&gt;block_samples *= wpc-&gt;config.block_samples;\n        }\n        else\n            wpc-&gt;block_samples = wpc-&gt;config.block_samples;\n    }\n\n    wpc-&gt;ave_block_samples = wpc-&gt;block_samples;\n    wpc-&gt;max_samples = wpc-&gt;block_samples + (wpc-&gt;block_samples &gt;&gt; 1);\n\n    for (stream_index = 0; stream_index &lt; wpc-&gt;num_streams; stream_index++) {\n        WavpackStream *wps = wpc-&gt;streams [stream_index];\n\n        wps-&gt;sample_buffer = malloc (wpc-&gt;max_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n\n#ifdef ENABLE_DSD\n        if (wps-&gt;wphdr.flags &amp; DSD_FLAG)\n            pack_dsd_init (wps);\n        else\n#endif\n            pack_init (wps);\n    }\n\n    return TRUE;\n}\n\n// Pack the specified samples. Samples must be stored in longs in the native\n// endian format of the executing processor. The number of samples specified\n// indicates composite samples (sometimes called &quot;frames&quot;). So, the actual\n// number of data points would be this &quot;sample_count&quot; times the number of\n// channels. Note that samples are accumulated here until enough exist to\n// create a complete WavPack block (or several blocks for multichannel audio).\n// If an application wants to break a block at a specific sample, then it must\n// simply call WavpackFlushSamples() to force an early termination. Completed\n// WavPack blocks are send to the function provided in the initial call to\n// WavpackOpenFileOutput(). A return of FALSE indicates an error.\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples, int last_block);\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer);\n\nint WavpackPackSamples (WavpackContext *wpc, int32_t *sample_buffer, uint32_t sample_count)\n{\n    int nch = wpc-&gt;config.num_channels;\n\n    while (sample_count) {\n        int32_t *source_pointer = sample_buffer;\n        unsigned int samples_to_copy;\n        int stream_index;\n\n        if (!wpc-&gt;riff_header_added &amp;&amp; !wpc-&gt;riff_header_created &amp;&amp; !wpc-&gt;file_format) {\n            char riff_header [128];\n\n            if (!add_to_metadata (wpc, riff_header, create_riff_header (wpc, wpc-&gt;total_samples, riff_header), ID_RIFF_HEADER))\n                return FALSE;\n        }\n\n        if (wpc-&gt;acc_samples + sample_count &gt; wpc-&gt;max_samples)\n            samples_to_copy = wpc-&gt;max_samples - wpc-&gt;acc_samples;\n        else\n            samples_to_copy = sample_count;\n\n        for (stream_index = 0; stream_index &lt; wpc-&gt;num_streams; stream_index++) {\n            WavpackStream *wps = wpc-&gt;streams [stream_index];\n            int32_t *dptr, *sptr, cnt;\n\n            dptr = wps-&gt;sample_buffer + wpc-&gt;acc_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 1 : 2);\n            sptr = source_pointer;\n            cnt = samples_to_copy;\n\n            // This code used to just copy the 32-bit samples regardless of the actual size with the\n            // assumption that the caller had properly sign-extended the values (if they were smaller\n            // than 32 bits). However, several people have discovered that if the data isn&#x27;t properly\n            // sign extended then ugly things happen (e.g. CRC errors that show up only on decode).\n            // To prevent this, we now explicitly sign-extend samples smaller than 32-bit when we\n            // copy, and the performance hit from doing this is very small (generally &lt; 1%).\n\n            if (wps-&gt;wphdr.flags &amp; MONO_FLAG) {\n                switch (wpc-&gt;config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (int32_t)((uint32_t)*sptr &lt;&lt; 8) &gt;&gt; 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = *sptr;\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer++;\n            }\n            else {\n                switch (wpc-&gt;config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) sptr [0];\n                            *dptr++ = (signed char) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) sptr [0];\n                            *dptr++ = (int16_t) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (int32_t)((uint32_t)sptr [0] &lt;&lt; 8) &gt;&gt; 8;\n                            *dptr++ = (int32_t)((uint32_t)sptr [1] &lt;&lt; 8) &gt;&gt; 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = sptr [0];\n                            *dptr++ = sptr [1];\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer += 2;\n            }\n        }\n\n        sample_buffer += samples_to_copy * nch;\n        sample_count -= samples_to_copy;\n\n        if ((wpc-&gt;acc_samples += samples_to_copy) == wpc-&gt;max_samples &amp;&amp;\n            !pack_streams (wpc, wpc-&gt;block_samples,\n                wpc-&gt;acc_samples - wpc-&gt;block_samples + sample_count &lt; wpc-&gt;max_samples))\n                    return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Flush all accumulated samples into WavPack blocks. This is normally called\n// after all samples have been sent to WavpackPackSamples(), but can also be\n// called to terminate a WavPack block at a specific sample (in other words it\n// is possible to continue after this operation). This is also called to\n// dump non-audio blocks like those holding metadata for various purposes.\n// A return of FALSE indicates an error.\n\nint WavpackFlushSamples (WavpackContext *wpc)\n{\n    while (wpc-&gt;acc_samples) {\n        uint32_t block_samples;\n\n        if (wpc-&gt;acc_samples &gt; wpc-&gt;block_samples)\n            block_samples = wpc-&gt;acc_samples / 2;\n        else\n            block_samples = wpc-&gt;acc_samples;\n\n        if (!pack_streams (wpc, block_samples, block_samples == wpc-&gt;acc_samples))\n            return FALSE;\n    }\n\n    if (wpc-&gt;metacount)\n        write_metadata_block (wpc);\n\n    return TRUE;\n}\n\n// Note: The following function is no longer required because a proper wav\n// header is now automatically generated for the application. However, if the\n// application wants to generate its own header or wants to include additional\n// chunks, then this function can still be used in which case the automatic\n// wav header generation is suppressed.\n\n// Add wrapper (currently RIFF only) to WavPack blocks. This should be called\n// before sending any audio samples for the RIFF header or after all samples\n// have been sent for any RIFF trailer. WavpackFlushSamples() should be called\n// between sending the last samples and calling this for trailer data to make\n// sure that headers and trailers don&#x27;t get mixed up in very short files. If\n// the exact contents of the RIFF header are not known because, for example,\n// the file duration is uncertain or trailing chunks are possible, simply write\n// a &quot;dummy&quot; header of the correct length. When all data has been written it\n// will be possible to read the first block written and update the header\n// directly. An example of this can be found in the Audition filter. A\n// return of FALSE indicates an error.\n\nint WavpackAddWrapper (WavpackContext *wpc, void *data, uint32_t bcount)\n{\n    int64_t index = WavpackGetSampleIndex64 (wpc);\n    unsigned char meta_id;\n\n    if (!index || index == -1) {\n        wpc-&gt;riff_header_added = TRUE;\n        meta_id = wpc-&gt;file_format ? ID_ALT_HEADER : ID_RIFF_HEADER;\n    }\n    else {\n        wpc-&gt;riff_trailer_bytes += bcount;\n        meta_id = wpc-&gt;file_format ? ID_ALT_TRAILER : ID_RIFF_TRAILER;\n    }\n\n    return add_to_metadata (wpc, data, bcount, meta_id);\n}\n\n// Store computed MD5 sum in WavPack metadata. Note that the user must compute\n// the 16 byte sum; it is not done here. A return of FALSE indicates an error.\n// If any of the lower 8 bits of qmode are set, then this MD5 is stored with\n// a metadata ID that old decoders do not recognize (because they would not\n// interpret the qmode and would therefore fail the verification).\n\nint WavpackStoreMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    return add_to_metadata (wpc, data, 16, (wpc-&gt;config.qmode &amp; 0xff) ? ID_ALT_MD5_CHECKSUM : ID_MD5_CHECKSUM);\n}\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define DS64ChunkFormat &quot;DDDL&quot;\n\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    char *outptr = outbuffer;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int32_t channel_mask = wpc-&gt;config.channel_mask;\n    int32_t sample_rate = wpc-&gt;config.sample_rate;\n    int bytes_per_sample = wpc-&gt;config.bytes_per_sample;\n    int bits_per_sample = wpc-&gt;config.bits_per_sample;\n    int format = (wpc-&gt;config.float_norm_exp) ? 3 : 1;\n    int num_channels = wpc-&gt;config.num_channels;\n    int wavhdrsize = 16;\n\n    wpc-&gt;riff_header_created = TRUE;\n\n    if (format == 3 &amp;&amp; wpc-&gt;config.float_norm_exp != 127) {\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t create valid RIFF wav header for non-normalized floating data!&quot;);\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes &gt; 0xff000000) {\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels &gt; 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    memcpy (riffhdr.ckID, do_rf64 ? &quot;RF64&quot; : &quot;RIFF&quot;, sizeof (riffhdr.ckID));\n    memcpy (riffhdr.formType, &quot;WAVE&quot;, sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + total_data_bytes + wpc-&gt;riff_trailer_bytes;\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    memcpy (fmthdr.ckID, &quot;fmt &quot;, sizeof (fmthdr.ckID));\n    memcpy (datahdr.ckID, &quot;data&quot;, sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        memcpy (junkchunk.ckID, &quot;junk&quot;, sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&amp;junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        memcpy (ds64hdr.ckID, &quot;ds64&quot;, sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&amp;ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&amp;ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    WavpackNativeToLittleEndian (&amp;riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&amp;fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&amp;wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&amp;datahdr, ChunkHeaderFormat);\n\n    // write the RIFF chunks up to just before the data starts\n\n    outptr = (char *) memcpy (outptr, &amp;riffhdr, sizeof (riffhdr)) + sizeof (riffhdr);\n\n    if (do_rf64) {\n        outptr = (char *) memcpy (outptr, &amp;ds64hdr, sizeof (ds64hdr)) + sizeof (ds64hdr);\n        outptr = (char *) memcpy (outptr, &amp;ds64_chunk, sizeof (ds64_chunk)) + sizeof (ds64_chunk);\n    }\n\n    if (write_junk)\n        outptr = (char *) memcpy (outptr, &amp;junkchunk, sizeof (junkchunk)) + sizeof (junkchunk);\n\n    outptr = (char *) memcpy (outptr, &amp;fmthdr, sizeof (fmthdr)) + sizeof (fmthdr);\n    outptr = (char *) memcpy (outptr, &amp;wavhdr, wavhdrsize) + wavhdrsize;\n    outptr = (char *) memcpy (outptr, &amp;datahdr, sizeof (datahdr)) + sizeof (datahdr);\n\n    return (int)(outptr - (char *) outbuffer);\n}\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes);\n\n// Pack the given stream into the allocated block buffers, including appending the block\n// checksum. The only error possible is overflowing the buffers (which generally should\n// be big enough to avoid this) and this is indicated with a FALSE return. This is\n// threadsafe across streams, so it can be called directly from the main packing code\n// or from the worker threads.\n\nstatic int pack_stream_block (WavpackStream *wps)\n{\n    int result;\n\n#ifdef ENABLE_DSD\n    if (wps-&gt;wphdr.flags &amp; DSD_FLAG)\n        result = pack_dsd_block (wps, wps-&gt;sample_buffer);\n    else\n#endif\n        result = pack_block (wps, wps-&gt;sample_buffer);\n\n    if (result) {\n        result = block_add_checksum (wps-&gt;blockbuff, wps-&gt;blockend, (wps-&gt;wphdr.flags &amp; HYBRID_FLAG) ? 2 : 4);\n\n        if (result &amp;&amp; wps-&gt;block2buff)\n            result = block_add_checksum (wps-&gt;block2buff, wps-&gt;block2end, 2);\n    }\n\n    return result;\n}\n\n// Write the packed data from the specified stream to the output file. This part is NOT threadsafe\n// and must be performed in the stream order. This step includes potentially converting the WavPack\n// header to little-endian and freeing the block buffers. If the block output function fails then\n// this is flagged here and we retain that status through potentially multiple calls.\n\nstatic int write_stream_block (WavpackStream *wps, int result)\n{\n    WavpackContext *wpc = (WavpackContext *) wps-&gt;wpc;  // safe because this is called single-threaded\n    int bcount;\n\n    if (result) {\n        bcount = ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize + 8;\n        WavpackNativeToLittleEndian ((WavpackHeader *) wps-&gt;blockbuff, WavpackHeaderFormat);\n        result = wpc-&gt;blockout (wpc-&gt;wv_out, wps-&gt;blockbuff, bcount);\n\n        if (result)\n            wpc-&gt;filelen += bcount;\n        else\n            strcpy (wpc-&gt;error_message, &quot;can&#x27;t write WavPack data, disk probably full!&quot;);\n    }\n\n    free (wps-&gt;blockbuff);\n    wps-&gt;blockbuff = NULL;\n\n    if (wps-&gt;block2buff) {\n        if (result) {\n            bcount = ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize + 8;\n            WavpackNativeToLittleEndian ((WavpackHeader *) wps-&gt;block2buff, WavpackHeaderFormat);\n            result = wpc-&gt;blockout (wpc-&gt;wvc_out, wps-&gt;block2buff, bcount);\n\n            if (result)\n                wpc-&gt;file2len += bcount;\n            else\n                strcpy (wpc-&gt;error_message, &quot;can&#x27;t write WavPack data, disk probably full!&quot;);\n        }\n\n        free (wps-&gt;block2buff);\n        wps-&gt;block2buff = NULL;\n    }\n\n    wps-&gt;sample_index += wps-&gt;wphdr.block_samples;  // now that block is written, this is safe to do\n    return result;\n}\n\n// Pack all streams and write the completed WavPack blocks to the output. The number of samples\n// to be processed is specified by &quot;block_samples&quot;, although in some situations fewer samples\n// may actually be processed (e.g., hybrid lossy mode with DNS). Unused data in the\n// sample_buffer will be moved up if the entire buffer is not exhausted.\n//\n// Multithreading is handled here. For multichannel files (i.e., more than one stream) the\n// multithreading is done spatially across the multiple streams and will therefore result in\n// identical output files. For single-stream files (i.e., mono or stereo) the multithreading\n// is done temporally, meaning we start blocks in the future before past blocks are done.\n// Unfortunately most WavPack modes use some information from the previous block during\n// encoding, and so some provisions must be made here for discontinuities. Also, this means\n// that the resulting output files will generally NOT be identical (although they will be\n// essentially equivalent).\n//\n// The &quot;last_block&quot; parameter indicates that this is the final call to this function in this\n// sequence. Otherwise, this function could return while packing is still occurring on worker\n// threads (in which case it must be called again to write the results to the output). The\n// exception to this is that on an error return (FALSE) the workers will be finished.\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples, int last_block)\n{\n    uint32_t max_blocksize, max_chans = 1;\n    int result = TRUE, stream_index, i;\n\n    // for calculating output (block) buffer size, first see if any streams are stereo\n\n    for (i = 0; i &lt; wpc-&gt;num_streams; i++)\n        if (!(wpc-&gt;streams [i]-&gt;wphdr.flags &amp; MONO_FLAG)) {\n            max_chans = 2;\n            break;\n        }\n\n    // then calculate maximum size based on bytes / sample\n\n    max_blocksize = block_samples * max_chans * ((wpc-&gt;streams [0]-&gt;wphdr.flags &amp; BYTES_STORED) + 1);\n\n    // add margin based on how much &quot;negative&quot; compression is possible with pathological audio\n\n    if ((wpc-&gt;config.flags &amp; CONFIG_FLOAT_DATA) &amp;&amp; !(wpc-&gt;config.flags &amp; CONFIG_SKIP_WVX))\n        max_blocksize += max_blocksize;         // 100% margin for lossless float data\n    else\n        max_blocksize += max_blocksize &gt;&gt; 2;    // otherwise 25% margin for everything else\n\n    max_blocksize += wpc-&gt;metabytes + 1024;     // finally, add metadata &amp; another 1K margin\n    max_blocksize += max_blocksize &amp; 1;         // and make sure it&#x27;s even so we detect overflow\n\n    for (stream_index = 0; result &amp;&amp; stream_index &lt; wpc-&gt;num_streams; stream_index++) {\n        WavpackStream *wps = wpc-&gt;streams [stream_index];\n        uint32_t flags = wps-&gt;wphdr.flags;\n\n        flags &amp;= ~MAG_MASK;\n        flags += (1U &lt;&lt; MAG_LSB) * ((flags &amp; BYTES_STORED) * 8 + 7);\n\n        SET_BLOCK_INDEX (wps-&gt;wphdr, wps-&gt;sample_index);\n        wps-&gt;wphdr.block_samples = block_samples;\n        wps-&gt;wphdr.flags = flags;\n        wps-&gt;block2buff = (wpc-&gt;wvc_flag) ? malloc (max_blocksize) : NULL;\n        wps-&gt;block2end = (wpc-&gt;wvc_flag) ? wps-&gt;block2buff + max_blocksize : NULL;\n        wps-&gt;blockbuff = malloc (max_blocksize);\n        wps-&gt;blockend = wps-&gt;blockbuff + max_blocksize;\n\n#ifdef ENABLE_THREADS\n        // If there is a worker thread available, and we&#x27;re not doing the final stream (which\n        // implies we&#x27;re doing multichannel) then we can start packing this stream on a worker\n        // thread. In this case we pass the WavpackStream structure directly (i.e., not a copy).\n\n        if (worker_available (wpc) &amp;&amp; stream_index &lt; wpc-&gt;num_streams - 1) {\n            result = write_completed_blocks (wpc, FALSE, result);\n            pack_samples_enqueue (wps, FALSE);\n        }\n\n        // If there is a worker available and we&#x27;re doing a single stream (i.e., mono or stereo) and\n        // it&#x27;s not the very first block (which might have metadata which needs to be sent unthreaded)\n        // and this is not the last block to be processed during this call to WavpackPackSamples(),\n        // then we can start packing this block on a worker and move on to the next block. Note that\n        // since we will continue with this stream before the packing is complete, we must make a\n        // copy of the WavpackStream structure that will be freed once the block has been written.\n        // This also implies that packing will continue in the background after pack_streams() has\n        // returned, but we will not return to the user until they&#x27;re all done, obviously.\n\n        else if (worker_available (wpc) &amp;&amp; wpc-&gt;num_streams == 1 &amp;&amp; wps-&gt;sample_index &amp;&amp; !last_block) {\n            WavpackStream *wps_copy = malloc (sizeof (WavpackStream));\n\n            memcpy (wps_copy, wps, sizeof (WavpackStream));\n\n            // If there is a discontinuity (i.e., the previous block is not done, so we can&#x27;t get any\n            // continuation information from it) then we must essentially start fresh. For &quot;high&quot; mode\n            // DSD we are able to use some number of previous samples to compensate for this, and the\n            // &quot;fast&quot; DSD mode is always encoded independently, so that&#x27;s a freebie.\n\n            if (wps-&gt;discontinuous)\n                pack_init (wps_copy);\n\n            wps_copy-&gt;sample_buffer = malloc (block_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n            memcpy (wps_copy-&gt;sample_buffer, wps-&gt;sample_buffer, block_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n\n            if (wps-&gt;discontinuous &amp;&amp; wps-&gt;pre_sample_buffer &amp;&amp; wps-&gt;num_pre_samples) {\n                wps_copy-&gt;pre_sample_buffer = malloc (wps-&gt;num_pre_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n                memcpy (wps_copy-&gt;pre_sample_buffer, wps-&gt;pre_sample_buffer, wps-&gt;num_pre_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n            }\n            else {\n                wps_copy-&gt;pre_sample_buffer = NULL;\n                wps_copy-&gt;num_pre_samples = 0;\n            }\n\n            if (wps-&gt;dsd.ptable) {\n                wps_copy-&gt;dsd.ptable = malloc (256 * sizeof (*wps-&gt;dsd.ptable));\n                memcpy (wps_copy-&gt;dsd.ptable, wps-&gt;dsd.ptable, 256 * sizeof (*wps-&gt;dsd.ptable));\n            }\n\n            result = write_completed_blocks (wpc, FALSE, result);\n            pack_samples_enqueue (wps_copy, TRUE);\n\n            // Fix up the existing WavpackStream, and mark it as &quot;discontinuous&quot; because we will be continuing with\n            // it before this operation is complete. The block buffers will be freed after the block is written.\n\n            wps-&gt;sample_index += block_samples;\n            wps-&gt;discontinuous = TRUE;\n            wps-&gt;blockbuff = NULL;\n            wps-&gt;block2buff = NULL;\n        }\n        else\n#endif\n        {\n            // This code handles blocks compressed now and sent in the foreground,\n            // although we might have to wait for all backgrounded blocks to send.\n\n            if (wps-&gt;discontinuous)\n                pack_init (wps);\n\n            result = pack_stream_block (wps);\n\n            if (wps-&gt;wphdr.block_samples != block_samples)\n                block_samples = wps-&gt;wphdr.block_samples;\n\n            if (!result) {\n                strcpy (wpc-&gt;error_message, &quot;output buffer overflowed!&quot;);\n                break;\n            }\n\n            wpc-&gt;lossy_blocks |= wps-&gt;lossy_blocks;\n\n#ifdef ENABLE_THREADS\n            // all background blocks must be complete and sent before we send this one...\n            if (wpc-&gt;num_workers)\n                result = write_completed_blocks (wpc, TRUE, result);\n#endif\n\n            result = write_stream_block (wps, result);\n            wps-&gt;discontinuous = FALSE;\n        }\n\n        // This handles maintaining the &quot;pre sample buffer&quot; if requested. Currently this is just used for DSD\n        // &quot;high&quot; mode, but it could be used in the future for PCM data instead of starting over from scratch\n\n        if (wps-&gt;discontinuous &amp;&amp; wps-&gt;wpc-&gt;max_pre_samples) {\n            if (!wps-&gt;pre_sample_buffer)\n                wps-&gt;pre_sample_buffer = malloc (wps-&gt;wpc-&gt;max_pre_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n\n            if (wps-&gt;wpc-&gt;block_samples &gt; wps-&gt;wpc-&gt;max_pre_samples) {\n                memcpy (wps-&gt;pre_sample_buffer,\n                    wps-&gt;sample_buffer + (wps-&gt;wpc-&gt;block_samples - wps-&gt;wpc-&gt;max_pre_samples) * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 1 : 2),\n                    wps-&gt;wpc-&gt;max_pre_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n\n                wps-&gt;num_pre_samples = wps-&gt;wpc-&gt;max_pre_samples;\n            }\n            else {\n                memcpy (wps-&gt;pre_sample_buffer, wps-&gt;sample_buffer, wps-&gt;wpc-&gt;block_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n                wps-&gt;num_pre_samples = wps-&gt;wpc-&gt;block_samples;\n            }\n        }\n    }\n\n#ifdef ENABLE_THREADS\n    // All background blocks must be complete and sent before we return if this is the last\n    // block of the WavpackPackSamples() call (or an error occurred). Of course, for\n    // multichannel audio, this was already done above before we sent the last stream.\n\n    if (wpc-&gt;num_workers &amp;&amp; (last_block || !result))\n        result = write_completed_blocks (wpc, TRUE, result);\n#endif\n\n    // If there&#x27;s still audio in the sample buffer, move it up to the front for the next call\n\n    if (wpc-&gt;acc_samples != block_samples)\n        for (stream_index = 0; result &amp;&amp; stream_index &lt; wpc-&gt;num_streams; stream_index++) {\n            WavpackStream *wps = wpc-&gt;streams [stream_index];\n            memmove (wps-&gt;sample_buffer,\n                     wps-&gt;sample_buffer + block_samples * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 1 : 2),\n                    (wpc-&gt;acc_samples - block_samples) * (wps-&gt;wphdr.flags &amp; MONO_FLAG ? 4 : 8));\n        }\n\n    wpc-&gt;ave_block_samples = (wpc-&gt;ave_block_samples * 0x7 + block_samples + 0x4) &gt;&gt; 3;\n    wpc-&gt;acc_samples -= block_samples;\n\n    return result;\n}\n\n// Given the pointer to the first block written (to either a .wv or .wvc file),\n// update the block with the actual number of samples written. If the wav\n// header was generated by the library, then it is updated also. This should\n// be done if WavpackSetConfiguration() was called with an incorrect number\n// of samples (or -1). It is the responsibility of the application to read and\n// rewrite the block. An example of this can be found in the Audition filter.\n\nstatic void block_update_checksum (unsigned char *buffer_start);\n\nvoid WavpackUpdateNumSamples (WavpackContext *wpc, void *first_block)\n{\n    uint32_t wrapper_size;\n\n    if (wpc-&gt;riff_header_created &amp;&amp; WavpackGetWrapperLocation (first_block, &amp;wrapper_size)) {\n        unsigned char riff_header [128];\n\n        if (wrapper_size == create_riff_header (wpc, WavpackGetSampleIndex64 (wpc), riff_header))\n            memcpy (WavpackGetWrapperLocation (first_block, NULL), riff_header, wrapper_size);\n    }\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    SET_TOTAL_SAMPLES (* (WavpackHeader *) first_block, WavpackGetSampleIndex64 (wpc));\n    block_update_checksum (first_block);\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n}\n\n// Note: The following function is no longer required because the wav header\n// automatically generated for the application will also be updated by\n// WavpackUpdateNumSamples (). However, if the application wants to generate\n// its own header or wants to include additional chunks, then this function\n// still must be used to update the application generated header.\n\n// Given the pointer to the first block written to a WavPack file, this\n// function returns the location of the stored RIFF header that was originally\n// written with WavpackAddWrapper(). This would normally be used to update\n// the wav header to indicate that a different number of samples was actually\n// written or if additional RIFF chunks are written at the end of the file.\n// The &quot;size&quot; parameter can be set to non-NULL to obtain the exact size of the\n// RIFF header, and the function will return FALSE if the header is not found\n// in the block&#x27;s metadata (or it is not a valid WavPack block). It is the\n// responsibility of the application to read and rewrite the block. An example\n// of this can be found in the Audition filter.\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size);\n\nvoid *WavpackGetWrapperLocation (void *first_block, uint32_t *size)\n{\n    void *loc;\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    loc = find_metadata (first_block, ID_RIFF_HEADER, size);\n\n    if (!loc)\n        loc = find_metadata (first_block, ID_ALT_HEADER, size);\n\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n\n    return loc;\n}\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size)\n{\n    WavpackHeader *wphdr = wavpack_block;\n    unsigned char *dp, meta_id, c1, c2;\n    int32_t bcount, meta_bc;\n\n    if (strncmp (wphdr-&gt;ckID, &quot;wvpk&quot;, 4))\n        return NULL;\n\n    bcount = wphdr-&gt;ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount &gt;= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 &lt;&lt; 1;\n        bcount -= 2;\n\n        if (meta_id &amp; ID_LARGE) {\n            if (bcount &lt; 2)\n                break;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 &lt;&lt; 9) + ((uint32_t) c2 &lt;&lt; 17);\n            bcount -= 2;\n        }\n\n        if ((meta_id &amp; ID_UNIQUE) == desired_id) {\n            if ((bcount - meta_bc) &gt;= 0) {\n                if (size)\n                    *size = meta_bc - ((meta_id &amp; ID_ODD_SIZE) ? 1 : 0);\n\n                return dp;\n            }\n            else\n                return NULL;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return NULL;\n}\n\nint copy_metadata (WavpackMetadata *wpmd, unsigned char *buffer_start, unsigned char *buffer_end)\n{\n    uint32_t mdsize = wpmd-&gt;byte_length + (wpmd-&gt;byte_length &amp; 1);\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n\n    mdsize += (wpmd-&gt;byte_length &gt; 510) ? 4 : 2;\n    buffer_start += wphdr-&gt;ckSize + 8;\n\n    if (buffer_start + mdsize &gt;= buffer_end)\n        return FALSE;\n\n    buffer_start [0] = wpmd-&gt;id | (wpmd-&gt;byte_length &amp; 1 ? ID_ODD_SIZE : 0);\n    buffer_start [1] = (wpmd-&gt;byte_length + 1) &gt;&gt; 1;\n\n    if (wpmd-&gt;byte_length &gt; 510) {\n        buffer_start [0] |= ID_LARGE;\n        buffer_start [2] = (wpmd-&gt;byte_length + 1) &gt;&gt; 9;\n        buffer_start [3] = (wpmd-&gt;byte_length + 1) &gt;&gt; 17;\n    }\n\n    if (wpmd-&gt;data &amp;&amp; wpmd-&gt;byte_length) {\n        memcpy (buffer_start + (wpmd-&gt;byte_length &gt; 510 ? 4 : 2), wpmd-&gt;data, wpmd-&gt;byte_length);\n\n        if (wpmd-&gt;byte_length &amp; 1)          // if size is odd, make sure pad byte is a zero\n            buffer_start [mdsize - 1] = 0;\n    }\n\n    wphdr-&gt;ckSize += mdsize;\n    return TRUE;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id)\n{\n    WavpackMetadata *mdp;\n    unsigned char *src = data;\n\n    while (bcount) {\n        if (wpc-&gt;metacount) {\n            uint32_t bc = bcount;\n\n            mdp = wpc-&gt;metadata + wpc-&gt;metacount - 1;\n\n            if (mdp-&gt;id == id) {\n                if (wpc-&gt;metabytes + bcount &gt; 1000000)\n                    bc = 1000000 - wpc-&gt;metabytes;\n\n                mdp-&gt;data = realloc (mdp-&gt;data, mdp-&gt;byte_length + bc);\n                memcpy ((char *) mdp-&gt;data + mdp-&gt;byte_length, src, bc);\n                mdp-&gt;byte_length += bc;\n                wpc-&gt;metabytes += bc;\n                bcount -= bc;\n                src += bc;\n\n                if (wpc-&gt;metabytes &gt;= 1000000 &amp;&amp; !write_metadata_block (wpc))\n                    return FALSE;\n            }\n        }\n\n        if (bcount) {\n            wpc-&gt;metadata = realloc (wpc-&gt;metadata, (wpc-&gt;metacount + 1) * sizeof (WavpackMetadata));\n            mdp = wpc-&gt;metadata + wpc-&gt;metacount++;\n            mdp-&gt;byte_length = 0;\n            mdp-&gt;data = NULL;\n            mdp-&gt;id = id;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic char *write_metadata (WavpackMetadata *wpmd, char *outdata)\n{\n    unsigned char id = wpmd-&gt;id, wordlen [3];\n\n    wordlen [0] = (wpmd-&gt;byte_length + 1) &gt;&gt; 1;\n    wordlen [1] = (wpmd-&gt;byte_length + 1) &gt;&gt; 9;\n    wordlen [2] = (wpmd-&gt;byte_length + 1) &gt;&gt; 17;\n\n    if (wpmd-&gt;byte_length &amp; 1)\n        id |= ID_ODD_SIZE;\n\n    if (wordlen [1] || wordlen [2])\n        id |= ID_LARGE;\n\n    *outdata++ = id;\n    *outdata++ = wordlen [0];\n\n    if (id &amp; ID_LARGE) {\n        *outdata++ = wordlen [1];\n        *outdata++ = wordlen [2];\n    }\n\n    if (wpmd-&gt;data &amp;&amp; wpmd-&gt;byte_length) {\n        memcpy (outdata, wpmd-&gt;data, wpmd-&gt;byte_length);\n        outdata += wpmd-&gt;byte_length;\n\n        if (wpmd-&gt;byte_length &amp; 1)\n            *outdata++ = 0;\n    }\n\n    return outdata;\n}\n\nstatic int write_metadata_block (WavpackContext *wpc)\n{\n    char *block_buff, *block_ptr;\n    WavpackHeader *wphdr;\n\n    if (wpc-&gt;metacount) {\n        int metacount = wpc-&gt;metacount, block_size = sizeof (WavpackHeader);\n        WavpackMetadata *wpmdp = wpc-&gt;metadata;\n\n        while (metacount--) {\n            block_size += wpmdp-&gt;byte_length + (wpmdp-&gt;byte_length &amp; 1);\n            block_size += (wpmdp-&gt;byte_length &gt; 510) ? 4 : 2;\n            wpmdp++;\n        }\n\n        // allocate 6 extra bytes for 4-byte checksum (which we add last)\n        wphdr = (WavpackHeader *) (block_buff = malloc (block_size + 6));\n\n        CLEAR (*wphdr);\n        memcpy (wphdr-&gt;ckID, &quot;wvpk&quot;, 4);\n        SET_TOTAL_SAMPLES (*wphdr, wpc-&gt;total_samples);\n        wphdr-&gt;version = wpc-&gt;stream_version;\n        wphdr-&gt;ckSize = block_size - 8;\n        wphdr-&gt;block_samples = 0;\n\n        block_ptr = (char *)(wphdr + 1);\n\n        wpmdp = wpc-&gt;metadata;\n\n        while (wpc-&gt;metacount) {\n            block_ptr = write_metadata (wpmdp, block_ptr);\n            wpc-&gt;metabytes -= wpmdp-&gt;byte_length;\n            free_metadata (wpmdp++);\n            wpc-&gt;metacount--;\n        }\n\n        free (wpc-&gt;metadata);\n        wpc-&gt;metadata = NULL;\n        // add a 4-byte checksum here (increases block size by 6)\n        block_add_checksum ((unsigned char *) block_buff, (unsigned char *) block_buff + (block_size += 6), 4);\n        WavpackNativeToLittleEndian ((WavpackHeader *) block_buff, WavpackHeaderFormat);\n\n        if (!wpc-&gt;blockout (wpc-&gt;wv_out, block_buff, block_size)) {\n            free (block_buff);\n            strcpy (wpc-&gt;error_message, &quot;can&#x27;t write WavPack data, disk probably full!&quot;);\n            return FALSE;\n        }\n\n        free (block_buff);\n    }\n\n    return TRUE;\n}\n\nvoid free_metadata (WavpackMetadata *wpmd)\n{\n    if (wpmd-&gt;data) {\n        free (wpmd-&gt;data);\n        wpmd-&gt;data = NULL;\n    }\n}\n\n// These two functions add or update the block checksums that were introduced in WavPack 5.0.\n// The presence of the checksum is indicated by a flag in the wavpack header (HAS_CHECKSUM)\n// and the actual metadata item should be the last one in the block, and can be either 2 or 4\n// bytes. Of course, older versions of the decoder will simply ignore both of these.\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n#ifdef BITSTREAM_SHORTS\n    uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n    unsigned char *csptr = buffer_start;\n#endif\n    int bcount = wphdr-&gt;ckSize + 8, wcount;\n    uint32_t csum = (uint32_t) -1;\n\n    if (bytes != 2 &amp;&amp; bytes != 4)\n        return FALSE;\n\n    if (bcount &lt; sizeof (WavpackHeader) || (bcount &amp; 1) || buffer_start + bcount + 2 + bytes &gt; buffer_end)\n        return FALSE;\n\n    wphdr-&gt;flags |= HAS_CHECKSUM;\n    wphdr-&gt;ckSize += 2 + bytes;\n    wcount = bcount &gt;&gt; 1;\n\n#ifdef BITSTREAM_SHORTS\n    while (wcount--)\n        csum = (csum * 3) + *csptr++;\n#else\n    WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n    while (wcount--) {\n        csum = (csum * 3) + csptr [0] + (csptr [1] &lt;&lt; 8);\n        csptr += 2;\n    }\n\n    WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n    buffer_start += bcount;\n    *buffer_start++ = ID_BLOCK_CHECKSUM;\n    *buffer_start++ = bytes &gt;&gt; 1;\n\n    if (bytes == 4) {\n        *buffer_start++ = csum;\n        *buffer_start++ = csum &gt;&gt; 8;\n        *buffer_start++ = csum &gt;&gt; 16;\n        *buffer_start++ = csum &gt;&gt; 24;\n    }\n    else {\n        csum ^= csum &gt;&gt; 16;\n        *buffer_start++ = csum;\n        *buffer_start++ = csum &gt;&gt; 8;\n    }\n\n    return TRUE;\n}\n\nstatic void block_update_checksum (unsigned char *buffer_start)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n    unsigned char *dp, meta_id, c1, c2;\n    uint32_t bcount, meta_bc;\n\n    if (!(wphdr-&gt;flags &amp; HAS_CHECKSUM))\n        return;\n\n    bcount = wphdr-&gt;ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount &gt;= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 &lt;&lt; 1;\n        bcount -= 2;\n\n        if (meta_id &amp; ID_LARGE) {\n            if (bcount &lt; 2)\n                return;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 &lt;&lt; 9) + ((uint32_t) c2 &lt;&lt; 17);\n            bcount -= 2;\n        }\n\n        if (bcount &lt; meta_bc)\n            return;\n\n        if ((meta_id &amp; ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n            unsigned char *csptr = buffer_start;\n#endif\n            int wcount = (int)(dp - 2 - buffer_start) &gt;&gt; 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id &amp; ID_ODD_SIZE) || meta_bc &lt; 2 || meta_bc &gt; 4)\n                return;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] &lt;&lt; 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                *dp++ = csum;\n                *dp++ = csum &gt;&gt; 8;\n                *dp++ = csum &gt;&gt; 16;\n                *dp++ = csum &gt;&gt; 24;\n                return;\n            }\n            else {\n                csum ^= csum &gt;&gt; 16;\n                *dp++ = csum;\n                *dp++ = csum &gt;&gt; 8;\n                return;\n            }\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n}\n\n///////////////////////////// multithreading code ////////////////////////////////\n\n#ifdef ENABLE_THREADS\n\n// This is the worker thread function for packing support, essentially allowing\n// pack_stream_block() to be running for multiple streams simultaneously.\n\n#ifdef _WIN32\nstatic unsigned WINAPI pack_samples_worker_thread (LPVOID param)\n#else\nstatic void *pack_samples_worker_thread (void *param)\n#endif\n{\n    WorkerInfo *cxt = param;\n\n    while (1) {\n        wp_mutex_obtain (*cxt-&gt;mutex);\n        cxt-&gt;state = Ready;\n        (*cxt-&gt;workers_ready)++;\n        wp_condvar_signal (*cxt-&gt;global_cond);      // signal that we&#x27;re ready to work\n\n        while (cxt-&gt;state == Ready)                 // wait for something to do\n            wp_condvar_wait (cxt-&gt;worker_cond, *cxt-&gt;mutex);\n\n        wp_mutex_release (*cxt-&gt;mutex);\n\n        if (cxt-&gt;state == Quit)                     // break out if we&#x27;re done\n            break;\n\n        cxt-&gt;result = pack_stream_block (cxt-&gt;wps); // this is where the work is done\n\n        wp_mutex_obtain (*cxt-&gt;mutex);\n        cxt-&gt;state = Done;\n        wp_condvar_signal (*cxt-&gt;global_cond);      // signal completion\n\n        while (cxt-&gt;state == Done)                  // wait for output to be written\n            wp_condvar_wait (cxt-&gt;worker_cond, *cxt-&gt;mutex);\n\n        wp_mutex_release (*cxt-&gt;mutex);\n\n        if (cxt-&gt;state == Quit)                     // should check for quit here too\n            break;\n    }\n\n    wp_thread_exit (0);\n    return 0;\n}\n\n// Send the given stream to an available worker thread. In the background, the specified\n// stream will begin the packing operation. The &quot;free_wps&quot; flag indicates that the\n// WavpackStream structure should be freed once the unpack operation is complete because\n// it is a copy of the original created for this operation only.\n\nstatic void pack_samples_enqueue (WavpackStream *wps, int free_wps)\n{\n    WavpackContext *wpc = (WavpackContext *) wps-&gt;wpc;  // this is safe here because single-threaded\n    int i;\n\n    wp_mutex_obtain (wpc-&gt;mutex);\n\n    while (!wpc-&gt;workers_ready)                         // make sure a worker thread is ready\n        wp_condvar_wait (wpc-&gt;global_cond, wpc-&gt;mutex);\n\n    for (i = 0; i &lt; wpc-&gt;num_workers; ++i)\n        if (wpc-&gt;workers [i].state == Ready) {\n            wpc-&gt;workers [i].wps = wps;\n            wpc-&gt;workers [i].state = Running;\n            wpc-&gt;workers [i].free_wps = free_wps;\n            wp_condvar_signal (wpc-&gt;workers [i].worker_cond);\n            wpc-&gt;workers_ready--;\n            break;\n        }\n\n    wp_mutex_release (wpc-&gt;mutex);\n}\n\n// If there are streams that have completed the packing operation, send their packed\n// data to the block output device. Depending on the &quot;write_all_blocks&quot; parameter, this\n// will return either as soon as there is a single worker thread in the &quot;ready&quot; state\n// or once they&#x27;re all in the &quot;ready&quot; state. If there are workers available already,\n// it will return without doing anything. The &quot;result&quot; status passes through here and\n// indicates that one of the two possible errors occurred: the output buffer overflowed\n// or the write callback (to the user) failed.\n\nstatic int write_completed_blocks (WavpackContext *wpc, int write_all_blocks, int result)\n{\n    wp_mutex_obtain (wpc-&gt;mutex);\n\n    while (!wpc-&gt;workers_ready || (write_all_blocks &amp;&amp; wpc-&gt;workers_ready &lt; wpc-&gt;num_workers)) {\n        WorkerInfo *next_worker = NULL;\n        int i;\n\n        // loop through the worker threads to determine the lowest sample index\n        // (or stream index if the sample index is the same) that is either running\n        // or done (which will be the next one we send)\n\n        for (i = 0; i &lt; wpc-&gt;num_workers; ++i)\n            if (wpc-&gt;workers [i].state == Done || wpc-&gt;workers [i].state == Running)\n                if (!next_worker || wpc-&gt;workers [i].wps-&gt;sample_index &lt; next_worker-&gt;wps-&gt;sample_index ||\n                   (wpc-&gt;workers [i].wps-&gt;sample_index == next_worker-&gt;wps-&gt;sample_index &amp;&amp;\n                    wpc-&gt;workers [i].wps-&gt;stream_index &lt; next_worker-&gt;wps-&gt;stream_index))\n                        next_worker = &amp;wpc-&gt;workers [i];\n\n        // if the lowest stream is done, then we can send it now, otherwise wait\n\n        if (next_worker &amp;&amp; next_worker-&gt;state == Done) {\n            wp_mutex_release (wpc-&gt;mutex);\n            wpc-&gt;lossy_blocks |= next_worker-&gt;wps-&gt;lossy_blocks;\n\n            if (result &amp;&amp; !next_worker-&gt;result) {\n                strcpy (wpc-&gt;error_message, &quot;output buffer overflowed!&quot;);\n                result = next_worker-&gt;result;\n            }\n\n            result = write_stream_block (next_worker-&gt;wps, result);\n\n            if (next_worker-&gt;free_wps) {\n                free (next_worker-&gt;wps-&gt;pre_sample_buffer);\n                free (next_worker-&gt;wps-&gt;sample_buffer);\n                free (next_worker-&gt;wps-&gt;dsd.ptable);\n                free (next_worker-&gt;wps);\n            }\n\n            wp_mutex_obtain (wpc-&gt;mutex);\n            next_worker-&gt;state = Uninit;\n            wp_condvar_signal (next_worker-&gt;worker_cond);   // signal the thread so it can go ready\n        }\n        else\n            wp_condvar_wait (wpc-&gt;global_cond, wpc-&gt;mutex);\n    }\n\n    wp_mutex_release (wpc-&gt;mutex);\n\n    return result;\n}\n\n// Create the worker thread contexts and start the threads\n// (which should all quickly go to the ready state)\n\nstatic void worker_threads_create (WavpackContext *wpc)\n{\n    if (!wpc-&gt;workers) {\n        int i;\n\n        wp_mutex_init (wpc-&gt;mutex);\n        wp_condvar_init (wpc-&gt;global_cond);\n\n        wpc-&gt;workers = calloc (wpc-&gt;num_workers, sizeof (WorkerInfo));\n\n        for (i = 0; i &lt; wpc-&gt;num_workers; ++i) {\n            wpc-&gt;workers [i].mutex = &amp;wpc-&gt;mutex;\n            wpc-&gt;workers [i].global_cond = &amp;wpc-&gt;global_cond;\n            wpc-&gt;workers [i].workers_ready = &amp;wpc-&gt;workers_ready;\n            wp_condvar_init (wpc-&gt;workers [i].worker_cond);\n            wp_thread_create (wpc-&gt;workers [i].thread, pack_samples_worker_thread, &amp;wpc-&gt;workers [i]);\n\n            // gracefully handle failures in creating worker threads\n\n            if (!wpc-&gt;workers [i].thread) {\n                wp_condvar_delete (wpc-&gt;workers [i].worker_cond);\n                wpc-&gt;num_workers = i;\n                break;\n            }\n        }\n\n        if (!wpc-&gt;num_workers) {    // if we failed to start any workers, free the array\n            free (wpc-&gt;workers);\n            wpc-&gt;workers = NULL;\n        }\n    }\n}\n\n// Return TRUE if there is a worker thread available. Obviously this depends on\n// whether there are worker threads enabled and running, but it also depends\n// on whether there is actually a worker thread that&#x27;s not busy (however we\n// don&#x27;t count this as a requirement if there are many workers).\n\nstatic int worker_available (WavpackContext *wpc)\n{\n    int retval = FALSE;\n\n    if (wpc-&gt;num_workers &amp;&amp; wpc-&gt;workers) {\n        if (wpc-&gt;num_workers &lt; 4) {\n            wp_mutex_obtain (wpc-&gt;mutex);\n            retval = wpc-&gt;workers_ready;\n            wp_mutex_release (wpc-&gt;mutex);\n        }\n        else\n            retval = TRUE;\n    }\n\n    return retval;\n}\n\n#endif\n"}, "/project/WavPack/cli/wavpack.c": {"id": "/project/WavPack/cli/wavpack.c", "filePath": "/project/WavPack/cli/wavpack.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2024 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// wavpack.c\n\n// This is the main module for the WavPack command-line compressor.\n\n#if defined(_WIN32)\n#define WIN32_LEAN_AND_MEAN\n#include &lt;windows.h&gt;\n#include &lt;conio.h&gt;\n#include &lt;io.h&gt;\n#else\n#if defined(__OS2__)\n#define INCL_DOSPROCESS\n#include &lt;os2.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;sys/param.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;iconv.h&gt;\n#endif\n\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n\n#include &quot;wavpack.h&quot;\n#include &quot;utils.h&quot;\n#include &quot;md5.h&quot;\n\n#if (defined(__GNUC__) || defined(__sun)) &amp;&amp; !defined(_WIN32)\n#include &lt;unistd.h&gt;\n#include &lt;glob.h&gt;\n#include &lt;sys/time.h&gt;\n#else\n#include &lt;sys/timeb.h&gt;\n#endif\n\n#ifdef _WIN32\n#include &quot;win32_unicode_support.h&quot;\n#define fputs fputs_utf8\n#define fprintf fprintf_utf8\n#define remove(f) unlink_utf8(f)\n#define rename(o,n) rename_utf8(o,n)\n#define fopen(f,m) fopen_utf8(f,m)\n#define strdup(x) _strdup(x)\n#define stricmp(x,y) _stricmp(x,y)\n#define strdup(x) _strdup(x)\n#define exp2(e) pow(2.0,e)\n#else\n#define stricmp strcasecmp\n#endif\n\n///////////////////////////// local variable storage //////////////////////////\n\nstatic const char *sign_on = &quot;\\n&quot;\n&quot; WAVPACK  Hybrid Lossless Audio Compressor  %s Version %s\\n&quot;\n&quot; Copyright (c) 1998 - 2024 David Bryant.  All Rights Reserved.\\n\\n&quot;;\n\nstatic const char *version_warning = &quot;\\n&quot;\n&quot; WARNING: WAVPACK using libwavpack version %s, expected %s (see README)\\n\\n&quot;;\n\nstatic const char *usage =\n#if defined (_WIN32)\n&quot; Usage:   WAVPACK [-options] infile[.wav]|infile.ext|- [outfile[.wv]|outpath|-]\\n&quot;\n&quot;          WAVPACK --drop [-options] infile[.wav]|infile.ext [...]\\n&quot;\n&quot;             (default is lossless; infile may contain wildcards: ?,*)\\n\\n&quot;\n#else\n&quot; Usage:   WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\\n&quot;\n&quot;             (default is lossless; multiple input files allowed)\\n\\n&quot;\n#endif\n&quot; Utils:   WAVPACK:  create or transcode WavPack files\\n&quot;\n&quot;          WVUNPACK: unpack or verify existing WavPack files\\n&quot;\n&quot;          WVGAIN:   apply ReplayGain to WavPack files\\n&quot;\n&quot;          WVTAG:    apply or edit metadata tags on WavPack files\\n\\n&quot;\n&quot; Formats: .wav (default, bwf/rf64 okay)  .aif (Apple AIFF)\\n&quot;\n&quot;          .w64 (Sony Wave64)             .caf (Core Audio Format)\\n&quot;\n&quot;          .dff (Philips DSDIFF)          .dsf (Sony DSD stream)\\n&quot;\n&quot;          .wv (transcode from existing WavPack file, with tags)\\n\\n&quot;\n&quot; Options: -b&lt;n&gt; = enable hybrid compression, n = 2.0 to 23.9 bits/sample, or\\n&quot;\n&quot;                                             n = 24-9600 kbits/second (kbps)\\n&quot;\n&quot;                  (unless combined with -c this will be a lossy operation)\\n&quot;\n&quot;          -c  = create correction file (.wvc) for hybrid lossless mode\\n&quot;\n&quot;          -c&lt;n&gt; = shortcut for &#x27;-b&lt;n&gt; -c&#x27; to specify hybrid lossless mode\\n&quot;\n&quot;                  with a single option, n = 2.0 to 23.9 bits/sample, or\\n&quot;\n&quot;                                        n = 24-9600 kbits/second (kbps)\\n&quot;\n#ifdef _WIN32\n&quot;          --drop = drag-and-drop (multiple infiles only, no outfile spec)\\n&quot;\n#endif\n&quot;          -f  = fast mode (fast, but some compromise in compression ratio)\\n&quot;\n&quot;          -h  = high quality (better compression ratio, but slower)\\n&quot;\n&quot;          -m  = compute &amp; store MD5 signature of raw audio data\\n&quot;\n#ifdef _WIN32\n&quot;          --pause = pause before exiting (if console window disappears)\\n&quot;\n#else\n&quot;          -o FILENAME | PATH = specify output filename or path\\n&quot;\n#endif\n#ifdef ENABLE_THREADS\n&quot;          --threads = use multiple threads for faster operation\\n&quot;\n#endif\n&quot;          -v  = verify output file integrity after write (no pipes)\\n&quot;\n&quot;          -x  = extra encode processing (no decoding speed penalty)\\n&quot;\n&quot;          --help = complete help\\n\\n&quot;\n&quot; Web:     Visit www.wavpack.com for latest version and info\\n&quot;;\n\nstatic const char *help =\n#if defined (_WIN32)\n&quot; Usage:\\n&quot;\n&quot;    WAVPACK [-options] infile[.wav]|infile.ext|- [outfile[.wv]|outpath|-]\\n&quot;\n&quot;    WAVPACK --drop [-options] infile[.wav]|infile.ext [...]\\n\\n&quot;\n&quot;    The default operation is lossless. Wildcard characters (*,?) may be included\\n&quot;\n&quot;    in the filename and the source file type is automatically determined (see\\n&quot;\n&quot;    accepted formats below). Raw PCM or DSD may also be used (see --raw-pcm option).\\n\\n&quot;\n#else\n&quot; Usage:\\n&quot;\n&quot;    WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\\n\\n&quot;\n&quot;    The default operation is lossless. Multiple input files may be specified\\n&quot;\n&quot;    and the source file type is automatically determined (see accepted formats\\n&quot;\n&quot;    below). Raw PCM or DSD data may also be used (see --raw-pcm option).\\n\\n&quot;\n#endif\n&quot; All Utilities:             WAVPACK:  create or transcode WavPack files\\n&quot;\n&quot;                            WVUNPACK: unpack or verify existing WavPack files\\n&quot;\n&quot;                            WVGAIN:   apply ReplayGain to WavPack files\\n&quot;\n&quot;                            WVTAG:    apply or edit metadata tags on WavPack files\\n\\n&quot;\n&quot; Input Formats:             .wav (default, includes bwf/rf64 variants)\\n&quot;\n&quot;                            .wv  (WavPack transcode operation, tags copied)\\n&quot;\n&quot;                            .aif (Apple AIFF)\\n&quot;\n&quot;                            .caf (Core Audio Format)\\n&quot;\n&quot;                            .w64 (Sony Wave64)\\n&quot;\n&quot;                            .dff (Philips DSDIFF)\\n&quot;\n&quot;                            .dsf (Sony DSD stream)\\n\\n&quot;\n&quot; Options:\\n&quot;\n&quot;    -a                      Adobe Audition (CoolEdit) mode for 32-bit floats\\n&quot;\n&quot;    --allow-huge-tags       allow tag data up to 16 MB (embedding &gt; 1 MB is not\\n&quot;\n&quot;                             recommended for portable devices and may not work\\n&quot;\n&quot;                             with some programs including WavPack pre-4.70)\\n&quot;\n&quot;    -b&lt;n&gt;                   enable hybrid compression with specified bitrate:\\n&quot;\n&quot;                             n = 2.0 to 23.9 bits/sample, or\\n&quot;\n&quot;                             n = 24-9600 kbits/second (kbps)\\n&quot;\n&quot;                              add -c to create correction file (.wvc), otherwise\\n&quot;\n&quot;                              operation is lossy\\n&quot;\n&quot;    --blocksize=&lt;n&gt;         specify block size in samples (max = 131072 and\\n&quot;\n&quot;                               min = 16 with --merge-blocks, otherwise 128)\\n&quot;\n&quot;    -c                      hybrid lossless mode (use with -b&lt;n&gt; to create\\n&quot;\n&quot;                             correction file (.wvc) in hybrid mode)\\n&quot;\n&quot;    -c&lt;n&gt;                   shortcut for &#x27;-b&lt;n&gt; -c&#x27; to specify two-file hybrid\\n&quot;\n&quot;                             lossless mode (i.e., wv+wvc) with a single option:\\n&quot;\n&quot;                              n = 2.0 to 23.9 bits/sample, or\\n&quot;\n&quot;                              n = 24-9600 kbits/second (kbps)\\n&quot;\n&quot;    -cc                     maximum hybrid lossless compression (but degrades\\n&quot;\n&quot;                             decode speed and may result in lower quality)\\n&quot;\n&quot;    --channel-order=&lt;list&gt;  specify (comma separated) channel order if not\\n&quot;\n&quot;                             Microsoft standard (which is FL,FR,FC,LFE,BL,BR,\\n&quot;\n&quot;                             FLC,FRC,BC,SL,SR,TC,TFL,TFC,TFR,TBL,TBC,TBR);\\n&quot;\n&quot;                             specify &#x27;...&#x27; to indicate that channels are not\\n&quot;\n&quot;                             assigned to specific speakers, or terminate list\\n&quot;\n&quot;                             with &#x27;...&#x27; to indicate that any channels beyond\\n&quot;\n&quot;                             those specified are unassigned\\n&quot;\n&quot;    --cross-decorr          use cross-channel correlation in hybrid mode (on by\\n&quot;\n&quot;                             default in lossless mode and with -cc option)\\n&quot;\n&quot;    -d                      delete source file if successful (use with caution!)\\n&quot;\n#ifdef _WIN32\n&quot;    --drop                  drag-and-drop (multiple infiles only, no outfile spec)\\n&quot;\n#endif\n&quot;    -f                      fast mode (faster encode and decode, but some\\n&quot;\n&quot;                             compromise in compression ratio)\\n&quot;\n&quot;    --force-even-byte-depth ignore non-whole-byte bit depths (e.g., 12-bit or\\n&quot;\n&quot;                             20-bit) and round up to the next whole byte\\n&quot;\n&quot;    -g                      general/normal mode (cancels -f and -h options)\\n&quot;\n&quot;    -h                      high quality (better compression ratio, but slightly\\n&quot;\n&quot;                             slower encode and decode than normal mode)\\n&quot;\n&quot;    -hh                     very high quality (best compression, but slowest\\n&quot;\n&quot;                             and not recommended for vintage hardware use)\\n&quot;\n&quot;    --help                  this extended help display\\n&quot;\n&quot;    -i                      parse header for audio format but ignore length in\\n&quot;\n&quot;                             header and just assume everything to EOF is audio\\n&quot;\n&quot;    --import-id3            attempt to import ID3v2 tags from the trailer of files\\n&quot;\n&quot;                             (standard on DSF and AIF, optional on WAV and DSDIFF)\\n&quot;\n&quot;    -j&lt;n&gt;                   joint-stereo override (0 = left/right, 1 = mid/side)\\n&quot;\n#if defined (_WIN32) || defined (__OS2__)\n&quot;    -l                      run at lower priority for smoother multitasking\\n&quot;\n#endif\n&quot;    -m                      compute &amp; store MD5 signature of raw audio data\\n&quot;\n&quot;    --merge-blocks          merge consecutive blocks with equal redundancy\\n&quot;\n&quot;                             (used with --blocksize option and is useful for\\n&quot;\n&quot;                             files generated by the lossyWAV program or\\n&quot;\n&quot;                             decoded HDCD files)\\n&quot;\n&quot;    -n                      calculate average and peak quantization noise\\n&quot;\n&quot;                             (for hybrid mode only, reference fullscale sine)\\n&quot;\n&quot;    --no-overwrite          never overwrite existing files (and don&#x27;t ask)\\n&quot;\n#ifdef _WIN32\n&quot;    --no-utf8-convert       assume tag values read from files are already UTF-8,\\n&quot;\n&quot;                             don&#x27;t attempt to convert from local encoding\\n&quot;\n#else\n&quot;    --no-utf8-convert       don&#x27;t recode passed tags from local encoding to\\n&quot;\n&quot;                             UTF-8, assume they are in UTF-8 already\\n&quot;\n&quot;    -o FILENAME | PATH      specify output filename or path\\n&quot;\n#endif\n&quot;    --optimize-int32        optimizations for some specific 32-bit integer files\\n&quot;\n&quot;                             (e.g., integer files sourced from float data);\\n&quot;\n&quot;                             decoding files so created with previous revisions\\n&quot;\n&quot;                             will result in output with only 24-bit equivalent\\n&quot;\n&quot;                             resolution (but appropriately formatted); applies\\n&quot;\n&quot;                             only to the lossless compression mode\\n&quot;\n&quot;    --pair-unassigned-chans encode unassigned channels into stereo pairs\\n&quot;\n#ifdef _WIN32\n&quot;    --pause                 pause before exiting (if console window disappears)\\n&quot;\n#endif\n&quot;    --pre-quantize=bits     pre-quantize samples to &lt;bits&gt; BEFORE encoding and MD5\\n&quot;\n&quot;                             (common use would be --pre-quantize=20 for 24-bit or\\n&quot;\n&quot;                             float material recorded with typical converters)\\n&quot;\n&quot;    -q                      quiet (keep console output to a minimum)\\n&quot;\n&quot;    -r                      parse headers for audio information but do not store in\\n&quot;\n&quot;                             WavPack file (minimum header regenerated on unpack)\\n&quot;\n&quot;    --raw-pcm               input data is raw pcm (default is 44100 Hz, 16-bit\\n&quot;\n&quot;                             signed, 2-channels, little-endian)\\n&quot;\n&quot;    --raw-pcm=sr,bps[f|s|u],nch,[le|be]\\n&quot;\n&quot;                            input data is raw pcm with specified sample rate,\\n&quot;\n&quot;                             sample bit depth (float or signed or unsigned), number\\n&quot;\n&quot;                             of channels, and little-endian or big-endian\\n&quot;\n&quot;                             (defaulted parameters may be omitted)\\n&quot;\n&quot;    --raw-pcm-skip=begin[,end]\\n&quot;\n&quot;                            skip &lt;begin&gt; bytes before encoding (i.e., a header)\\n&quot;\n&quot;                             and &lt;end&gt; bytes at the end-of-file (i.e., a trailer)\\n&quot;\n&quot;    -s&lt;n&gt;                   override default noise shaping where n is a float\\n&quot;\n&quot;                             value between -1.0 and 1.0; negative values move noise\\n&quot;\n&quot;                             lower in freq, positive values move noise higher\\n&quot;\n&quot;                             in freq, use &#x27;0&#x27; for no shaping (white noise)\\n&quot;\n#ifdef ENABLE_THREADS\n&quot;    --threads[=n]           use multiple threads for faster operation, optional\\n&quot;\n&quot;                             &#x27;n&#x27; must be 1 - 12, 1 = single thread only\\n&quot;\n#endif\n&quot;    -t                      copy input file&#x27;s time stamp to output file(s)\\n&quot;\n&quot;    --use-dns               force use of dynamic noise shaping (hybrid mode only)\\n&quot;\n&quot;    -v                      verify output file integrity after write (no pipes)\\n&quot;\n&quot;    --version               write the version to stdout\\n&quot;\n&quot;    -w Encoder              write actual \\&quot;Encoder\\&quot; information to APEv2 tag\\n&quot;\n&quot;    -w Settings             write actual \\&quot;Settings\\&quot; information to APEv2 tag\\n&quot;\n&quot;    -w \\&quot;Field=Value\\&quot;        write specified text metadata to APEv2 tag\\n&quot;\n&quot;    -w \\&quot;Field=@file.ext\\&quot;    write specified text metadata from file to APEv2\\n&quot;\n&quot;                             tag, normally used for embedded cuesheets and logs\\n&quot;\n&quot;                             (field names \\&quot;Cuesheet\\&quot; and \\&quot;Log\\&quot;)\\n&quot;\n&quot;    --write-binary-tag \\&quot;Field=@file.ext\\&quot;\\n&quot;\n&quot;                            write the specified binary metadata file to APEv2\\n&quot;\n&quot;                             tag, normally used for cover art with the specified\\n&quot;\n&quot;                             field name \\&quot;Cover Art (Front)\\&quot;\\n&quot;\n&quot;    -x[n]                   extra encode processing (optional n = 0 to 6, 1=default)\\n&quot;\n&quot;                             -x0 no extra processing (fastest encode speed)\\n&quot;\n&quot;                             -x1 to -x3 to choose best of predefined filters\\n&quot;\n&quot;                             -x4 to -x6 to generate custom filters (very slow!)\\n&quot;\n&quot;    -y                      yes to all warnings (use with caution!)\\n&quot;\n#if defined (_WIN32)\n&quot;    -z                      don&#x27;t set console title to indicate progress\\n\\n&quot;\n#else\n&quot;    -z1                     set console title to indicate progress\\n\\n&quot;\n#endif\n&quot; Web:\\n&quot;\n&quot;     Visit www.wavpack.com for latest version and complete information\\n&quot;;\n\nstatic const char *speakers [] = {\n    &quot;FL&quot;, &quot;FR&quot;, &quot;FC&quot;, &quot;LFE&quot;, &quot;BL&quot;, &quot;BR&quot;, &quot;FLC&quot;, &quot;FRC&quot;, &quot;BC&quot;,\n    &quot;SL&quot;, &quot;SR&quot;, &quot;TC&quot;, &quot;TFL&quot;, &quot;TFC&quot;, &quot;TFR&quot;, &quot;TBL&quot;, &quot;TBC&quot;, &quot;TBR&quot;\n};\n\n#define NUM_SPEAKERS (sizeof (speakers) / sizeof (speakers [0]))\n\nint ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\nint ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\nint ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\nint ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\nint ParseDsfHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\nint ParseAiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\n\nstatic struct {\n    unsigned char id;\n    char *fourcc, *default_extension;\n    int (* ParseHeader) (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config);\n    int chunk_alignment;\n} file_formats [] = {\n    { WP_FORMAT_WAV,  &quot;RIFF&quot;, &quot;wav&quot;, ParseRiffHeaderConfig,   2 },\n    { WP_FORMAT_WAV,  &quot;RF64&quot;, &quot;wav&quot;, ParseRiffHeaderConfig,   2 },\n    { WP_FORMAT_WAV,  &quot;BW64&quot;, &quot;wav&quot;, ParseRiffHeaderConfig,   2 },\n    { WP_FORMAT_W64,  &quot;riff&quot;, &quot;w64&quot;, ParseWave64HeaderConfig, 8 },\n    { WP_FORMAT_CAF,  &quot;caff&quot;, &quot;caf&quot;, ParseCaffHeaderConfig,   1 },\n    { WP_FORMAT_DFF,  &quot;FRM8&quot;, &quot;dff&quot;, ParseDsdiffHeaderConfig, 2 },\n    { WP_FORMAT_DSF,  &quot;DSD &quot;, &quot;dsf&quot;, ParseDsfHeaderConfig,    1 },\n    { WP_FORMAT_AIF,  &quot;FORM&quot;, &quot;aif&quot;, ParseAiffHeaderConfig,   2 }\n};\n\n#define NUM_FILE_FORMATS (sizeof (file_formats) / sizeof (file_formats [0]))\n\n// this global is used to indicate the special &quot;debug&quot; mode where extra debug messages\n// are displayed and all messages are logged to the file \\wavpack.log\n\nint debug_logging_mode;\n\nstatic int overwrite_all, no_overwrite, num_files, file_index, copy_time, quiet_mode, verify_mode, delete_source,\n    no_utf8_convert, set_console_title, allow_huge_tags, quantize_bits, quantize_round, import_id3,\n    raw_pcm_skip_bytes_begin, raw_pcm_skip_bytes_end, worker_threads;\n\nstatic int num_channels_order;\nstatic unsigned char channel_order [18];\nstatic double encode_time_percent;\n\n// These two statics are used to keep track of tags that the user specifies on the\n// command line. The &quot;num_tag_strings&quot; and &quot;tag_strings&quot; fields in the WavpackConfig\n// structure are no longer used for anything (they should not have been there in\n// the first place).\n\nstatic int num_tag_items, total_tag_size;\n\nstatic struct tag_item {\n    char *item, *value, *ext;\n    int vsize, binary;\n} *tag_items;\n\n#if defined (_WIN32)\nstatic int pause_mode, drop_mode;\n#endif\n\n/////////////////////////// local function declarations ///////////////////////\n\nstatic FILE *wild_fopen (char *filename, const char *mode);\nstatic int pack_file (char *infilename, char *outfilename, char *out2filename, const WavpackConfig *config);\nstatic int pack_audio (WavpackContext *wpc, FILE *infile, int qmode, unsigned char *new_order, unsigned char *md5_digest_source);\nstatic int pack_dsd_audio (WavpackContext *wpc, FILE *infile, int qmode, unsigned char *new_order, unsigned char *md5_digest_source);\nstatic int repack_file (char *infilename, char *outfilename, char *out2filename, const WavpackConfig *config);\nstatic int repack_audio (WavpackContext *wpc, WavpackContext *infile, unsigned char *md5_digest_source);\nstatic int verify_audio (char *infilename, unsigned char *md5_digest_source);\nstatic void make_settings_string (char *settings, WavpackConfig *config);\nstatic void display_progress (double file_progress);\nstatic void TextToUTF8 (void *string, int len);\n\n// The &quot;main&quot; function for the command-line WavPack compressor. Note that on Windows\n// this is actually a static function that is called from the &quot;real&quot; main() defined\n// immediately afterward that converts the wchar argument list into UTF-8 strings\n// and sets the console to UTF-8 for better Unicode support.\n\n#ifdef _WIN32\nstatic int wavpack_main(int argc, char **argv)\n#else\nint main (int argc, char **argv)\n#endif\n{\n#ifdef __EMX__ /* OS/2 */\n    _wildcard (&amp;argc, &amp;argv);\n#endif\n    int error_count = 0, tag_next_arg = 0, output_spec = 0, argc_fn = 0, use_stdin = 0, use_stdout = 0;\n    char *outfilename = NULL, *out2filename = NULL;\n    char selfname [PATH_MAX];\n    char **argv_fn = NULL;\n    char **matches = NULL;\n    WavpackConfig config;\n    int result, argi, i;\n    int warnings = 0;\n\n#if defined(_WIN32)\n    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))\n#endif\n    strncpy (selfname, *argv, sizeof (selfname) - 1);\n    selfname [sizeof (selfname) - 1] = &#x27;\\0&#x27;;\n\n    if (filespec_name (selfname)) {\n        char *filename = filespec_name (selfname);\n\n        if (strstr (filename, &quot;ebug&quot;) || strstr (filename, &quot;DEBUG&quot;))\n            debug_logging_mode = TRUE;\n\n        while (strchr (filename, &#x27;{&#x27;)) {\n            char *open_brace = strchr (filename, &#x27;{&#x27;);\n            char *close_brace = strchr (open_brace, &#x27;}&#x27;);\n\n            if (!close_brace)\n                break;\n\n            if (close_brace - open_brace &gt; 1) {\n                int option_len = (int)(close_brace - open_brace) - 1;\n                char *option = malloc (option_len + 1);\n\n                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);\n                memcpy (option, open_brace + 1, option_len);\n                argv_fn [argc_fn - 1] = option;\n                option [option_len] = 0;\n\n                if (debug_logging_mode)\n                    error_line (&quot;file arg %d: %s&quot;, argc_fn, option);\n            }\n\n            filename = close_brace;\n        }\n    }\n\n    if (debug_logging_mode) {\n        char **argv_t = argv;\n        int argc_t = argc;\n\n        while (--argc_t)\n            error_line (&quot;cli arg %d: %s&quot;, argc - argc_t, *++argv_t);\n    }\n\n#if defined (_WIN32)\n    set_console_title = 1;      // on Windows, we default to messing with the console title\n#endif                          // on Linux, this is considered uncool to do by default\n\n    CLEAR (config);\n\n    // loop through command-line arguments\n\n    for (argi = 0; argi &lt; argc + argc_fn - 1; ++argi) {\n        char *argcp;\n\n        if (argi &lt; argc_fn)\n            argcp = argv_fn [argi];\n        else\n            argcp = argv [argi - argc_fn + 1];\n\n        if (argcp [0] == &#x27;-&#x27; &amp;&amp; argcp [1] == &#x27;-&#x27; &amp;&amp; argcp [2]) {\n            char *long_option = argcp + 2, *long_param = long_option;\n\n            while (*long_param)\n                if (*long_param++ == &#x27;=&#x27;)\n                    break;\n\n            if (!strcmp (long_option, &quot;help&quot;)) {                        // --help\n                printf (&quot;%s&quot;, help);\n                return 0;\n            }\n            else if (!strcmp (long_option, &quot;version&quot;)) {                // --version\n                printf (&quot;wavpack %s\\n&quot;, PACKAGE_VERSION);\n                printf (&quot;libwavpack %s\\n&quot;, WavpackGetLibraryVersionString ());\n                return 0;\n            }\n#ifdef _WIN32\n            else if (!strcmp (long_option, &quot;pause&quot;))                    // --pause\n                pause_mode = 1;\n            else if (!strcmp (long_option, &quot;drop&quot;))                     // --drop\n                drop_mode = 1;\n#endif\n            else if (!strcmp (long_option, &quot;optimize-int32&quot;))           // --optimize-int32\n                config.flags |= CONFIG_OPTIMIZE_32BIT;\n            else if (!strcmp (long_option, &quot;optimize-mono&quot;))            // --optimize-mono\n                error_line (&quot;warning: --optimize-mono deprecated, now enabled by default&quot;);\n            else if (!strcmp (long_option, &quot;dns&quot;)) {                    // --dns\n                error_line (&quot;warning: --dns deprecated, use --use-dns&quot;);\n                ++error_count;\n            }\n            else if (!strcmp (long_option, &quot;use-dns&quot;))                  // --use-dns\n                config.flags |= CONFIG_DYNAMIC_SHAPING;\n            else if (!strcmp (long_option, &quot;cross-decorr&quot;))             // --cross-decorr\n                config.flags |= CONFIG_CROSS_DECORR;\n            else if (!strcmp (long_option, &quot;merge-blocks&quot;))             // --merge-blocks\n                config.flags |= CONFIG_MERGE_BLOCKS;\n            else if (!strcmp (long_option, &quot;pair-unassigned-chans&quot;))    // --pair-unassigned-chans\n                config.flags |= CONFIG_PAIR_UNDEF_CHANS;\n            else if (!strcmp (long_option, &quot;force-even-byte-depth&quot;))    // --force-even-byte_depth\n                config.qmode |= QMODE_EVEN_BYTE_DEPTH;\n            else if (!strcmp (long_option, &quot;import-id3&quot;))               // --import-id3\n                import_id3 = 1;\n            else if (!strcmp (long_option, &quot;no-utf8-convert&quot;))          // --no-utf8-convert\n                no_utf8_convert = 1;\n            else if (!strcmp (long_option, &quot;no-overwrite&quot;))             // --no-overwrite\n                no_overwrite = 1;\n            else if (!strcmp (long_option, &quot;allow-huge-tags&quot;))          // --allow-huge-tags\n                allow_huge_tags = 1;\n            else if (!strcmp (long_option, &quot;write-binary-tag&quot;))         // --write-binary-tag\n                tag_next_arg = 2;\n            else if (!strncmp (long_option, &quot;raw-pcm-skip&quot;, 12)) {      // --raw-pcm-skip\n                raw_pcm_skip_bytes_begin = strtol (long_param, &amp;long_param, 10);\n\n                if (*long_param == &#x27;,&#x27;)\n                    raw_pcm_skip_bytes_end = strtol (++long_param, &amp;long_param, 10);\n\n                if (*long_param || raw_pcm_skip_bytes_begin &lt; 0 || raw_pcm_skip_bytes_end &lt; 0) {\n                    error_line (&quot;syntax error in raw-pcm-skip specification!&quot;);\n                    ++error_count;\n                }\n\n                error_line (&quot;raw_pcm_skip = %d, %d bytes&quot;, raw_pcm_skip_bytes_begin, raw_pcm_skip_bytes_end);\n            }\n            else if (!strncmp (long_option, &quot;raw-pcm&quot;, 7)) {            // --raw-pcm &amp; --raw-pcm-ex\n                int extended = !strncmp (long_option, &quot;raw-pcm-ex&quot;, 10);\n                int params [] = { 44100, 16, 2 };\n                int pi, fp = 0, be = 0, us = 0, s = 0;\n\n                for (pi = 0; *long_param &amp;&amp; pi &lt; 3; ++pi) {\n                    if (isdigit (*long_param))\n                        params [pi] = strtol (long_param, &amp;long_param, 10);\n\n                    if (pi == 1) {\n                        if (*long_param == &#x27;f&#x27; || *long_param == &#x27;F&#x27;) {\n                            long_param++;\n                            fp = 1;\n                        }\n                        else if (*long_param == &#x27;u&#x27; || *long_param == &#x27;U&#x27;) {\n                            long_param++;\n                            us = 1;\n                        }\n                        else if (*long_param == &#x27;s&#x27; || *long_param == &#x27;S&#x27;) {\n                            long_param++;\n                            s = 1;\n                        }\n                    }\n\n                    if (*long_param == &#x27;,&#x27;)\n                        long_param++;\n                    else\n                        break;\n                }\n\n                if (*long_param &amp;&amp; pi == 3) {\n                    if (!stricmp (long_param, &quot;be&quot;)) {\n                        long_param += 2;\n                        be = 1;\n                    }\n                    else if (!stricmp (long_param, &quot;le&quot;))\n                        long_param += 2;\n                }\n\n                if (*long_param) {\n                    error_line (&quot;syntax error in raw PCM specification!&quot;);\n                    ++error_count;\n                }\n                else if (params [0] &lt; 1 || params [0] &gt; 1000000000 ||\n                    params [1] &lt; 1 || params [1] &gt; 32 || (fp &amp;&amp; params [1] != 32) ||\n                    params [2] &lt; 1 || params [2] &gt; (extended ? WAVPACK_MAX_CHANS : WAVPACK_MAX_CLI_CHANS)) {\n                        error_line (&quot;argument range error in raw PCM specification!&quot;);\n                        ++error_count;\n                }\n                else if (params [1] == 1) {\n                    config.sample_rate = (params [0] + 7) / 8;\n                    config.bits_per_sample = params [1] * 8;\n                    config.bytes_per_sample = 1;\n                    config.num_channels = params [2];\n                    config.qmode |= QMODE_DSD_MSB_FIRST | QMODE_RAW_PCM;\n                }\n                else {\n                    config.sample_rate = params [0];\n                    config.bits_per_sample = params [1];\n                    config.bytes_per_sample = (params [1] + 7) / 8;\n                    config.num_channels = params [2];\n                    config.float_norm_exp = fp ? 127 : 0;\n                    config.qmode |= QMODE_RAW_PCM;\n\n                    if (params [1] &gt; 8) {\n                        if (us)\n                            config.qmode |= QMODE_UNSIGNED_WORDS;\n\n                        if (be)\n                            config.qmode |= QMODE_BIG_ENDIAN;\n                    }\n                    else if (s)\n                        config.qmode |= QMODE_SIGNED_BYTES;\n                }\n            }\n            else if (!strncmp (long_option, &quot;blocksize&quot;, 9)) {          // --blocksize\n                config.block_samples = strtol (long_param, NULL, 10);\n\n                if (config.block_samples &lt; 16 || config.block_samples &gt; 131072) {\n                    error_line (&quot;invalid blocksize!&quot;);\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, &quot;channel-order&quot;, 13)) {      // --channel-order\n                char name [6], channel_error = 0;\n                uint32_t mask = 0;\n                int chan, ci, si;\n\n                for (chan = 0; chan &lt; sizeof (channel_order); ++chan) {\n\n                    if (!*long_param)\n                        break;\n\n                    if (*long_param == &#x27;.&#x27;) {\n                        if (*++long_param == &#x27;.&#x27; &amp;&amp; *++long_param == &#x27;.&#x27; &amp;&amp; !*++long_param)\n                            config.qmode |= QMODE_CHANS_UNASSIGNED;\n                        else\n                            channel_error = 1;\n\n                        break;\n                    }\n\n                    for (ci = 0; isalpha (*long_param) &amp;&amp; ci &lt; sizeof (name) - 1; ci++)\n                        name [ci] = *long_param++;\n\n                    if (!ci) {\n                        channel_error = 1;\n                        break;\n                    } \n\n                    name [ci] = 0;\n\n                    for (si = 0; si &lt; NUM_SPEAKERS; ++si)\n                        if (!stricmp (name, speakers [si])) {\n                            if (mask &amp; (1L &lt;&lt; si))\n                                channel_error = 1;\n\n                            channel_order [chan] = si;\n                            mask |= (1L &lt;&lt; si);\n                            break;\n                        }\n\n                    if (channel_error || si == NUM_SPEAKERS) {\n                        error_line (&quot;unknown or repeated channel spec: %s!&quot;, name);\n                        channel_error = 1;\n                        break;\n                    } \n\n                    if (*long_param &amp;&amp; *long_param++ != &#x27;,&#x27;) {\n                        channel_error = 1;\n                        break;\n                    } \n                }\n\n                if (channel_error) {\n                    error_line (&quot;syntax error in channel order specification!&quot;);\n                    ++error_count;\n                }\n                else if (*long_param) {\n                    error_line (&quot;too many channels specified!&quot;);\n                    ++error_count;\n                }\n                else {\n                    config.channel_mask = mask;\n                    num_channels_order = chan;\n                }\n            }\n            else if (!strncmp (long_option, &quot;pre-quantize-round&quot;, 18)) {    // --pre-quantize-round=\n                quantize_round = quantize_bits = strtol(long_param, NULL, 10);\n\n                if (quantize_bits &lt; 4 || quantize_bits &gt; 32) {\n                    error_line (&quot;invalid quantize bits!&quot;);\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, &quot;pre-quantize&quot;, 12)) {          // --pre-quantize=\n                quantize_bits = strtol(long_param, NULL, 10);\n\n                if (quantize_bits &lt; 4 || quantize_bits &gt; 32) {\n                    error_line (&quot;invalid quantize bits!&quot;);\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, &quot;threads&quot;, 7)) {                // --threads\n#ifdef ENABLE_THREADS\n                if (isdigit (*long_param)) {\n                    // &quot;worker_threads&quot; doesn&#x27;t include main thread, so subtract 1 from user value\n                    worker_threads = strtol (long_param, &amp;long_param, 10) - 1;\n\n                    if (worker_threads &lt; 0 || worker_threads &gt; 11) {\n                        error_line (&quot;specified thread count must be 1 - 12!&quot;);\n                        ++error_count;\n                    }\n                }\n                else\n                    worker_threads = 4;             // 4 is a good default for now\n\n                config.worker_threads = worker_threads;\n#else\n                error_line (&quot;warning: --threads not enabled, ignoring option!&quot;);\n#endif\n            }\n            else {\n                error_line (&quot;unknown option: %s !&quot;, long_option);\n                ++error_count;\n            }\n        }\n#if defined (_WIN32)\n        else if ((argcp [0] == &#x27;-&#x27; || argcp [0] == &#x27;/&#x27;) &amp;&amp; argcp [1])\n#else\n        else if (argcp [0] == &#x27;-&#x27; &amp;&amp; argcp [1])\n#endif\n            while (*++argcp)\n                switch (*argcp) {\n\n                    case &#x27;Y&#x27;: case &#x27;y&#x27;:\n                        overwrite_all = 1;\n                        break;\n\n                    case &#x27;D&#x27;: case &#x27;d&#x27;:\n                        delete_source = 1;\n                        break;\n\n                    case &#x27;X&#x27;: case &#x27;x&#x27;:\n                        if (isdigit (*++argcp))\n                            config.xmode = strtol (argcp, &amp;argcp, 10);\n                        else\n                            config.xmode = 1;   // &#x27;x&#x27; with no value specified = 1\n\n                        if (config.xmode &lt; 0 || config.xmode &gt; 6) {\n                            error_line (&quot;extra mode only goes from 0 to 6!&quot;);\n                            ++error_count;\n                        }\n                        else if (config.xmode)\n                            config.flags |= CONFIG_EXTRA_MODE;\n                        else\n                            config.flags &amp;= ~CONFIG_EXTRA_MODE;\n\n                        --argcp;\n                        break;\n\n                    case &#x27;F&#x27;: case &#x27;f&#x27;:\n                        config.flags &amp;= ~(CONFIG_HIGH_FLAG | CONFIG_VERY_HIGH_FLAG);\n                        config.flags |= CONFIG_FAST_FLAG;\n                        break;\n\n                    case &#x27;G&#x27;: case &#x27;g&#x27;:\n                        config.flags &amp;= ~(CONFIG_FAST_FLAG | CONFIG_HIGH_FLAG | CONFIG_VERY_HIGH_FLAG);\n                        break;\n\n                    case &#x27;H&#x27;: case &#x27;h&#x27;:\n                        config.flags &amp;= ~CONFIG_FAST_FLAG;\n\n                        if (config.flags &amp; CONFIG_HIGH_FLAG)\n                            config.flags |= CONFIG_VERY_HIGH_FLAG;\n                        else\n                            config.flags |= CONFIG_HIGH_FLAG;\n\n                        break;\n\n                    case &#x27;N&#x27;: case &#x27;n&#x27;:\n                        config.flags |= CONFIG_CALC_NOISE;\n                        break;\n\n                    case &#x27;A&#x27;: case &#x27;a&#x27;:\n                        config.qmode |= QMODE_ADOBE_MODE;\n                        break;\n#if defined (_WIN32)\n                    case &#x27;L&#x27;: case &#x27;l&#x27;:\n                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);\n                        break;\n#elif defined (__OS2__)\n                    case &#x27;L&#x27;: case &#x27;l&#x27;:\n                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);\n                        break;\n#endif\n#if defined (_WIN32)\n                    case &#x27;O&#x27;: case &#x27;o&#x27;:  // ignore -o in Windows to be Linux compatible\n                        break;\n#else\n                    case &#x27;O&#x27;: case &#x27;o&#x27;:\n                        output_spec = 1;\n                        break;\n#endif\n                    case &#x27;T&#x27;: case &#x27;t&#x27;:\n                        copy_time = 1;\n                        break;\n\n                    case &#x27;Q&#x27;: case &#x27;q&#x27;:\n                        quiet_mode = 1;\n                        break;\n\n                    case &#x27;Z&#x27;: case &#x27;z&#x27;:\n                        set_console_title = strtol (++argcp, &amp;argcp, 10);\n                        --argcp;\n                        break;\n\n                    case &#x27;M&#x27;: case &#x27;m&#x27;:\n                        config.flags |= CONFIG_MD5_CHECKSUM;\n                        break;\n\n                    case &#x27;I&#x27;: case &#x27;i&#x27;:\n                        config.qmode |= QMODE_IGNORE_LENGTH;\n                        break;\n\n                    case &#x27;R&#x27;: case &#x27;r&#x27;:\n                        config.qmode |= QMODE_NO_STORE_WRAPPER;\n                        break;\n\n                    case &#x27;V&#x27;: case &#x27;v&#x27;:\n                        verify_mode = 1;\n                        break;\n\n                    case &#x27;C&#x27;: case &#x27;c&#x27;:\n                        if (config.flags &amp; CONFIG_CREATE_WVC)\n                            config.flags |= CONFIG_OPTIMIZE_WVC;\n                        else\n                            config.flags |= CONFIG_CREATE_WVC;\n\n                        if (!isdigit (argcp [1]))       // if no number follows, we&#x27;re done; otherwise\n                            break;                      // use numeric parameter for -b option\n\n                    case &#x27;B&#x27;: case &#x27;b&#x27;:\n                        config.flags |= CONFIG_HYBRID_FLAG;\n                        config.bitrate = (float) strtod (++argcp, &amp;argcp);\n                        --argcp;\n\n                        if (config.bitrate &lt; 2.0 || config.bitrate &gt; 9600.0) {\n                            error_line (&quot;hybrid spec must be 2.0 to 9600!&quot;);\n                            ++error_count;\n                        }\n\n                        if (config.bitrate &gt;= 24.0)\n                            config.flags |= CONFIG_BITRATE_KBPS;\n\n                        break;\n\n                    case &#x27;J&#x27;: case &#x27;j&#x27;:\n                        switch (strtol (++argcp, &amp;argcp, 10)) {\n\n                            case 0:\n                                config.flags |= CONFIG_JOINT_OVERRIDE;\n                                config.flags &amp;= ~CONFIG_JOINT_STEREO;\n                                break;\n\n                            case 1:\n                                config.flags |= (CONFIG_JOINT_OVERRIDE | CONFIG_JOINT_STEREO);\n                                break;\n\n                            default:\n                                error_line (&quot;-j0 or -j1 only!&quot;);\n                                ++error_count;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case &#x27;S&#x27;: case &#x27;s&#x27;:\n                        config.shaping_weight = (float) strtod (++argcp, &amp;argcp);\n\n                        if (!config.shaping_weight) {\n                            config.flags |= CONFIG_SHAPE_OVERRIDE;\n                            config.flags &amp;= ~CONFIG_HYBRID_SHAPE;\n                        }\n                        else if (config.shaping_weight &gt;= -1.0 &amp;&amp; config.shaping_weight &lt;= 1.0)\n                            config.flags |= (CONFIG_HYBRID_SHAPE | CONFIG_SHAPE_OVERRIDE);\n                        else {\n                            error_line (&quot;-s-1.00 to -s1.00 only!&quot;);\n                            ++error_count;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case &#x27;W&#x27;: case &#x27;w&#x27;:\n                        if (++tag_next_arg == 2) {\n                            error_line (&quot;warning: -ww deprecated, use --write-binary-tag&quot;);\n                            ++error_count;\n                        }\n\n                        break;\n\n                    default:\n                        error_line (&quot;illegal option: %c !&quot;, *argcp);\n                        ++error_count;\n                }\n        else if (tag_next_arg) {\n            char *cp;\n\n            // check for and allow &quot;encoder&quot; or &quot;settings&quot; without a value and create\n            // an appropriate value for them (otherwise missing value is an error)\n\n            if (!stricmp (argcp, &quot;encoder&quot;)) {\n                char *tag_arg = malloc (80);\n                sprintf (tag_arg, &quot;%s=WavPack %s&quot;, argcp, PACKAGE_VERSION);\n                argcp = tag_arg;\n            }\n            else if (!stricmp (argcp, &quot;settings&quot;)) {\n                char settings [256], *tag_arg;\n\n                make_settings_string (settings, &amp;config);\n                tag_arg = malloc (strlen (settings) + 16);\n                sprintf (tag_arg, &quot;%s=%s&quot;, argcp, settings);\n                argcp = tag_arg;\n            }\n\n            cp = strchr (argcp, &#x27;=&#x27;);\n\n            if (cp &amp;&amp; cp &gt; argcp) {\n                int i = num_tag_items;\n\n                tag_items = realloc (tag_items, ++num_tag_items * sizeof (*tag_items));\n                tag_items [i].item = malloc (cp - argcp + 1);\n                memcpy (tag_items [i].item, argcp, cp - argcp);\n                tag_items [i].item [cp - argcp] = 0;\n                tag_items [i].vsize = (int) strlen (cp + 1);\n                tag_items [i].value = malloc (tag_items [i].vsize + 1);\n                strcpy (tag_items [i].value, cp + 1);\n                tag_items [i].binary = (tag_next_arg == 2);\n                tag_items [i].ext = NULL;\n            }\n            else {\n                error_line (&quot;error in tag spec: %s !&quot;, argcp);\n                ++error_count;\n            }\n\n            tag_next_arg = 0;\n        }\n        else if (argi &lt; argc_fn) {\n            error_line (&quot;invalid use of filename-embedded args: %s !&quot;, argcp);\n            ++error_count;\n        }\n#if defined (_WIN32)\n        else if (drop_mode || !num_files) {\n            matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n            matches [num_files] = malloc (strlen (argcp) + 10);\n            strcpy (matches [num_files], argcp);\n            use_stdin |= (*argcp == &#x27;-&#x27;);\n\n            if (*(matches [num_files]) != &#x27;-&#x27; &amp;&amp; *(matches [num_files]) != &#x27;@&#x27; &amp;&amp;\n                !filespec_ext (matches [num_files]))\n                    strcat (matches [num_files], (config.qmode &amp; QMODE_RAW_PCM) ? &quot;.raw&quot; : &quot;.wav&quot;);\n\n            num_files++;\n        }\n        else if (!outfilename) {\n            outfilename = malloc (strlen (argcp) + PATH_MAX);\n            strcpy (outfilename, argcp);\n            use_stdout = (*argcp == &#x27;-&#x27;);\n        }\n        else if (!out2filename) {\n            out2filename = malloc (strlen (argcp) + PATH_MAX);\n            strcpy (out2filename, argcp);\n        }\n        else {\n            error_line (&quot;extra unknown argument: %s !&quot;, argcp);\n            ++error_count;\n        }\n#else\n        else if (output_spec) {\n            outfilename = malloc (strlen (argcp) + PATH_MAX);\n            strcpy (outfilename, argcp);\n            use_stdout = (*argcp == &#x27;-&#x27;);\n            output_spec = 0;\n        }\n        else {\n            matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n            matches [num_files] = malloc (strlen (argcp) + 10);\n            strcpy (matches [num_files], argcp);\n            use_stdin |= (*argcp == &#x27;-&#x27;);\n\n            if (*(matches [num_files]) != &#x27;-&#x27; &amp;&amp; *(matches [num_files]) != &#x27;@&#x27; &amp;&amp;\n                !filespec_ext (matches [num_files]))\n                    strcat (matches [num_files], (config.qmode &amp; QMODE_RAW_PCM) ? &quot;.raw&quot; : &quot;.wav&quot;);\n\n            num_files++;\n        }\n#endif\n        if (argi &lt; argc_fn)\n            free (argv_fn [argi]);\n    }\n\n    free (argv_fn);\n\n    setup_break ();     // set up console and detect ^C and ^Break\n\n    // check for various command-line argument problems\n\n    if (output_spec) {\n        error_line (&quot;no output filename or path specified with -o option!&quot;);\n        ++error_count;\n    }\n\n    if (use_stdin &amp;&amp; num_files &gt; 1) {\n        error_line (&quot;when stdin is used for input, it must be the only file!&quot;);\n        ++error_count;\n    }\n\n    if (use_stdin &amp;&amp; !outfilename)  // for stdin source, no output specification implies stdout\n        use_stdout = 1;\n\n    if (overwrite_all &amp;&amp; no_overwrite) {\n        error_line (&quot;overwrite all and no overwrite and mutually exclusive!&quot;);\n        ++error_count;\n    }\n\n    if (tag_next_arg) {\n        error_line (&quot;no tag specified with %s option!&quot;, tag_next_arg == 1 ? &quot;-w&quot; : &quot;--write-binary-tag&quot;);\n        ++error_count;\n    }\n\n    if ((config.qmode &amp; QMODE_IGNORE_LENGTH) &amp;&amp; use_stdin &amp;&amp; use_stdout &amp;&amp; !overwrite_all) {\n        error_line (&quot;can&#x27;t ignore length in header when both input and output are pipes, &#x27;-y&#x27; to override&quot;);\n        ++error_count;\n    }\n\n    if ((config.qmode &amp; QMODE_RAW_PCM) &amp;&amp; use_stdin &amp;&amp; use_stdout &amp;&amp; !overwrite_all) {\n        error_line (&quot;can&#x27;t process raw PCM when both input and output are pipes, &#x27;-y&#x27; to override&quot;);\n        ++error_count;\n    }\n\n    if (verify_mode &amp;&amp; use_stdout) {\n        error_line (&quot;can&#x27;t verify output file when using stdout!&quot;);\n        ++error_count;\n    }\n\n    if (config.flags &amp; CONFIG_HYBRID_FLAG) {\n        if ((config.flags &amp; CONFIG_OPTIMIZE_32BIT) &amp;&amp; !(config.flags &amp; CONFIG_CREATE_WVC)) {\n            error_line (&quot;--optimize-int32 option is for lossless mode only!&quot;);\n            ++error_count;\n        }\n        if ((config.flags &amp; CONFIG_CREATE_WVC) &amp;&amp; use_stdout) {\n            error_line (&quot;can&#x27;t create correction file when using stdout!&quot;);\n            ++error_count;\n        }\n        if (config.flags &amp; CONFIG_MERGE_BLOCKS) {\n            error_line (&quot;--merge-blocks option is for lossless mode only!&quot;);\n            ++error_count;\n        }\n        if ((config.flags &amp; CONFIG_SHAPE_OVERRIDE) &amp;&amp; (config.flags &amp; CONFIG_DYNAMIC_SHAPING)) {\n            error_line (&quot;-s and --use-dns options are mutually exclusive!&quot;);\n            ++error_count;\n        }\n    }\n    else {\n        if (config.flags &amp; (CONFIG_CALC_NOISE | CONFIG_SHAPE_OVERRIDE | CONFIG_CREATE_WVC | CONFIG_DYNAMIC_SHAPING)) {\n            error_line (&quot;-c, -n, -s, and --use-dns options are for hybrid mode (-b) only!&quot;);\n            ++error_count;\n        }\n    }\n\n    if (config.flags &amp; CONFIG_MERGE_BLOCKS) {\n        if (!config.block_samples) {\n            error_line (&quot;--merge-blocks only makes sense when --blocksize is specified!&quot;);\n            ++error_count;\n        }\n    }\n    else if (config.block_samples &amp;&amp; config.block_samples &lt; 128) {\n        error_line (&quot;minimum blocksize is 128 when --merge-blocks is not specified!&quot;);\n        ++error_count;\n    }\n\n    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {\n        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);\n        fflush (stderr);\n    }\n    else if (!quiet_mode &amp;&amp; !error_count) {\n        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());\n        fflush (stderr);\n    }\n\n    // Loop through any tag specification strings and check for file access, convert text\n    // strings to UTF-8, and otherwise prepare for writing to APE tags. This is done here\n    // rather than after encoding so that any errors can be reported to the user now.\n\n    for (i = 0; i &lt; num_tag_items; ++i) {\n#ifdef _WIN32\n        int tag_came_from_file = 0;\n#endif\n        if (*tag_items [i].value == &#x27;@&#x27;) {\n            char *fn = tag_items [i].value + 1, *new_value = NULL;\n            FILE *file = wild_fopen (fn, &quot;rb&quot;);\n\n            // if the file is not found, try using any input and output directories that the\n            // user may have specified on the command line\n\n            if (!file &amp;&amp; num_files &amp;&amp; filespec_name (matches [0]) &amp;&amp; *matches [0] != &#x27;-&#x27;) {\n                char *temp = malloc (strlen (matches [0]) + PATH_MAX);\n\n                strcpy (temp, matches [0]);\n                strcpy (filespec_name (temp), fn);\n                file = wild_fopen (temp, &quot;rb&quot;);\n                free (temp);\n            }\n\n            if (!file &amp;&amp; outfilename &amp;&amp; filespec_name (outfilename) &amp;&amp; *outfilename != &#x27;-&#x27;) {\n                char *temp = malloc (strlen (outfilename) + PATH_MAX);\n\n                strcpy (temp, outfilename);\n                strcpy (filespec_name (temp), fn);\n                file = wild_fopen (temp, &quot;rb&quot;);\n                free (temp);\n            }\n\n            if (file) {\n                uint32_t bcount;\n\n                tag_items [i].vsize = (int) DoGetFileSize (file);\n\n                if (filespec_ext (fn))\n                    tag_items [i].ext = strdup (filespec_ext (fn));\n\n                if (tag_items [i].vsize &lt; 1048576 * (allow_huge_tags ? 16 : 1)) {\n                    new_value = malloc (tag_items [i].vsize + 2);\n                    memset (new_value, 0, tag_items [i].vsize + 2);\n\n                    if (!DoReadFile (file, new_value, tag_items [i].vsize, &amp;bcount) ||\n                        bcount != tag_items [i].vsize) {\n                            free (new_value);\n                            new_value = NULL;\n                        }\n                }\n\n                DoCloseHandle (file);\n            }\n\n            if (!new_value) {\n                error_line (&quot;error in tag spec: %s !&quot;, tag_items [i].value);\n                ++error_count;\n            }\n            else {\n                free (tag_items [i].value);\n                tag_items [i].value = new_value;\n#ifdef _WIN32\n                tag_came_from_file = 1;\n#endif\n            }\n        }\n        else if (tag_items [i].binary) {\n            error_line (&quot;binary tags must be from files: %s !&quot;, tag_items [i].value);\n            ++error_count;\n        }\n\n        if (tag_items [i].binary) {\n            int isize = (int) strlen (tag_items [i].item);\n            int esize = tag_items [i].ext ? (int) strlen (tag_items [i].ext) : 0;\n\n            tag_items [i].value = realloc (tag_items [i].value, isize + esize + 1 + tag_items [i].vsize);\n            memmove (tag_items [i].value + isize + esize + 1, tag_items [i].value, tag_items [i].vsize);\n            strcpy (tag_items [i].value, tag_items [i].item);\n\n            if (tag_items [i].ext)\n                strcat (tag_items [i].value, tag_items [i].ext);\n\n            tag_items [i].vsize += isize + esize + 1;\n        }\n        else if (tag_items [i].vsize) {\n            tag_items [i].value = realloc (tag_items [i].value, tag_items [i].vsize * 2 + 1);\n\n#ifdef _WIN32\n            if (tag_came_from_file &amp;&amp; !no_utf8_convert)\n#else\n            if (!no_utf8_convert)\n#endif\n                TextToUTF8 (tag_items [i].value, (int) tag_items [i].vsize * 2 + 1);\n\n            // if a UTF8 BOM gets through to here, delete it now (redundant in APEv2 tags)\n\n            if (tag_items [i].vsize &gt;= 3 &amp;&amp; (unsigned char) tag_items [i].value [0] == 0xEF &amp;&amp;\n                (unsigned char) tag_items [i].value [1] == 0xBB &amp;&amp; (unsigned char) tag_items [i].value [2] == 0xBF) {\n                    memmove (tag_items [i].value, tag_items [i].value + 3, tag_items [i].vsize -= 3);\n                    tag_items [i].value [tag_items [i].vsize] = 0;\n            }\n\n            tag_items [i].vsize = (int) strlen (tag_items [i].value);\n        }\n\n        if ((total_tag_size += tag_items [i].vsize) &gt; 1048576 * (allow_huge_tags ? 16 : 1)) {\n            error_line (&quot;total APEv2 tag size exceeds %d MB !&quot;, allow_huge_tags ? 16 : 1);\n            ++error_count;\n            break;\n        }\n    }\n\n    if (error_count) {\n        fprintf (stderr, &quot;\\ntype &#x27;wavpack&#x27; for short help or &#x27;wavpack --help&#x27; for full help\\n&quot;);\n        fflush (stderr);\n        return 1;\n    }\n\n    if (!num_files) {\n        printf (&quot;%s&quot;, usage);\n        return 1;\n    }\n\n    for (file_index = 0; file_index &lt; num_files; ++file_index) {\n        char *infilename = matches [file_index];\n\n        // If the single infile specification begins with a &#x27;@&#x27;, then it\n        // actually points to a file that contains the names of the files\n        // to be converted. This was included for use by Wim Speekenbrink&#x27;s\n        // frontends, but could be used for other purposes.\n\n        if (*infilename == &#x27;@&#x27;) {\n            FILE *list = fopen (infilename+1, &quot;rb&quot;);\n            char *listbuff = NULL, *cp;\n            int listbytes = 0, di, c;\n\n            for (di = file_index; di &lt; num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if (list == NULL) {\n                error_line (&quot;file %s not found!&quot;, infilename+1);\n                free (infilename);\n                return 1;\n            }\n\n            while (1) {\n                int bytes_read;\n\n                listbuff = realloc (listbuff, listbytes + 1024);\n                memset (listbuff + listbytes, 0, 1024);\n                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);\n\n                if (bytes_read &lt; 1024)\n                    break;\n            }\n\n#if defined (_WIN32)\n            listbuff = realloc (listbuff, listbytes *= 2);\n            TextToUTF8 (listbuff, listbytes);\n#endif\n            cp = listbuff;\n\n            while ((c = *cp++)) {\n\n                while (c == &#x27;\\n&#x27; || c == &#x27;\\r&#x27;)\n                    c = *cp++;\n\n                if (c) {\n                    char *fname = malloc (PATH_MAX);\n                    int ci = 0;\n\n                    do\n                        fname [ci++] = c;\n                    while ((c = *cp++) != &#x27;\\n&#x27; &amp;&amp; c != &#x27;\\r&#x27; &amp;&amp; c &amp;&amp; ci &lt; PATH_MAX);\n\n                    fname [ci++] = &#x27;\\0&#x27;;\n                    matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                    for (di = num_files - 1; di &gt; file_index + 1; di--)\n                        matches [di] = matches [di - 1];\n\n                    matches [++file_index] = fname;\n                }\n\n                if (!c)\n                    break;\n            }\n\n            fclose (list);\n            free (listbuff);\n            free (infilename);\n        }\n#if defined (_WIN32)\n        else if (filespec_wild (infilename)) {\n            wchar_t *winfilename = utf8_to_utf16(infilename);\n            struct _wfinddata_t _wfinddata_t;\n            intptr_t file;\n            int di;\n\n            for (di = file_index; di &lt; num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if ((file = _wfindfirst (winfilename, &amp;_wfinddata_t)) != (intptr_t) -1) {\n                do {\n                    char *name_utf8;\n\n                    if (!(_wfinddata_t.attrib &amp; _A_SUBDIR) &amp;&amp; (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                        matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                        for (di = num_files - 1; di &gt; file_index + 1; di--)\n                            matches [di] = matches [di - 1];\n\n                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);\n                        strcpy (matches [file_index], infilename);\n                        *filespec_name (matches [file_index]) = &#x27;\\0&#x27;;\n                        strcat (matches [file_index], name_utf8);\n                        free (name_utf8);\n                    }\n                } while (_wfindnext (file, &amp;_wfinddata_t) == 0);\n\n                _findclose (file);\n            }\n\n            free (winfilename);\n            free (infilename);\n        }\n#endif\n    }\n\n    // If the outfile specification begins with a &#x27;@&#x27;, then it actually points\n    // to a file that contains the output specification. This was included for\n    // use by Wim Speekenbrink&#x27;s frontends because certain filenames could not\n    // be passed on the command-line, but could be used for other purposes.\n\n    if (outfilename &amp;&amp; outfilename [0] == &#x27;@&#x27;) {\n        char listbuff [PATH_MAX * 2], *lp = listbuff;\n        FILE *list = fopen (outfilename+1, &quot;rb&quot;);\n        int c;\n\n        if (list == NULL) {\n            error_line (&quot;file %s not found!&quot;, outfilename+1);\n            free(outfilename);\n            return 1;\n        }\n\n        memset (listbuff, 0, sizeof (listbuff));\n        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning\n\n#if defined (_WIN32)\n        TextToUTF8 (listbuff, PATH_MAX * 2);\n#endif\n\n        while ((c = *lp++) == &#x27;\\n&#x27; || c == &#x27;\\r&#x27;);\n\n        if (c) {\n            int ci = 0;\n\n            do\n                outfilename [ci++] = c;\n            while ((c = *lp++) != &#x27;\\n&#x27; &amp;&amp; c != &#x27;\\r&#x27; &amp;&amp; c &amp;&amp; ci &lt; PATH_MAX);\n\n            outfilename [ci] = &#x27;\\0&#x27;;\n        }\n        else {\n            error_line (&quot;output spec file is empty!&quot;);\n            free(outfilename);\n            fclose (list);\n            return 1;\n        }\n\n        fclose (list);\n    }\n\n    if (out2filename &amp;&amp; (num_files &gt; 1 || !(config.flags &amp; CONFIG_CREATE_WVC))) {\n        error_line (&quot;extra unknown argument: %s !&quot;, out2filename);\n        return 1;\n    }\n\n    // if we found any files to process, this is where we start\n\n    if (num_files) {\n        char outpath, addext;\n\n        // calculate an estimate for the percentage of the time that will be used for the encoding (as opposed\n        // to the optional verification step) based on the &quot;extra&quot; mode processing; this is only used for\n        // displaying the progress and so is not very critical\n\n        if (verify_mode) {\n            if (config.flags &amp; CONFIG_EXTRA_MODE) {\n                if (config.xmode)\n                    encode_time_percent = 100.0 * (1.0 - (1.0 / ((1 &lt;&lt; config.xmode) + 1)));\n                else\n                    encode_time_percent = 66.7;\n            }\n            else\n                encode_time_percent = 50.0;\n        }\n        else\n            encode_time_percent = 100.0;\n\n        if (outfilename &amp;&amp; *outfilename != &#x27;-&#x27;) {\n            outpath = (filespec_path (outfilename) != NULL);\n\n            if (num_files &gt; 1 &amp;&amp; !outpath) {\n                error_line (&quot;%s is not a valid output path&quot;, outfilename);\n                free(outfilename);\n                return 1;\n            }\n        }\n        else\n            outpath = 0;\n\n        addext = !outfilename || outpath || !filespec_ext (outfilename);\n\n        // loop through and process files in list\n\n        for (file_index = 0; file_index &lt; num_files; ++file_index) {\n            if (check_break ())\n                break;\n\n            // generate output filename\n\n            if (outpath) {\n                strcat (outfilename, filespec_name (matches [file_index]));\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = &#x27;\\0&#x27;;\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (matches [file_index]) + 10);\n                strcpy (outfilename, matches [file_index]);\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = &#x27;\\0&#x27;;\n            }\n\n            if (addext &amp;&amp; *outfilename != &#x27;-&#x27;)\n                strcat (outfilename, &quot;.wv&quot;);\n\n            // if &quot;correction&quot; file is desired, generate name for that\n\n            if (config.flags &amp; CONFIG_CREATE_WVC) {\n                if (!out2filename) {\n                    out2filename = malloc (strlen (outfilename) + 10);\n                    strcpy (out2filename, outfilename);\n                }\n                else {\n                    char *temp = malloc (strlen (outfilename) + PATH_MAX);\n\n                    strcpy (temp, outfilename);\n                    strcpy (filespec_name (temp), filespec_name (out2filename));\n                    strcpy (out2filename, temp);\n                    free (temp);\n                }\n\n                if (filespec_ext (out2filename))\n                    *filespec_ext (out2filename) = &#x27;\\0&#x27;;\n\n                strcat (out2filename, &quot;.wvc&quot;);\n            }\n            else\n                out2filename = NULL;\n\n            if (num_files &gt; 1 &amp;&amp; !quiet_mode) {\n                fprintf (stderr, &quot;\\n%s:\\n&quot;, matches [file_index]);\n                fflush (stderr);\n            }\n\n            if (filespec_ext (matches [file_index]) &amp;&amp; !stricmp (filespec_ext (matches [file_index]), &quot;.wv&quot;)) {\n                if (config.qmode &amp; QMODE_RAW_PCM) {\n                    error_line (&quot;can&#x27;t interpret a WavPack file as raw PCM (doesn&#x27;t make sense)!&quot;);\n                    result = WAVPACK_SOFT_ERROR;\n                }\n                else\n                    result = repack_file (matches [file_index], outfilename, out2filename, &amp;config);\n            }\n            else\n                result = pack_file (matches [file_index], outfilename, out2filename, &amp;config);\n\n            if (result != WAVPACK_NO_ERROR) {\n                if (result == WAVPACK_WARNINGS)\n                    ++warnings;\n                else\n                    ++error_count;\n            }\n\n            if (result == WAVPACK_HARD_ERROR)\n                break;\n\n            // clean up in preparation for potentially another file\n\n            if (outpath)\n                *filespec_name (outfilename) = &#x27;\\0&#x27;;\n            else if (*outfilename != &#x27;-&#x27;) {\n                free (outfilename);\n                outfilename = NULL;\n            }\n\n            if (out2filename) {\n                free (out2filename);\n                out2filename = NULL;\n            }\n\n            free (matches [file_index]);\n        }\n\n        if (num_files &gt; 1) {\n            if (warnings || error_count) {\n                fprintf (stderr, &quot;\\n&quot;);\n\n                if (error_count)\n                    fprintf (stderr, &quot; **** errors occurred in %d of %d files! ****\\n&quot;, error_count, num_files);\n\n                if (warnings)\n                    fprintf (stderr, &quot; **** warnings occurred in %d of %d files! ****\\n&quot;, warnings, num_files);\n\n                fflush (stderr);\n            }\n            else if (!quiet_mode) {\n                fprintf (stderr, &quot;\\n **** %d files successfully processed ****\\n&quot;, num_files);\n                fflush (stderr);\n            }\n        }\n\n        free (matches);\n    }\n    else {\n        error_line (&quot;nothing to do!&quot;);\n        ++error_count;\n    }\n\n    if (outfilename)\n        free (outfilename);\n\n    if (set_console_title)\n        DoSetConsoleTitle (&quot;WavPack Completed&quot;);\n\n    return error_count ? 1 : 0;\n}\n\n#ifdef _WIN32\n\n// On Windows, this &quot;real&quot; main() acts as a shell to our static wavpack_main().\n// Its purpose is to convert the wchar command-line arguments into UTF-8 encoded\n// strings.\n\nint main(int argc, char **argv)\n{\n    int ret = -1, argc_utf8 = -1;\n    char **argv_utf8 = NULL;\n\n    init_commandline_arguments_utf8(&amp;argc_utf8, &amp;argv_utf8);\n    ret = wavpack_main(argc_utf8, argv_utf8);\n    free_commandline_arguments_utf8(&amp;argc_utf8, &amp;argv_utf8);\n    if (pause_mode) do_pause_mode ();\n    return ret;\n}\n\n#endif\n\n// This structure and function are used to write completed WavPack blocks in\n// a device independent way.\n\ntypedef struct {\n    uint32_t bytes_written, first_block_size;\n    FILE *file;\n    int error;\n} write_id;\n\nstatic int write_block (void *id, void *data, int32_t length)\n{\n    write_id *wid = (write_id *) id;\n    uint32_t bcount;\n\n    if (wid-&gt;error)\n        return FALSE;\n\n    if (wid &amp;&amp; wid-&gt;file &amp;&amp; data &amp;&amp; length) {\n        if (!DoWriteFile (wid-&gt;file, data, length, &amp;bcount) || bcount != length) {\n            DoTruncateFile (wid-&gt;file);\n            DoCloseHandle (wid-&gt;file);\n            wid-&gt;file = NULL;\n            wid-&gt;error = 1;\n            return FALSE;\n        }\n        else {\n            wid-&gt;bytes_written += length;\n\n            if (!wid-&gt;first_block_size)\n                wid-&gt;first_block_size = bcount;\n        }\n    }\n\n    return TRUE;\n}\n\n// Special version of fopen() that allows a wildcard specification for the\n// filename. If a wildcard is specified, then it must match 1 and only 1\n// file to be acceptable (i.e. it won&#x27;t match just the &quot;first&quot; file).\n\n#if defined (_WIN32)\n\nstatic FILE *wild_fopen (char *filename, const char *mode)\n{\n    struct _wfinddata_t _wfinddata_t;\n    char *matchname = NULL;\n    wchar_t *wfilename;\n    FILE *res = NULL;\n    intptr_t file;\n\n    if (!filespec_wild (filename) || !filespec_name (filename))\n        return fopen (filename, mode);\n\n    wfilename = utf8_to_utf16(filename);\n\n    if (!wfilename)\n        return NULL;\n\n    if ((file = _wfindfirst (wfilename, &amp;_wfinddata_t)) != (intptr_t) -1) {\n        do {\n            if (!(_wfinddata_t.attrib &amp; _A_SUBDIR)) {\n                char *name_utf8;\n\n                if (matchname) {\n                    free (matchname);\n                    matchname = NULL;\n                    break;\n                }\n                else if ((name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                    matchname = malloc (strlen (filename) + strlen(name_utf8));\n                    strcpy (matchname, filename);\n                    strcpy (filespec_name (matchname), name_utf8);\n                    free (name_utf8);\n                }\n            }\n        } while (_wfindnext (file, &amp;_wfinddata_t) == 0);\n\n        _findclose (file);\n    }\n\n    if (matchname) {\n        res = fopen (matchname, mode);\n        free (matchname);\n    }\n\n    free (wfilename);\n    return res;\n}\n\n#else\n\nstatic FILE *wild_fopen (char *filename, const char *mode)\n{\n    char *matchname = NULL;\n    struct stat statbuf;\n    FILE *res = NULL;\n    glob_t globbuf;\n    int i;\n\n    glob (filename, 0, NULL, &amp;globbuf);\n\n    for (i = 0; i &lt; globbuf.gl_pathc; ++i) {\n        if (stat (globbuf.gl_pathv [i], &amp;statbuf) == -1 || S_ISDIR (statbuf.st_mode))\n            continue;\n\n        if (matchname) {\n            free (matchname);\n            matchname = NULL;\n            break;\n        }\n        else {\n            matchname = malloc (strlen (globbuf.gl_pathv [i]) + 10);\n            strcpy (matchname, globbuf.gl_pathv [i]);\n        }\n    }\n\n    globfree (&amp;globbuf);\n\n    if (matchname) {\n        res = fopen (matchname, mode);\n        free (matchname);\n    }\n\n    return res;\n}\n\n#endif\n\n\n// This function packs a single file &quot;infilename&quot; and stores the result at\n// &quot;outfilename&quot;. If &quot;out2filename&quot; is specified, then the &quot;correction&quot;\n// file would go there. The files are opened and closed in this function\n// and the &quot;config&quot; structure specifies the mode of compression.\n\nint ImportID3v2 (WavpackContext *wpc, unsigned char *tag_data, int tag_size, char *error, int32_t *bytes_used); // import_id3.c\n\nstatic int pack_file (char *infilename, char *outfilename, char *out2filename, const WavpackConfig *config)\n{\n    char *outfilename_temp = NULL, *out2filename_temp = NULL, dummy;\n    int use_tempfiles = (out2filename != NULL), chunk_alignment = 1;\n    char imported_tag_type [16] = &quot;&quot;;\n    int imported_tag_items = 0;\n    uint32_t bcount;\n    WavpackConfig loc_config = *config;\n    unsigned char *new_channel_order = NULL;\n    unsigned char md5_digest [16];\n    write_id wv_file, wvc_file;\n    int warnings = 0, result;\n    WavpackContext *wpc;\n    double dtime;\n    FILE *infile;\n\n#if defined(__WATCOMC__)\n    struct _timeb time1, time2;\n#elif defined(_WIN32)\n    struct __timeb64 time1, time2;\n#else\n    struct timeval time1, time2;\n    struct timezone timez;\n#endif\n\n    CLEAR (wv_file);\n    CLEAR (wvc_file);\n    wpc = WavpackOpenFileOutput (write_block, &amp;wv_file, out2filename ? &amp;wvc_file : NULL);\n\n    // open the source file for reading\n\n    if (*infilename == &#x27;-&#x27;) {\n        infile = stdin;\n#if defined(_WIN32)\n        _setmode (_fileno (stdin), O_BINARY);\n#endif\n#if defined(__OS2__)\n        setmode (fileno (stdin), O_BINARY);\n#endif\n    }\n    else if ((infile = fopen (infilename, &quot;rb&quot;)) == NULL) {\n        error_line (&quot;can&#x27;t open file %s!&quot;, infilename);\n        WavpackCloseFile (wpc);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (loc_config.qmode &amp; QMODE_RAW_PCM) {\n        int64_t infilesize = DoGetFileSize (infile), total_samples;\n\n        if (infilesize) {\n            int sample_size = loc_config.bytes_per_sample * loc_config.num_channels;\n\n            infilesize -= raw_pcm_skip_bytes_begin + raw_pcm_skip_bytes_end;\n            total_samples = infilesize / sample_size;\n\n            if (total_samples &lt;= 0) {\n                error_line (&quot;no raw PCM data to encode!&quot;);\n                DoCloseHandle (infile);\n                WavpackCloseFile (wpc);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize % sample_size) {\n                error_line (&quot;warning: raw PCM infile length does not divide evenly, %d bytes will be discarded&quot;,\n                    (int)(infilesize % sample_size));\n                warnings++;\n            }\n        }\n        else {\n            if (raw_pcm_skip_bytes_end) {\n                error_line (&quot;can&#x27;t skip trailer in raw PCM read from stdin!&quot;);\n                DoCloseHandle (infile);\n                WavpackCloseFile (wpc);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            loc_config.qmode |= QMODE_IGNORE_LENGTH;\n            total_samples = -1;\n        }\n\n        if (!loc_config.channel_mask &amp;&amp; !(loc_config.qmode &amp; QMODE_CHANS_UNASSIGNED)) {\n            if (loc_config.num_channels &lt;= 2)\n                loc_config.channel_mask = 0x5 - loc_config.num_channels;\n            else if (loc_config.num_channels &lt;= 18)\n                loc_config.channel_mask = (1 &lt;&lt; loc_config.num_channels) - 1;\n            else\n                loc_config.channel_mask = 0x3ffff;\n        }\n\n        if (!WavpackSetConfiguration64 (wpc, &amp;loc_config, total_samples, NULL)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n            DoCloseHandle (infile);\n            WavpackCloseFile (wpc);\n            return WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    // check both output files for overwrite warning required\n\n    // note that for a file to be considered &quot;overwritable&quot;, it must both be openable for reading\n    // and have at least 1 readable byte - this prevents us getting stuck on &quot;nul&quot; (Windows) \n\n    if (*outfilename != &#x27;-&#x27; &amp;&amp; (wv_file.file = fopen (outfilename, &quot;rb&quot;)) != NULL) {\n        size_t res = fread (&amp;dummy, 1, 1, wv_file.file);\n\n        DoCloseHandle (wv_file.file);\n\n        if (res == 1) {\n            if (no_overwrite) {\n                error_line (&quot;not overwriting %s&quot;, FN_FIT (outfilename));\n                DoCloseHandle (infile);\n                WavpackCloseFile (wpc);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            use_tempfiles = 1;\n\n            if (!overwrite_all) {\n                fprintf (stderr, &quot;overwrite %s (yes/no/all)? &quot;, FN_FIT (outfilename));\n                fflush (stderr);\n\n                if (set_console_title)\n                    DoSetConsoleTitle (&quot;overwrite?&quot;);\n\n                switch (yna ()) {\n                    case &#x27;n&#x27;:\n                        DoCloseHandle (infile);\n                        WavpackCloseFile (wpc);\n                        return WAVPACK_SOFT_ERROR;\n\n                    case &#x27;a&#x27;:\n                        overwrite_all = 1;\n                }\n            }\n        }\n    }\n\n    if (out2filename &amp;&amp; !overwrite_all &amp;&amp; (wvc_file.file = fopen (out2filename, &quot;rb&quot;)) != NULL) {\n        size_t res = fread (&amp;dummy, 1, 1, wvc_file.file);\n\n        DoCloseHandle (wvc_file.file);\n\n        if (res == 1) {\n            if (no_overwrite) {\n                error_line (&quot;not overwriting %s&quot;, FN_FIT (outfilename));\n                DoCloseHandle (infile);\n                WavpackCloseFile (wpc);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            fprintf (stderr, &quot;overwrite %s (yes/no/all)? &quot;, FN_FIT (out2filename));\n            fflush (stderr);\n\n            if (set_console_title)\n                DoSetConsoleTitle (&quot;overwrite?&quot;);\n\n            switch (yna ()) {\n\n                case &#x27;n&#x27;:\n                    DoCloseHandle (infile);\n                    WavpackCloseFile (wpc);\n                    return WAVPACK_SOFT_ERROR;\n\n                case &#x27;a&#x27;:\n                    overwrite_all = 1;\n            }\n        }\n    }\n\n    // if we are using temp files, either because the output filename already exists or we are creating a\n    // &quot;correction&quot; file, search for and generate the corresponding names here\n\n    if (use_tempfiles) {\n        FILE *testfile;\n        int count = 0;\n\n        outfilename_temp = malloc (strlen (outfilename) + 16);\n\n        if (out2filename)\n            out2filename_temp = malloc (strlen (outfilename) + 16);\n\n        while (1) {\n            strcpy (outfilename_temp, outfilename);\n\n            if (filespec_ext (outfilename_temp)) {\n                if (count++)\n                    sprintf (filespec_ext (outfilename_temp), &quot;.tmp%d&quot;, count-1);\n                else\n                    strcpy (filespec_ext (outfilename_temp), &quot;.tmp&quot;);\n\n                strcat (outfilename_temp, filespec_ext (outfilename));\n            }\n            else {\n                if (count++)\n                    sprintf (outfilename_temp + strlen (outfilename_temp), &quot;.tmp%d&quot;, count-1);\n                else\n                    strcat (outfilename_temp, &quot;.tmp&quot;);\n            }\n\n            testfile = fopen (outfilename_temp, &quot;rb&quot;);\n\n            if (testfile) {\n                int res = (int) fread (&amp;dummy, 1, 1, testfile);\n\n                fclose (testfile);\n\n                if (res == 1)\n                    continue;\n            }\n\n            if (out2filename) {\n                strcpy (out2filename_temp, outfilename_temp);\n                strcat (out2filename_temp, &quot;c&quot;);\n\n                testfile = fopen (out2filename_temp, &quot;rb&quot;);\n\n                if (testfile) {\n                    int res = (int) fread (&amp;dummy, 1, 1, testfile);\n\n                    fclose (testfile);\n\n                    if (res == 1)\n                        continue;\n                }\n            }   \n\n            break;\n        }\n    }\n\n#if defined(__WATCOMC__)\n    _ftime (&amp;time1);\n#elif defined(_WIN32)\n    _ftime64 (&amp;time1);\n#else\n    gettimeofday(&amp;time1,&amp;timez);\n#endif\n\n    // open output file for writing\n\n    if (*outfilename == &#x27;-&#x27;) {\n        wv_file.file = stdout;\n#if defined(_WIN32)\n        _setmode (_fileno (stdout), O_BINARY);\n#endif\n#if defined(__OS2__)\n        setmode (fileno (stdout), O_BINARY);\n#endif\n    }\n    else if ((wv_file.file = fopen (use_tempfiles ? outfilename_temp : outfilename, &quot;w+b&quot;)) == NULL) {\n        error_line (&quot;can&#x27;t create file %s!&quot;, use_tempfiles ? outfilename_temp : outfilename);\n        DoCloseHandle (infile);\n        WavpackCloseFile (wpc);\n        free (outfilename_temp);\n        free (out2filename_temp);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (!quiet_mode) {\n        if (*outfilename == &#x27;-&#x27;)\n            fprintf (stderr, &quot;packing %s to stdout,&quot;, *infilename == &#x27;-&#x27; ? &quot;stdin&quot; : FN_FIT (infilename));\n        else if (out2filename)\n            fprintf (stderr, &quot;creating %s (+%s),&quot;, FN_FIT (outfilename), filespec_ext (out2filename));\n        else\n            fprintf (stderr, &quot;creating %s,&quot;, FN_FIT (outfilename));\n\n        fflush (stderr);\n    }\n\n    // for now, raw 1-bit PCM is only DSDIFF format\n\n    if (loc_config.qmode &amp; QMODE_RAW_PCM)\n        if (loc_config.qmode &amp; QMODE_DSD_AUDIO)\n            WavpackSetFileInformation (wpc, &quot;dff&quot;, WP_FORMAT_DFF);\n\n    // if not in &quot;raw&quot; mode, process RIFF form header and set configuration\n\n    if (!(loc_config.qmode &amp; QMODE_RAW_PCM)) {\n        char fourcc [4], fourcc_str [5];\n        int i;\n\n        if (!DoReadFile (infile, fourcc, sizeof (fourcc), &amp;bcount) || bcount != sizeof (fourcc)) {\n            error_line (&quot;can&#x27;t read file %s!&quot;, infilename);\n            DoCloseHandle (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (wpc);\n            free (outfilename_temp);\n            free (out2filename_temp);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        strcpy (fourcc_str, &quot;????&quot;);\n\n        for (i = 0; i &lt; 4 &amp;&amp; fourcc [i]; ++i)\n            if (fourcc [i] &gt;= 0x20 &amp;&amp; fourcc [i] &lt;= 0x7f)\n                fourcc_str [i] = fourcc [i];\n\n        if (debug_logging_mode)\n            error_line (&quot;fourcc is \\&quot;%s\\&quot;&quot;, fourcc_str);\n\n        for (i = 0; i &lt; NUM_FILE_FORMATS; ++i)\n            if (!strncmp (fourcc, file_formats [i].fourcc, 4)) {\n\n                WavpackSetFileInformation (wpc,\n                    filespec_ext (infilename) ? filespec_ext (infilename) + 1 : file_formats [i].default_extension,\n                    file_formats [i].id);\n\n                if (file_formats [i].ParseHeader (infile, infilename, fourcc, wpc, &amp;loc_config)) {\n                    DoCloseHandle (infile);\n                    DoCloseHandle (wv_file.file);\n                    DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n                    WavpackCloseFile (wpc);\n                    free (outfilename_temp);\n                    free (out2filename_temp);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                chunk_alignment = file_formats [i].chunk_alignment;\n                break;\n            }\n\n        if (i == NUM_FILE_FORMATS)  {\n            error_line (&quot;%s is not a recognized file type, fourcc is \\&quot;%s\\&quot;!&quot;, infilename, fourcc_str);\n            DoCloseHandle (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (wpc);\n            free (outfilename_temp);\n            free (out2filename_temp);\n            return WAVPACK_SOFT_ERROR;\n        }\n    }\n    else if (raw_pcm_skip_bytes_begin) {          // if raw pcm mode and bytes to skip, do that here\n        int bytes_to_skip = raw_pcm_skip_bytes_begin;\n        char dummy [256];\n\n        while (bytes_to_skip) {\n            int requested_bytes = (bytes_to_skip &gt;= sizeof (dummy)) ? sizeof (dummy) : bytes_to_skip;\n\n            if (DoReadFile (infile, dummy, requested_bytes, &amp;bcount) &amp;&amp; bcount == requested_bytes)\n                bytes_to_skip -= bcount;\n            else\n                break;\n        }\n\n        if (bytes_to_skip) {\n            error_line (&quot;can&#x27;t read file %s!&quot;, infilename);\n            DoCloseHandle (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (wpc);\n            free (outfilename_temp);\n            free (out2filename_temp);\n            return WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    // handle case where the CAF header indicated a channel layout that requires reordering\n\n    if (loc_config.qmode &amp; QMODE_REORDERED_CHANS) {\n        int layout = WavpackGetChannelLayout (wpc, NULL), i;\n\n        if ((layout &amp; 0xff) &lt;= loc_config.num_channels) {\n            new_channel_order = malloc (loc_config.num_channels);\n\n            for (i = 0; i &lt; loc_config.num_channels; ++i)\n                new_channel_order [i] = i;\n\n            WavpackGetChannelLayout (wpc, new_channel_order);\n        }\n    }\n\n    // handle case where the user specified channel configuration on the command-line\n\n    if (num_channels_order || (loc_config.qmode &amp; QMODE_CHANS_UNASSIGNED)) {\n        int i, j;\n\n        if (loc_config.num_channels &lt; num_channels_order ||\n            (loc_config.num_channels &gt; num_channels_order &amp;&amp; !(loc_config.qmode &amp; QMODE_CHANS_UNASSIGNED))) {\n                error_line (&quot;file does not have %d channel(s)!&quot;, num_channels_order);\n                DoCloseHandle (infile);\n                DoCloseHandle (wv_file.file);\n                DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n                WavpackCloseFile (wpc);\n                free (outfilename_temp);\n                free (out2filename_temp);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n        if (num_channels_order) {\n            new_channel_order = malloc (loc_config.num_channels);\n\n            for (i = 0; i &lt; loc_config.num_channels; ++i)\n                new_channel_order [i] = i;\n\n            memcpy (new_channel_order, channel_order, num_channels_order);\n\n            for (i = 0; i &lt; num_channels_order;) {\n                for (j = 0; j &lt; num_channels_order; ++j)\n                    if (new_channel_order [j] == i) {\n                        i++;\n                        break;\n                    }\n\n                if (j == num_channels_order)\n                    for (j = 0; j &lt; num_channels_order; ++j)\n                        if (new_channel_order [j] &gt; i)\n                            new_channel_order [j]--;\n            }\n        }\n    }\n\n    // if we are creating a &quot;correction&quot; file, open it now for writing\n\n    if (out2filename) {\n        if ((wvc_file.file = fopen (use_tempfiles ? out2filename_temp : out2filename, &quot;w+b&quot;)) == NULL) {\n            error_line (&quot;can&#x27;t create correction file!&quot;);\n            DoCloseHandle (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (wpc);\n            free (outfilename_temp);\n            free (out2filename_temp);\n            return WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    // pack the audio portion of the file now; calculate md5 if we&#x27;re writing it to the file or verify mode is active\n\n    if (loc_config.qmode &amp; QMODE_DSD_AUDIO)\n        result = pack_dsd_audio (wpc, infile, loc_config.qmode, new_channel_order, ((loc_config.flags &amp; CONFIG_MD5_CHECKSUM) || verify_mode) ? md5_digest : NULL);\n    else\n        result = pack_audio (wpc, infile, loc_config.qmode, new_channel_order, ((loc_config.flags &amp; CONFIG_MD5_CHECKSUM) || verify_mode) ? md5_digest : NULL);\n\n    if (result == WAVPACK_WARNINGS) {\n        result = WAVPACK_NO_ERROR;\n        warnings++;\n    }\n\n    if (new_channel_order)\n        free (new_channel_order);\n\n    // write the md5 sum if the user asked for it to be included\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; (loc_config.flags &amp; CONFIG_MD5_CHECKSUM))\n        WavpackStoreMD5Sum (wpc, md5_digest);\n\n    // if everything went well, and we&#x27;re not ignoring length or encoding raw\n    // pcm, read past any required data chunk padding and then try to read anything\n    // else that might be appended to the audio data and write that to the WavPack\n    // metadata as &quot;wrapper&quot;\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; !(loc_config.qmode &amp; (QMODE_IGNORE_LENGTH | QMODE_RAW_PCM))) {\n        int wrapper_size = 0, buffer_size;\n        unsigned char *buffer;\n\n        // if this file format has chunk alignment padding, read past that here\n\n        if (chunk_alignment != 1) {\n            int64_t data_chunk_bytes = WavpackGetNumSamples64 (wpc) * WavpackGetNumChannels (wpc) * WavpackGetBytesPerSample (wpc);\n            int bytes_over = (int)(data_chunk_bytes % chunk_alignment);\n            int padding_bytes = bytes_over ? chunk_alignment - bytes_over : 0;\n            unsigned char pad_byte;\n\n            while (padding_bytes--) {\n                if (!DoReadFile (infile, &amp;pad_byte, 1, &amp;bcount) || bcount != 1)\n                    error_line (&quot;warning: input file missing required padding byte!&quot;);\n                else if (pad_byte)\n                    error_line (&quot;warning: input file has non-zero padding byte!&quot;);\n            }\n        }\n\n        // now read everything remaining in the file into a new buffer\n\n        buffer = malloc (buffer_size = 65536);\n\n        while (DoReadFile (infile, buffer + wrapper_size, buffer_size - wrapper_size, &amp;bcount) &amp;&amp; bcount)\n            if ((wrapper_size += bcount) == buffer_size)\n                buffer = realloc (buffer, buffer_size += 65536);\n\n        // if we got something and are storing wrapper, write it to the outfile file\n\n        if (wrapper_size &amp;&amp; !(loc_config.qmode &amp; QMODE_NO_STORE_WRAPPER) &amp;&amp; !WavpackAddWrapper (wpc, buffer, wrapper_size)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n            result = WAVPACK_HARD_ERROR;\n        }\n        else if (wrapper_size &amp;&amp; debug_logging_mode)\n            error_line (&quot;%d bytes of trailing data stored in file&quot;, wrapper_size);\n\n        // if we&#x27;re supposed to try to import ID3 tags, check for and do that now\n        // (but only error on a bad tag, not just a missing one or one with no applicable items)\n\n        if (result == WAVPACK_NO_ERROR &amp;&amp; import_id3 &amp;&amp; wrapper_size &gt; 10) {\n            int32_t bytes_used, id3_res;\n            char error [80] = &quot;&quot;;\n\n            // first we do a &quot;dry run&quot; pass through the ID3 tag, and only if that passes do we try to write the tag items\n\n            id3_res = ImportID3v2 (NULL, buffer, wrapper_size, error, &amp;bytes_used);\n\n            if (!allow_huge_tags &amp;&amp; bytes_used &gt; 1048576) {\n                error_line (&quot;imported tag items exceed 1 MB, use --allow-huge-tags to override&quot;);\n                result = WAVPACK_SOFT_ERROR;\n            }\n            else if (bytes_used &gt; 1048576 * 16) {\n                error_line (&quot;imported tag items exceed 16 MB&quot;);\n                result = WAVPACK_SOFT_ERROR;\n            }\n            else {\n                if (id3_res &gt; 0)\n                    id3_res = ImportID3v2 (wpc, buffer, wrapper_size, error, NULL);\n\n                if (id3_res &lt; 0) {\n                    error_line (&quot;ID3v2 import: %s&quot;, error);\n                    result = WAVPACK_SOFT_ERROR;\n                }\n                else if (id3_res &gt; 0) {\n                    imported_tag_items = id3_res;\n\n                    if (strlen (error) &lt; sizeof (imported_tag_type))\n                        strcpy (imported_tag_type, error);\n                    else\n                        imported_tag_type [0] = 0;\n                }\n                else if (!quiet_mode)\n                    error_line (&quot;warning: no tag or importable tag items found&quot;);\n            }\n        }\n\n        free (buffer);\n    }\n\n    DoCloseHandle (infile);     // we&#x27;re now done with input file, so close\n\n    // we&#x27;re now done with any WavPack blocks, so flush any remaining data\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; !WavpackFlushSamples (wpc)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n        result = WAVPACK_HARD_ERROR;\n    }\n\n    // if still no errors, check to see if we need to create &amp; write a tag\n    // (which is NOT stored in regular WavPack blocks)\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; (num_tag_items || imported_tag_items)) {\n        int i, res = TRUE;\n\n        for (i = 0; i &lt; num_tag_items &amp;&amp; res; ++i)\n            if (tag_items [i].vsize) {\n                if (tag_items [i].binary) \n                    res = WavpackAppendBinaryTagItem (wpc, tag_items [i].item, tag_items [i].value, tag_items [i].vsize);\n                else\n                    res = WavpackAppendTagItem (wpc, tag_items [i].item, tag_items [i].value, tag_items [i].vsize);\n            }\n\n        if (!res || !WavpackWriteTag (wpc)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n            result = WAVPACK_HARD_ERROR;\n        }\n    }\n\n    // At this point we&#x27;re done writing to the output files. If the number of samples converted\n    // did not match the number we were expecting, and the &quot;ignore length&quot; option was NOT specified,\n    // then that&#x27;s an error.\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; WavpackGetNumSamples64 (wpc) != WavpackGetSampleIndex64 (wpc) &amp;&amp;\n        !(loc_config.qmode &amp; QMODE_IGNORE_LENGTH)) {\n            error_line (&quot;couldn&#x27;t read all samples; specify &#x27;-i&#x27; to ignore length in header&quot;);\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n    // If we&#x27;re ignoring the length in the header, or we were not able to determine the length of\n    // a &quot;raw&quot; file in advance, then we&#x27;ll need to back up and read the first frame written and\n    // update the length stored there and potentially fix the header stored from the source file.\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp;\n        ((loc_config.qmode &amp; QMODE_IGNORE_LENGTH) || WavpackGetNumSamples64 (wpc) == -1)) {\n            char *block_buff = malloc (wv_file.first_block_size);\n            int update_error = 0;\n\n            if (block_buff &amp;&amp; !DoSetFilePositionAbsolute (wv_file.file, 0) &amp;&amp;\n                DoReadFile (wv_file.file, block_buff, wv_file.first_block_size, &amp;bcount) &amp;&amp;\n                bcount == wv_file.first_block_size &amp;&amp; !strncmp (block_buff, &quot;wvpk&quot;, 4)) {\n\n                    // If we got the RIFF header from the source file, we try to update it here if it&#x27;s a simple\n                    // header (not RF64) and the audio data length is appropriate. Note that this means we&#x27;re no\n                    // longer strictly lossless, but the user essentially told us the length in the header was\n                    // wrong, so we&#x27;re fixing it.\n\n                    if (!(loc_config.qmode &amp; (QMODE_NO_STORE_WRAPPER | QMODE_RAW_PCM)) &amp;&amp; WavpackGetWrapperLocation (block_buff, NULL)) {\n                        uint32_t wrapper_size;\n                        unsigned char *wrapper_location = WavpackGetWrapperLocation (block_buff, &amp;wrapper_size);\n                        int64_t data_size = WavpackGetSampleIndex64 (wpc) * WavpackGetNumChannels (wpc) * WavpackGetBytesPerSample (wpc);\n                        ChunkHeader chunk_header;\n\n                        memcpy (&amp;chunk_header, wrapper_location, sizeof (ChunkHeader));\n\n                        if (data_size &lt;= 0xff000000 &amp;&amp; !strncmp (chunk_header.ckID, &quot;RIFF&quot;, 4)) {\n                            chunk_header.ckSize = (uint32_t) (wrapper_size + data_size - 8);\n                            WavpackNativeToLittleEndian (&amp;chunk_header, ChunkHeaderFormat);\n                            memcpy (wrapper_location, &amp;chunk_header, sizeof (ChunkHeader));\n                            memcpy (&amp;chunk_header, wrapper_location + wrapper_size - sizeof (ChunkHeader), sizeof (ChunkHeader));\n\n                            if (!strncmp (chunk_header.ckID, &quot;data&quot;, 4)) {\n                                chunk_header.ckSize = (uint32_t) data_size;\n                                WavpackNativeToLittleEndian (&amp;chunk_header, ChunkHeaderFormat);\n                                memcpy (wrapper_location + wrapper_size - sizeof (ChunkHeader), &amp;chunk_header, sizeof (ChunkHeader));\n                            }\n                        }\n                    }\n\n                    // this call will take care of the initial WavPack header and any RIFF header the library made\n                    // (and also make sure the block checksum is correct)\n\n                    WavpackUpdateNumSamples (wpc, block_buff);\n\n                    if (DoSetFilePositionAbsolute (wv_file.file, 0) ||\n                        !DoWriteFile (wv_file.file, block_buff, wv_file.first_block_size, &amp;bcount) ||\n                        bcount != wv_file.first_block_size)\n                            update_error = 1;\n            }\n            else\n                update_error = 1;\n\n            if (block_buff)\n                free (block_buff);\n\n            if (!update_error &amp;&amp; wvc_file.file) {\n                block_buff = malloc (wvc_file.first_block_size);\n\n                if (block_buff &amp;&amp; !DoSetFilePositionAbsolute (wvc_file.file, 0) &amp;&amp;\n                    DoReadFile (wvc_file.file, block_buff, wvc_file.first_block_size, &amp;bcount) &amp;&amp;\n                    bcount == wvc_file.first_block_size &amp;&amp; !strncmp (block_buff, &quot;wvpk&quot;, 4)) {\n\n                        WavpackUpdateNumSamples (wpc, block_buff);\n\n                        if (DoSetFilePositionAbsolute (wvc_file.file, 0) ||\n                            !DoWriteFile (wvc_file.file, block_buff, wvc_file.first_block_size, &amp;bcount) ||\n                            bcount != wvc_file.first_block_size)\n                                update_error = 1;\n                }\n                else\n                    update_error = 1;\n\n                if (block_buff)\n                    free (block_buff);\n            }\n\n            // If we&#x27;re writing to stdout then we really shouldn&#x27;t be too surprised that we can&#x27;t rewrite the\n            // header, and we can&#x27;t delete the output file either, so let them off with a warning this time.\n\n            if (update_error) {\n                if (*outfilename != &#x27;-&#x27;) {\n                    error_line (&quot;couldn&#x27;t update WavPack header with actual length!!&quot;);\n                    result = WAVPACK_SOFT_ERROR;\n                }\n                else\n                    error_line (&quot;warning: couldn&#x27;t update WavPack header with actual length!&quot;);\n            }\n    }\n\n    // at this point we&#x27;re completely done with the files, so close &#x27;em whether there\n    // were any other errors or not\n\n    if (!DoCloseHandle (wv_file.file)) {\n        error_line (&quot;can&#x27;t close WavPack file!&quot;);\n\n        if (result == WAVPACK_NO_ERROR)\n            result = WAVPACK_SOFT_ERROR;\n    }\n\n    if (out2filename &amp;&amp; !DoCloseHandle (wvc_file.file)) {\n        error_line (&quot;can&#x27;t close correction file!&quot;);\n\n        if (result == WAVPACK_NO_ERROR)\n            result = WAVPACK_SOFT_ERROR;\n    }\n\n    // if there have been no errors up to now, and verify mode is enabled, do that now; only pass in the md5 if this\n    // was a lossless operation (either explicitly or because a high lossy bitrate resulted in lossless)\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; verify_mode)\n        result = verify_audio (use_tempfiles ? outfilename_temp : outfilename, !WavpackLossyBlocks (wpc) ? md5_digest : NULL);\n\n    // if there were any errors, delete the output files, close the context, and return the error\n\n    if (result != WAVPACK_NO_ERROR) {\n        DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n\n        if (out2filename)\n            DoDeleteFile (use_tempfiles ? out2filename_temp : out2filename);\n\n        WavpackCloseFile (wpc);\n        free (outfilename_temp);\n        free (out2filename_temp);\n        return result;\n    }\n\n    // if we were writing to a temp file because the target file already existed,\n    // do the rename / overwrite now (and if that fails, return the error)\n\n    if (use_tempfiles) {\n#if defined(_WIN32)\n        FILE *temp;\n\n        if (remove (outfilename) &amp;&amp; (temp = fopen (outfilename, &quot;rb&quot;))) {\n            error_line (&quot;can not remove file %s, result saved in %s!&quot;, outfilename, outfilename_temp);\n            result = WAVPACK_SOFT_ERROR;\n            fclose (temp);\n        }\n        else\n#endif\n        if (rename (outfilename_temp, outfilename)) {\n            error_line (&quot;can not rename temp file %s to %s!&quot;, outfilename_temp, outfilename);\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n        if (out2filename) {\n#if defined(_WIN32)\n            FILE *temp;\n\n            if (remove (out2filename) &amp;&amp; (temp = fopen (out2filename, &quot;rb&quot;))) {\n                error_line (&quot;can not remove file %s, result saved in %s!&quot;, out2filename, out2filename_temp);\n                result = WAVPACK_SOFT_ERROR;\n                fclose (temp);\n            }\n            else\n#endif\n            if (rename (out2filename_temp, out2filename)) {\n                error_line (&quot;can not rename temp file %s to %s!&quot;, out2filename_temp, out2filename);\n                result = WAVPACK_SOFT_ERROR;\n            }\n        }\n\n        free (outfilename_temp);\n        if (out2filename) free (out2filename_temp);\n\n        if (result != WAVPACK_NO_ERROR) {\n            WavpackCloseFile (wpc);\n            return result;\n        }\n    }\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; copy_time)\n        if (!copy_timestamp (infilename, outfilename) ||\n            (out2filename &amp;&amp; !copy_timestamp (infilename, out2filename)))\n                error_line (&quot;failure copying time stamp!&quot;);\n\n    // delete source file if that option is enabled\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; delete_source) {\n        if (warnings) {\n            if (!quiet_mode)\n                error_line (&quot;not deleting source file %s because of warnings&quot;, infilename);\n        }\n        else {\n            int res = DoDeleteFile (infilename);\n\n            if (!quiet_mode || !res)\n                error_line (&quot;%s source file %s&quot;, res ?\n                &quot;deleted&quot; : &quot;can&#x27;t delete&quot;, infilename);\n        }\n    }\n\n    // if we&#x27;re not creating a correction file but there&#x27;s an existing one\n    // with the appropriate name, delete it because it&#x27;s now very obsolete\n\n    if (!out2filename &amp;&amp; outfilename &amp;&amp; *outfilename != &#x27;-&#x27;) {\n        char out2filename_obsolete [PATH_MAX];\n        FILE *testfile;\n        int res;\n\n        strcpy (out2filename_obsolete, outfilename);\n        strcat (out2filename_obsolete, &quot;c&quot;);\n\n        if ((testfile = fopen (out2filename_obsolete, &quot;rb&quot;)) != NULL) {\n            fclose (testfile);\n            res = DoDeleteFile (out2filename_obsolete);\n\n            if (!quiet_mode || !res)\n                error_line (&quot;%s obsolete correction file %s&quot;,\n                    res ? &quot;deleted&quot; : &quot;can&#x27;t delete&quot;, out2filename_obsolete);\n        }\n    }\n\n    // compute and display the time consumed along with some other details of\n    // the packing operation, and then return WAVPACK_NO_ERROR\n\n#if defined(__WATCOMC__)\n    _ftime (&amp;time2);\n    dtime = time2.time + time2.millitm / 1000.0;\n    dtime -= time1.time + time1.millitm / 1000.0;\n#elif defined(_WIN32)\n    _ftime64 (&amp;time2);\n    dtime = time2.time + time2.millitm / 1000.0;\n    dtime -= time1.time + time1.millitm / 1000.0;\n#else\n    gettimeofday(&amp;time2,&amp;timez);\n    dtime = time2.tv_sec + time2.tv_usec / 1000000.0;\n    dtime -= time1.tv_sec + time1.tv_usec / 1000000.0;\n#endif\n\n    if ((loc_config.flags &amp; CONFIG_CALC_NOISE) &amp;&amp; WavpackGetEncodedNoise (wpc, NULL) &gt; 0.0) {\n        int full_scale_bits = WavpackGetBitsPerSample (wpc);\n        double full_scale_rms = 0.5, sum, peak;\n\n        while (full_scale_bits--)\n            full_scale_rms *= 2.0;\n\n        full_scale_rms = full_scale_rms * (full_scale_rms - 1.0) * 0.5;\n        sum = WavpackGetEncodedNoise (wpc, &amp;peak);\n\n        error_line (&quot;ave noise = %.2f dB, peak noise = %.2f dB&quot;,\n            log10 (sum / WavpackGetNumSamples64 (wpc) / full_scale_rms) * 10,\n            log10 (peak / full_scale_rms) * 10);\n    }\n\n    if (!quiet_mode) {\n        char *file, *fext, *oper, *cmode, cratio [16] = &quot;&quot;;\n\n        if (imported_tag_items)\n            error_line (&quot;successfully imported %d items from %s tag&quot;, imported_tag_items, imported_tag_type);\n\n        if (loc_config.flags &amp; CONFIG_MD5_CHECKSUM) {\n            char md5_string [] = &quot;original md5 signature: 00000000000000000000000000000000&quot;;\n            int i;\n\n            for (i = 0; i &lt; 16; ++i)\n                sprintf (md5_string + 24 + (i * 2), &quot;%02x&quot;, md5_digest [i]);\n\n            error_line (md5_string);\n        }\n\n        if (outfilename &amp;&amp; *outfilename != &#x27;-&#x27;) {\n            file = FN_FIT (outfilename);\n            fext = wvc_file.bytes_written ? &quot; (+.wvc)&quot; : &quot;&quot;;\n            oper = verify_mode ? &quot;created (and verified)&quot; : &quot;created&quot;;\n        }\n        else {\n            file = (*infilename == &#x27;-&#x27;) ? &quot;stdin&quot; : FN_FIT (infilename);\n            fext = &quot;&quot;;\n            oper = &quot;packed&quot;;\n        }\n\n        if (WavpackLossyBlocks (wpc)) {\n            cmode = &quot;lossy&quot;;\n\n            if (WavpackGetAverageBitrate (wpc, TRUE) != 0.0)\n                sprintf (cratio, &quot;, %d kbps&quot;, (int) (WavpackGetAverageBitrate (wpc, TRUE) / 1000.0));\n        }\n        else {\n            cmode = &quot;lossless&quot;;\n\n            if (WavpackGetRatio (wpc) != 0.0)\n                sprintf (cratio, &quot;, %.2f%%&quot;, 100.0 - WavpackGetRatio (wpc) * 100.0);\n        }\n\n        error_line (&quot;%s %s%s in %.2f secs (%s%s)&quot;, oper, file, fext, dtime, cmode, cratio);\n    }\n\n    WavpackCloseFile (wpc);\n    return warnings ? WAVPACK_WARNINGS : WAVPACK_NO_ERROR;\n}\n\n// This function handles the actual audio data compression. It assumes that the\n// input file is positioned at the beginning of the audio data and that the\n// WavPack configuration has been set. This is where the conversion from RIFF\n// little-endian standard the executing processor&#x27;s format is done and where\n// (if selected) the MD5 sum is calculated and displayed.\n\nstatic void reorder_channels (void *data, unsigned char *new_order, int num_chans,\n    int num_samples, int bytes_per_sample);\n\nstatic void load_samples (int32_t *dst, void *src, int qmode, int bps, int count);\nstatic void *store_samples (void *dst, int32_t *src, int qmode, int bps, int count);\nstatic void unreorder_channels (int32_t *data, unsigned char *order, int num_chans, int num_samples);\n\n#define INPUT_SAMPLES 65536\n\nstatic int pack_audio (WavpackContext *wpc, FILE *infile, int qmode, unsigned char *new_order, unsigned char *md5_digest_source)\n{\n    int64_t samples_remaining, input_samples = INPUT_SAMPLES;\n    double progress = -1.0;\n    int bytes_per_sample;\n    int32_t *sample_buffer;\n    unsigned char *input_buffer;\n    MD5_CTX md5_context;\n    int32_t padding_error_bit_mask = 0, quantize_bit_mask = 0;\n    double fquantize_scale = 1.0, fquantize_iscale = 1.0;\n\n    if (worker_threads &amp;&amp; WavpackGetNumChannels (wpc) &lt;= 2)\n        input_samples = (worker_threads + 1) * 48000;\n    else\n        while (input_samples * WavpackGetNumChannels (wpc) &gt; 8388608 / sizeof (int32_t))\n            input_samples &gt;&gt;= 1;\n\n    if (md5_digest_source)\n        MD5_Init (&amp;md5_context);\n\n    WavpackPackInit (wpc);\n    bytes_per_sample = WavpackGetBytesPerSample (wpc) * WavpackGetNumChannels (wpc);\n    input_buffer = malloc ((uint32_t) input_samples * bytes_per_sample);\n    sample_buffer = malloc ((uint32_t) input_samples * sizeof (int32_t) * WavpackGetNumChannels (wpc));\n    samples_remaining = WavpackGetNumSamples64 (wpc);\n\n    if (quantize_bits &amp;&amp; quantize_bits &lt; WavpackGetBytesPerSample (wpc) * 8) {\n        quantize_bit_mask = ~((1&lt;&lt;(WavpackGetBytesPerSample (wpc)*8-quantize_bits))-1);\n        if (MODE_FLOAT == (WavpackGetMode(wpc) &amp; MODE_FLOAT)) {\n            int float_norm_exp = WavpackGetFloatNormExp (wpc);\n            fquantize_scale = exp2 (quantize_bits + 126 - float_norm_exp);\n            fquantize_iscale = exp2 (float_norm_exp - 126 - quantize_bits);\n        }\n    }\n\n    if (WavpackGetBitsPerSample (wpc) % 8)\n        padding_error_bit_mask = (1 &lt;&lt; (8 - (WavpackGetBitsPerSample (wpc) % 8))) - 1;\n\n    while (1) {\n        uint32_t bytes_to_read, bytes_read = 0;\n        int32_t sample_count;\n\n        if ((qmode &amp; QMODE_IGNORE_LENGTH) || samples_remaining &gt; input_samples)\n            bytes_to_read = (uint32_t) input_samples * bytes_per_sample;\n        else\n            bytes_to_read = (uint32_t) samples_remaining * bytes_per_sample;\n\n        samples_remaining -= bytes_to_read / bytes_per_sample;\n        DoReadFile (infile, input_buffer, bytes_to_read, &amp;bytes_read);\n        sample_count = bytes_read / bytes_per_sample;\n\n        // if we have reordering to do because the user used the --channel-order option to define\n        // an order that does not match the Microsoft order, then we do that BEFORE the MD5 because\n        // this reordering is permanent (i.e., we will not unreorder on decode) and we want the\n        // MD5 to match the new order\n\n        if (new_order &amp;&amp; !(qmode &amp; QMODE_REORDERED_CHANS))\n            reorder_channels (input_buffer, new_order, WavpackGetNumChannels (wpc),\n                sample_count, WavpackGetBytesPerSample (wpc));\n\n        if (md5_digest_source &amp;&amp; quantize_bit_mask == 0)\n            MD5_Update (&amp;md5_context, input_buffer, sample_count * bytes_per_sample);\n\n        // if we have reordering to do because this is a CAF channel layout that is not in Microsoft\n        // order, then we do the reordering AFTER the MD5 because we will be unreordering them at\n        // decode time, and so we want the MD5 to match the original order\n\n        if (new_order &amp;&amp; (qmode &amp; QMODE_REORDERED_CHANS))\n            reorder_channels (input_buffer, new_order, WavpackGetNumChannels (wpc),\n                sample_count, WavpackGetBytesPerSample (wpc));\n\n        if (!sample_count)\n            break;\n\n        if (sample_count) {\n            int bps = WavpackGetBytesPerSample (wpc);\n\n            load_samples (sample_buffer, input_buffer, qmode, bps, sample_count * WavpackGetNumChannels (wpc));\n\n            if (quantize_bit_mask) {\n                unsigned int x,l = sample_count * WavpackGetNumChannels (wpc);\n                if (0 == (WavpackGetMode(wpc) &amp; MODE_FLOAT)) {\n                    if (quantize_round) {\n                        int32_t offset = (quantize_bit_mask &gt;&gt; 1) ^ quantize_bit_mask;\n                        int shift = 32 - WavpackGetBytesPerSample (wpc) * 8;\n\n                        for (x = 0; x &lt; l; x ++)\n                            if (sample_buffer[x] &lt; 0 || ((sample_buffer[x] + offset) &lt;&lt; shift) &gt; 0)\n                                sample_buffer[x] += offset;\n                    }\n\n                    for (x = 0; x &lt; l; x ++) sample_buffer[x] &amp;= quantize_bit_mask;\n                }\n                else {\n                    for (x = 0; x &lt; l; x ++) {\n                        const float f = *(float *)&amp;sample_buffer[x];\n                        *(float *)&amp;sample_buffer[x] = (float) (floor(f * fquantize_scale + 0.5) * fquantize_iscale);\n                    }\n                }\n\n                if (md5_digest_source) {\n                    store_samples (input_buffer, sample_buffer, qmode, bps, sample_count * WavpackGetNumChannels (wpc));\n                    MD5_Update (&amp;md5_context, input_buffer, WavpackGetBytesPerSample (wpc) * l);\n                }\n            }\n\n            if (padding_error_bit_mask) {\n                unsigned int x,l = sample_count * WavpackGetNumChannels (wpc);\n\n                for (x = 0; x &lt; l; x ++)\n                    if (sample_buffer[x] &amp; padding_error_bit_mask) {\n                        int bits = WavpackGetBitsPerSample (wpc);\n                        error_line (&quot;\\&quot;%d-bit\\&quot; file has non-zero PCM padding bits!!&quot;, bits);\n                        error_line (&quot;use --force-even-byte-depth to encode as %d-bit&quot;, (bits + 7) / 8 * 8);\n                        if (bits &gt;= 4)\n                            error_line (&quot;or --pre-quantize=%d to zero those bits before encoding&quot;, bits);\n                        free (sample_buffer);\n                        free (input_buffer);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n            }\n        }\n\n        if (!WavpackPackSamples (wpc, sample_buffer, sample_count)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n            free (sample_buffer);\n            free (input_buffer);\n            return WAVPACK_HARD_ERROR;\n        }\n\n        if (check_break ()) {\n#if defined(_WIN32)\n            fprintf (stderr, &quot;^C\\n&quot;);\n#else\n            fprintf (stderr, &quot;\\n&quot;);\n#endif\n            fflush (stderr);\n            free (sample_buffer);\n            free (input_buffer);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (WavpackGetProgress (wpc) != -1.0 &amp;&amp;\n            progress != floor (WavpackGetProgress (wpc) * encode_time_percent + 0.5)) {\n                int nobs = progress == -1.0;\n\n                progress = floor (WavpackGetProgress (wpc) * encode_time_percent + 0.5);\n                display_progress (progress / 100.0);\n\n                if (!quiet_mode) {\n                    fprintf (stderr, &quot;%s%3d%% done...&quot;,\n                        nobs ? &quot; &quot; : &quot;\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b&quot;, (int) progress);\n                    fflush (stderr);\n                }\n        }\n    }\n\n    free (sample_buffer);\n    free (input_buffer);\n\n    if (!WavpackFlushSamples (wpc)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n        return WAVPACK_HARD_ERROR;\n    }\n\n    if (md5_digest_source)\n        MD5_Final (md5_digest_source, &amp;md5_context);\n\n    return WAVPACK_NO_ERROR;\n}\n\nstatic const unsigned char bit_reverse_table [] = {\n    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff\n};\n\n#define DSD_BLOCKSIZE 4096\n\nstatic int pack_dsd_audio (WavpackContext *wpc, FILE *infile, int qmode, unsigned char *new_order, unsigned char *md5_digest_source)\n{\n    int res = WAVPACK_NO_ERROR, dsd_blocks = 1;\n    int64_t samples_remaining;\n    double progress = -1.0;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t *sample_buffer;\n    unsigned char *input_buffer;\n    MD5_CTX md5_context;\n\n    if (md5_digest_source)\n        MD5_Init (&amp;md5_context);\n\n    if (worker_threads &amp;&amp; num_channels &lt;= 2)\n        dsd_blocks = (worker_threads + 1) * 12;\n\n    WavpackPackInit (wpc);\n    input_buffer = malloc (DSD_BLOCKSIZE * num_channels);\n    sample_buffer = malloc (DSD_BLOCKSIZE * dsd_blocks * sizeof (int32_t) * num_channels);\n    samples_remaining = WavpackGetNumSamples64 (wpc);\n\n    while (samples_remaining) {\n        int32_t buffer_sample_count = 0, dsd_block;\n        int32_t *sptr = sample_buffer;\n\n        for (dsd_block = 0; dsd_block &lt; dsd_blocks &amp;&amp; samples_remaining; dsd_block++) {\n            uint32_t bytes_to_read, bytes_read = 0;\n            int32_t sample_count;\n\n            if ((qmode &amp; (QMODE_DSD_IN_BLOCKS | QMODE_IGNORE_LENGTH)) || samples_remaining &gt; DSD_BLOCKSIZE)\n                bytes_to_read = DSD_BLOCKSIZE * num_channels;\n            else\n                bytes_to_read = (uint32_t) samples_remaining * num_channels;\n\n            DoReadFile (infile, input_buffer, bytes_to_read, &amp;bytes_read);\n\n            if (qmode &amp; QMODE_DSD_IN_BLOCKS) {\n                if (bytes_read != bytes_to_read) {\n                    error_line (&quot;incomplete DSD block!&quot;);\n                    samples_remaining = sample_count = 0;\n                }\n                else if (samples_remaining &lt; DSD_BLOCKSIZE)\n                    sample_count = (int32_t) samples_remaining;\n                else\n                    sample_count = DSD_BLOCKSIZE;\n            }\n            else\n                sample_count = bytes_read / num_channels;\n\n            samples_remaining -= sample_count;\n\n            // if we have reordering to do because the user used the --channel-order option to define\n            // an order that does not match the Microsoft order, then we do that BEFORE the MD5 because\n            // this reordering is permanent (i.e., we will not unreorder on decode) and we want the\n            // MD5 to match the new order\n\n            if (new_order &amp;&amp; !(qmode &amp; QMODE_REORDERED_CHANS)) {\n                if (qmode &amp; QMODE_DSD_IN_BLOCKS)\n                    reorder_channels (input_buffer, new_order, num_channels, 1, DSD_BLOCKSIZE);\n                else\n                    reorder_channels (input_buffer, new_order, num_channels, sample_count, 1);\n            }\n\n            if (md5_digest_source)\n                MD5_Update (&amp;md5_context, input_buffer, bytes_read);\n\n            if (!sample_count)\n                break;\n\n            if (sample_count) {\n                if (qmode &amp; QMODE_DSD_IN_BLOCKS) {\n                    int32_t sindex, non_null = 0;\n\n                    for (sindex = 0; sindex &lt; DSD_BLOCKSIZE; ++sindex) {\n                        unsigned char *srcp = input_buffer + sindex;\n                        int cc;\n\n                        for (cc = num_channels; cc--; srcp += DSD_BLOCKSIZE)\n                            if (sindex &lt; sample_count)\n                                *sptr++ = (qmode &amp; QMODE_DSD_LSB_FIRST) ? bit_reverse_table [*srcp] : *srcp;\n                            else if (*srcp)\n                                non_null++;\n                    }\n\n                    if (non_null) {\n                        error_line (&quot;blocks not padded with NULLs, MD5 will not match!&quot;);\n                        res = WAVPACK_WARNINGS;\n                    }\n                }\n                else {\n                    int32_t scount = sample_count * num_channels;\n                    unsigned char *iptr = input_buffer;\n\n                    while (scount--)\n                        *sptr++ = *iptr++;\n                }\n            }\n\n            buffer_sample_count += sample_count;\n        }\n\n        if (!WavpackPackSamples (wpc, sample_buffer, buffer_sample_count)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n            free (sample_buffer);\n            free (input_buffer);\n            return WAVPACK_HARD_ERROR;\n        }\n\n        if (check_break ()) {\n#if defined(_WIN32)\n            fprintf (stderr, &quot;^C\\n&quot;);\n#else\n            fprintf (stderr, &quot;\\n&quot;);\n#endif\n            fflush (stderr);\n            free (sample_buffer);\n            free (input_buffer);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (WavpackGetProgress (wpc) != -1.0 &amp;&amp;\n            progress != floor (WavpackGetProgress (wpc) * encode_time_percent + 0.5)) {\n                int nobs = progress == -1.0;\n\n                progress = floor (WavpackGetProgress (wpc) * encode_time_percent + 0.5);\n                display_progress (progress / 100.0);\n\n                if (!quiet_mode) {\n                    fprintf (stderr, &quot;%s%3d%% done...&quot;,\n                        nobs ? &quot; &quot; : &quot;\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b&quot;, (int) progress);\n                    fflush (stderr);\n                }\n        }\n    }\n\n    free (sample_buffer);\n    free (input_buffer);\n\n    if (!WavpackFlushSamples (wpc)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (wpc));\n        return WAVPACK_HARD_ERROR;\n    }\n\n    if (md5_digest_source)\n        MD5_Final (md5_digest_source, &amp;md5_context);\n\n    return res;\n}\n\n// This function transcodes a single WavPack file &quot;infilename&quot; and stores the resulting\n// WavPack file at &quot;outfilename&quot;. If &quot;out2filename&quot; is specified, then the &quot;correction&quot;\n// file would go there. The files are opened and closed in this function and the &quot;config&quot;\n// structure specifies the mode of compression. Note that lossy to lossless transcoding\n// is not allowed (no technical reason, it&#x27;s just dumb, and could result in files that\n// fail their MD5 verification test).\n\nstatic int repack_file (char *infilename, char *outfilename, char *out2filename, const WavpackConfig *config)\n{\n    int output_lossless = !(config-&gt;flags &amp; CONFIG_HYBRID_FLAG) || (config-&gt;flags &amp; CONFIG_CREATE_WVC);\n    int flags = OPEN_WVC | OPEN_TAGS | OPEN_DSD_NATIVE | OPEN_ALT_TYPES, imported_tag_items = 0;\n    char *outfilename_temp = NULL, *out2filename_temp = NULL;\n    int use_tempfiles = (out2filename != NULL), input_mode;\n    unsigned char md5_verify [16], md5_display [16];\n    WavpackConfig loc_config = *config;\n    WavpackContext *infile, *outfile;\n    write_id wv_file, wvc_file;\n    int64_t total_samples = 0;\n    unsigned char *chan_ids;\n    char error [80];\n    double dtime;\n    int result;\n\n#if defined(__WATCOMC__)\n    struct _timeb time1, time2;\n#elif defined(_WIN32)\n    struct __timeb64 time1, time2;\n#else\n    struct timeval time1, time2;\n    struct timezone timez;\n#endif\n\n    if (!(loc_config.qmode &amp; QMODE_NO_STORE_WRAPPER) || import_id3)\n        flags |= OPEN_WRAPPER;\n\n#if defined(_WIN32)\n    flags |= OPEN_FILE_UTF8;\n#endif\n\n    if (worker_threads)\n        flags |= worker_threads &lt;&lt; OPEN_THREADS_SHFT;\n\n    // use library to open input WavPack file\n\n    infile = WavpackOpenFileInput (infilename, error, flags, 0);\n\n    if (!infile) {\n        error_line (error);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    input_mode = WavpackGetMode (infile);\n\n    if (!(input_mode &amp; MODE_LOSSLESS) &amp;&amp; output_lossless) {\n        error_line (&quot;can&#x27;t transcode lossy file %s to lossless...not allowed!&quot;, infilename);\n        WavpackCloseFile (infile);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    total_samples = WavpackGetNumSamples64 (infile);\n\n    if (total_samples == -1) {\n        error_line (&quot;can&#x27;t transcode file %s of unknown length!&quot;, infilename);\n        WavpackCloseFile (infile);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    // open an output context\n\n    CLEAR (wv_file);\n    CLEAR (wvc_file);\n    outfile = WavpackOpenFileOutput (write_block, &amp;wv_file, out2filename ? &amp;wvc_file : NULL);\n\n    // check both output files for overwrite warning required\n\n    if (*outfilename != &#x27;-&#x27; &amp;&amp; (wv_file.file = fopen (outfilename, &quot;rb&quot;)) != NULL) {\n        DoCloseHandle (wv_file.file);\n        use_tempfiles = 1;\n\n        if (no_overwrite) {\n            error_line (&quot;not overwriting %s&quot;, FN_FIT (outfilename));\n            WavpackCloseFile (infile);\n            WavpackCloseFile (outfile);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (!overwrite_all) {\n            if (output_lossless)\n                fprintf (stderr, &quot;overwrite %s (yes/no/all)? &quot;, FN_FIT (outfilename));\n            else\n                fprintf (stderr, &quot;overwrite %s with lossy transcode (yes/no/all)? &quot;, FN_FIT (outfilename));\n\n            fflush (stderr);\n\n            if (set_console_title)\n                DoSetConsoleTitle (&quot;overwrite?&quot;);\n\n            switch (yna ()) {\n                case &#x27;n&#x27;:\n                    WavpackCloseFile (infile);\n                    WavpackCloseFile (outfile);\n                    return WAVPACK_SOFT_ERROR;\n\n                case &#x27;a&#x27;:\n                    overwrite_all = 1;\n            }\n        }\n    }\n\n    if (out2filename &amp;&amp; !overwrite_all &amp;&amp; (wvc_file.file = fopen (out2filename, &quot;rb&quot;)) != NULL) {\n        DoCloseHandle (wvc_file.file);\n\n        if (no_overwrite) {\n            error_line (&quot;not overwriting %s&quot;, FN_FIT (outfilename));\n            WavpackCloseFile (infile);\n            WavpackCloseFile (outfile);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        fprintf (stderr, &quot;overwrite %s (yes/no/all)? &quot;, FN_FIT (out2filename));\n        fflush (stderr);\n\n        if (set_console_title)\n            DoSetConsoleTitle (&quot;overwrite?&quot;);\n\n        switch (yna ()) {\n\n            case &#x27;n&#x27;:\n                WavpackCloseFile (infile);\n                WavpackCloseFile (outfile);\n                return WAVPACK_SOFT_ERROR;\n\n            case &#x27;a&#x27;:\n                overwrite_all = 1;\n        }\n    }\n\n    // if we are using temp files, either because the output filename already exists or we are creating a\n    // &quot;correction&quot; file, search for and generate the corresponding names here\n\n    if (use_tempfiles) {\n        FILE *testfile;\n        int count = 0;\n\n        outfilename_temp = malloc (strlen (outfilename) + 16);\n\n        if (out2filename)\n            out2filename_temp = malloc (strlen (outfilename) + 16);\n\n        while (1) {\n            strcpy (outfilename_temp, outfilename);\n\n            if (filespec_ext (outfilename_temp)) {\n                if (count++)\n                    sprintf (filespec_ext (outfilename_temp), &quot;.tmp%d&quot;, count-1);\n                else\n                    strcpy (filespec_ext (outfilename_temp), &quot;.tmp&quot;);\n\n                strcat (outfilename_temp, filespec_ext (outfilename));\n            }\n            else {\n                if (count++)\n                    sprintf (outfilename_temp + strlen (outfilename_temp), &quot;.tmp%d&quot;, count-1);\n                else\n                    strcat (outfilename_temp, &quot;.tmp&quot;);\n            }\n\n            testfile = fopen (outfilename_temp, &quot;rb&quot;);\n\n            if (testfile) {\n                fclose (testfile);\n                continue;\n            }\n\n            if (out2filename) {\n                strcpy (out2filename_temp, outfilename_temp);\n                strcat (out2filename_temp, &quot;c&quot;);\n\n                testfile = fopen (out2filename_temp, &quot;rb&quot;);\n\n                if (testfile) {\n                    fclose (testfile);\n                    continue;\n                }\n            }   \n\n            break;\n        }\n    }\n\n#if defined(__WATCOMC__)\n    _ftime (&amp;time1);\n#elif defined(_WIN32)\n    _ftime64 (&amp;time1);\n#else\n    gettimeofday(&amp;time1,&amp;timez);\n#endif\n\n    // open output file for writing\n\n    if (*outfilename == &#x27;-&#x27;) {\n        wv_file.file = stdout;\n#if defined(_WIN32)\n        _setmode (_fileno (stdout), O_BINARY);\n#endif\n#if defined(__OS2__)\n        setmode (fileno (stdout), O_BINARY);\n#endif\n    }\n    else if ((wv_file.file = fopen (use_tempfiles ? outfilename_temp : outfilename, &quot;w+b&quot;)) == NULL) {\n        error_line (&quot;can&#x27;t create file %s!&quot;, use_tempfiles ? outfilename_temp : outfilename);\n        WavpackCloseFile (infile);\n        WavpackCloseFile (outfile);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (!quiet_mode) {\n        if (*outfilename == &#x27;-&#x27;)\n            fprintf (stderr, &quot;packing %s to stdout,&quot;, *infilename == &#x27;-&#x27; ? &quot;stdin&quot; : FN_FIT (infilename));\n        else if (out2filename)\n            fprintf (stderr, &quot;creating %s (+%s),&quot;, FN_FIT (outfilename), filespec_ext (out2filename));\n        else\n            fprintf (stderr, &quot;creating %s,&quot;, FN_FIT (outfilename));\n\n        fflush (stderr);\n    }\n\n    WavpackSetFileInformation (outfile, WavpackGetFileExtension (infile), WavpackGetFileFormat (infile));\n\n    // unless we&#x27;ve been specifically told not to, copy RIFF header\n\n    if (WavpackGetWrapperBytes (infile)) {\n        if (!(loc_config.qmode &amp; QMODE_NO_STORE_WRAPPER) &amp;&amp; !WavpackAddWrapper (outfile, WavpackGetWrapperData (infile), WavpackGetWrapperBytes (infile))) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n            WavpackCloseFile (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (outfile);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackFreeWrapper (infile);\n    }\n\n    loc_config.bytes_per_sample = WavpackGetBytesPerSample (infile);\n    loc_config.bits_per_sample = WavpackGetBitsPerSample (infile);\n    loc_config.channel_mask = WavpackGetChannelMask (infile);\n    loc_config.num_channels = WavpackGetNumChannels (infile);\n    loc_config.sample_rate = WavpackGetSampleRate (infile);\n    loc_config.qmode |= WavpackGetQualifyMode (infile);\n    loc_config.worker_threads = worker_threads;\n    chan_ids = malloc (loc_config.num_channels + 1);\n    WavpackGetChannelIdentities (infile, chan_ids);\n\n    if (input_mode &amp; MODE_FLOAT)\n        loc_config.float_norm_exp = WavpackGetFloatNormExp (infile);\n\n    if (input_mode &amp; MODE_MD5)\n        loc_config.flags |= CONFIG_MD5_CHECKSUM;\n\n    if (!WavpackSetConfiguration64 (outfile, &amp;loc_config, total_samples, chan_ids)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n        WavpackCloseFile (infile);\n        DoCloseHandle (wv_file.file);\n        DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n        WavpackCloseFile (outfile);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    free (chan_ids);\n\n    if (loc_config.qmode &amp; QMODE_REORDERED_CHANS) {\n        uint32_t layout = WavpackGetChannelLayout (infile, NULL);\n        unsigned char order [256];\n\n        if (layout &amp; 0xff) {\n            WavpackGetChannelLayout (infile, order);\n            WavpackSetChannelLayout (outfile, layout, order);\n        }\n    }\n    else\n        WavpackSetChannelLayout (outfile, WavpackGetChannelLayout (infile, NULL), NULL);\n\n    // if we are creating a &quot;correction&quot; file, open it now for writing\n\n    if (out2filename) {\n        if ((wvc_file.file = fopen (use_tempfiles ? out2filename_temp : out2filename, &quot;w+b&quot;)) == NULL) {\n            error_line (&quot;can&#x27;t create correction file!&quot;);\n            WavpackCloseFile (infile);\n            DoCloseHandle (wv_file.file);\n            DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n            WavpackCloseFile (outfile);\n            return WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    // pack the audio portion of the file now; calculate md5 if we&#x27;re writing it to the file or verify mode is active\n\n    result = repack_audio (outfile, infile, md5_verify);\n\n    // before anything else, make sure the source file was read without errors\n\n    if (result == WAVPACK_NO_ERROR) {\n        if (WavpackGetNumErrors (infile)) {\n            error_line (&quot;missing data or crc errors detected in %d block(s)!&quot;, WavpackGetNumErrors (infile));\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n        if (WavpackGetSampleIndex64 (outfile) != total_samples) {\n            error_line (&quot;incorrect number of samples read from source file!&quot;);\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n        if ((input_mode &amp; MODE_LOSSLESS) &amp;&amp; !quantize_bits) {\n            unsigned char md5_source [16];\n\n            if (WavpackGetMD5Sum (infile, md5_source) &amp;&amp; memcmp (md5_source, md5_verify, sizeof (md5_source))) {\n                error_line (&quot;MD5 signature in source should match, but does not!&quot;);\n                result = WAVPACK_SOFT_ERROR;\n            }\n        }\n    }\n\n    // copy the md5 sum if present in source; if there&#x27;s not one there and the user asked to add it,\n    // store the one we just calculated\n\n    if (result == WAVPACK_NO_ERROR) {\n        if (WavpackGetMD5Sum (infile, md5_display)) {\n            if ((input_mode &amp; MODE_LOSSLESS) &amp;&amp; quantize_bits)\n                memcpy (md5_display, md5_verify, sizeof (md5_verify));\n                \n            WavpackStoreMD5Sum (outfile, md5_display);\n        }\n        else if (loc_config.flags &amp; CONFIG_MD5_CHECKSUM) {\n            memcpy (md5_display, md5_verify, sizeof (md5_display));\n            WavpackStoreMD5Sum (outfile, md5_verify);\n        }\n    }\n\n    // this is where we deal with a trailer (i.e., trailing wrapper) if there is one\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; WavpackGetWrapperBytes (infile)) {\n        unsigned char *buffer = WavpackGetWrapperData (infile);\n        int wrapper_size = WavpackGetWrapperBytes (infile);\n\n        // unless we&#x27;ve been specifically told not to, copy RIFF trailer to output file\n\n        if (!(loc_config.qmode &amp; QMODE_NO_STORE_WRAPPER) &amp;&amp; !WavpackAddWrapper (outfile, buffer, wrapper_size)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n        // if we&#x27;re supposed to try to import ID3 tags, check for and do that now\n        // (but only error on a bad tag, not just a missing one or one with no applicable items)\n\n        if (result == WAVPACK_NO_ERROR &amp;&amp; import_id3 &amp;&amp; wrapper_size &gt; 10 &amp;&amp; !strncmp ((char *) buffer, &quot;ID3&quot;, 3)) {\n            int32_t bytes_used, id3_res;\n            char error [80];\n\n            // first we do a &quot;dry run&quot; pass through the ID3 tag, and only if that passes do we try to write the tag items\n\n            id3_res = ImportID3v2 (NULL, buffer, wrapper_size, error, &amp;bytes_used);\n\n            if (!allow_huge_tags &amp;&amp; bytes_used &gt; 1048576) {\n                error_line (&quot;imported tag items exceed 1 MB, use --allow-huge-tags to override&quot;);\n                result = WAVPACK_SOFT_ERROR;\n            }\n            else if (bytes_used &gt; 1048576 * 16) {\n                error_line (&quot;imported tag items exceed 16 MB&quot;);\n                result = WAVPACK_SOFT_ERROR;\n            }\n            else {\n                if (id3_res &gt; 0)\n                    id3_res = ImportID3v2 (outfile, buffer, wrapper_size, error, NULL);\n\n                if (id3_res &lt; 0) {\n                    error_line (&quot;ID3v2 import: %s&quot;, error);\n                    result = WAVPACK_SOFT_ERROR;\n                }\n                else if (id3_res &gt; 0)\n                    imported_tag_items = id3_res;\n            }\n        }\n\n        WavpackFreeWrapper (infile);\n    }\n\n    // we&#x27;re now done with any WavPack blocks, so flush any remaining data\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; !WavpackFlushSamples (outfile)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n        result = WAVPACK_HARD_ERROR;\n    }\n\n    // if still no errors, check to see if we need to create &amp; write a tag\n    // (which is NOT stored in regular WavPack blocks)\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; ((input_mode &amp; MODE_VALID_TAG) || num_tag_items || imported_tag_items)) {\n        int num_binary_items = WavpackGetNumBinaryTagItems (infile);\n        int num_items = WavpackGetNumTagItems (infile), i;\n        int item_len, value_len;\n        char *item, *value;\n        int res = TRUE;\n\n        for (i = 0; i &lt; num_items &amp;&amp; res; ++i) {\n            item_len = WavpackGetTagItemIndexed (infile, i, NULL, 0);\n            item = malloc (item_len + 1);\n            WavpackGetTagItemIndexed (infile, i, item, item_len + 1);\n\n            // don&#x27;t copy the values from the &quot;encoder&quot; or &quot;settings&quot; items because\n            // these should be based on the current encoder and user settings\n\n            if (!stricmp (item, &quot;encoder&quot;)) {\n                value = malloc (80);\n                sprintf (value, &quot;WavPack %s&quot;, PACKAGE_VERSION);\n                value_len = (int) strlen (value);\n            }\n            else if (!stricmp (item, &quot;settings&quot;)) {\n                value = malloc (256);\n                make_settings_string (value, &amp;loc_config);\n                value_len = (int) strlen (value);\n            }\n            else {\n                value_len = WavpackGetTagItem (infile, item, NULL, 0);\n                value = malloc (value_len + 1);\n                WavpackGetTagItem (infile, item, value, value_len + 1);\n            }\n\n            res = WavpackAppendTagItem (outfile, item, value, value_len);\n            free (value);\n            free (item);\n        }\n\n        for (i = 0; i &lt; num_binary_items &amp;&amp; res; ++i) {\n            item_len = WavpackGetBinaryTagItemIndexed (infile, i, NULL, 0);\n            item = malloc (item_len + 1);\n            WavpackGetBinaryTagItemIndexed (infile, i, item, item_len + 1);\n            value_len = WavpackGetBinaryTagItem (infile, item, NULL, 0);\n            value = malloc (value_len);\n            value_len = WavpackGetBinaryTagItem (infile, item, value, value_len);\n            res = WavpackAppendBinaryTagItem (outfile, item, value, value_len);\n            free (value);\n            free (item);\n        }\n\n        for (i = 0; i &lt; num_tag_items &amp;&amp; res; ++i)\n            if (tag_items [i].vsize) {\n                if (tag_items [i].binary) \n                    res = WavpackAppendBinaryTagItem (outfile, tag_items [i].item, tag_items [i].value, tag_items [i].vsize);\n                else\n                    res = WavpackAppendTagItem (outfile, tag_items [i].item, tag_items [i].value, tag_items [i].vsize);\n            }\n            else\n                WavpackDeleteTagItem (outfile, tag_items [i].item);\n\n        if (!res || !WavpackWriteTag (outfile)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n            result = WAVPACK_HARD_ERROR;\n        }\n    }\n\n    WavpackCloseFile (infile);     // we&#x27;re now done with input file, so close\n\n    // at this point we&#x27;re completely done with the files, so close &#x27;em whether there\n    // were any other errors or not\n\n    if (!DoCloseHandle (wv_file.file)) {\n        error_line (&quot;can&#x27;t close WavPack file!&quot;);\n\n        if (result == WAVPACK_NO_ERROR)\n            result = WAVPACK_SOFT_ERROR;\n    }\n\n    if (out2filename &amp;&amp; !DoCloseHandle (wvc_file.file)) {\n        error_line (&quot;can&#x27;t close correction file!&quot;);\n\n        if (result == WAVPACK_NO_ERROR)\n            result = WAVPACK_SOFT_ERROR;\n    }\n\n    // if there have been no errors up to now, and verify mode is enabled, do that now; only pass in the md5 if this\n    // was a lossless operation (either explicitly or because a high lossy bitrate resulted in lossless)\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; verify_mode)\n        result = verify_audio (use_tempfiles ? outfilename_temp : outfilename, !WavpackLossyBlocks (outfile) ? md5_verify : NULL);\n\n    // if there were any errors, delete the output files, close the context, and return the error\n\n    if (result != WAVPACK_NO_ERROR) {\n        DoDeleteFile (use_tempfiles ? outfilename_temp : outfilename);\n\n        if (out2filename)\n            DoDeleteFile (use_tempfiles ? out2filename_temp : out2filename);\n\n        WavpackCloseFile (outfile);\n        return result;\n    }\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; copy_time)\n        if (!copy_timestamp (infilename, use_tempfiles ? outfilename_temp : outfilename) ||\n            (out2filename &amp;&amp; !copy_timestamp (infilename, use_tempfiles ? out2filename_temp : out2filename)))\n                error_line (&quot;failure copying time stamp!&quot;);\n\n    // delete source file(s) if that option is enabled (this is done before temp file rename to make sure\n    // we don&#x27;t delete the file(s) we just created)\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; delete_source) {\n        int res;\n\n        if (stricmp (infilename, outfilename)) {\n            res = DoDeleteFile (infilename);\n\n            if (!quiet_mode || !res)\n                error_line (&quot;%s source file %s&quot;, res ?\n                    &quot;deleted&quot; : &quot;can&#x27;t delete&quot;, infilename);\n        }\n    \n        if (input_mode &amp; MODE_WVC) {\n            char in2filename [PATH_MAX];\n\n            strcpy (in2filename, infilename);\n            strcat (in2filename, &quot;c&quot;);\n\n            if (!out2filename || stricmp (in2filename, out2filename)) {\n                res = DoDeleteFile (in2filename);\n\n                if (!quiet_mode || !res)\n                    error_line (&quot;%s source file %s&quot;, res ?\n                        &quot;deleted&quot; : &quot;can&#x27;t delete&quot;, in2filename);\n            }\n        }\n    }\n\n    // if we were writing to a temp file because the target file already existed,\n    // do the rename / overwrite now (and if that fails, return the error)\n\n    if (use_tempfiles) {\n#if defined(_WIN32)\n        FILE *temp;\n\n        if (remove (outfilename) &amp;&amp; (temp = fopen (outfilename, &quot;rb&quot;))) {\n            error_line (&quot;can not remove file %s, result saved in %s!&quot;, outfilename, outfilename_temp);\n            result = WAVPACK_SOFT_ERROR;\n            fclose (temp);\n        }\n        else\n#endif\n        if (rename (outfilename_temp, outfilename)) {\n            error_line (&quot;can not rename temp file %s to %s!&quot;, outfilename_temp, outfilename);\n            result = WAVPACK_SOFT_ERROR;\n        }\n\n        if (out2filename) {\n#if defined(_WIN32)\n            FILE *temp;\n\n            if (remove (out2filename) &amp;&amp; (temp = fopen (out2filename, &quot;rb&quot;))) {\n                error_line (&quot;can not remove file %s, result saved in %s!&quot;, out2filename, out2filename_temp);\n                result = WAVPACK_SOFT_ERROR;\n                fclose (temp);\n            }\n            else\n#endif\n            if (rename (out2filename_temp, out2filename)) {\n                error_line (&quot;can not rename temp file %s to %s!&quot;, out2filename_temp, out2filename);\n                result = WAVPACK_SOFT_ERROR;\n            }\n        }\n\n        free (outfilename_temp);\n        if (out2filename) free (out2filename_temp);\n\n        if (result != WAVPACK_NO_ERROR) {\n            WavpackCloseFile (outfile);\n            return result;\n        }\n    }\n\n    // if we&#x27;re not creating a correction file but there&#x27;s an existing one\n    // with the appropriate name, delete it because it&#x27;s now very obsolete\n\n    if (!out2filename &amp;&amp; outfilename &amp;&amp; *outfilename != &#x27;-&#x27;) {\n        char out2filename_obsolete [PATH_MAX];\n        FILE *testfile;\n        int res;\n\n        strcpy (out2filename_obsolete, outfilename);\n        strcat (out2filename_obsolete, &quot;c&quot;);\n\n        if ((testfile = fopen (out2filename_obsolete, &quot;rb&quot;)) != NULL) {\n            fclose (testfile);\n            res = DoDeleteFile (out2filename_obsolete);\n\n            if (!quiet_mode || !res)\n                error_line (&quot;%s obsolete correction file %s&quot;,\n                    res ? &quot;deleted&quot; : &quot;can&#x27;t delete&quot;, out2filename_obsolete);\n        }\n    }\n\n    // compute and display the time consumed along with some other details of\n    // the packing operation, and then return WAVPACK_NO_ERROR\n\n#if defined(__WATCOMC__)\n    _ftime (&amp;time2);\n    dtime = time2.time + time2.millitm / 1000.0;\n    dtime -= time1.time + time1.millitm / 1000.0;\n#elif defined(_WIN32)\n    _ftime64 (&amp;time2);\n    dtime = time2.time + time2.millitm / 1000.0;\n    dtime -= time1.time + time1.millitm / 1000.0;\n#else\n    gettimeofday(&amp;time2,&amp;timez);\n    dtime = time2.tv_sec + time2.tv_usec / 1000000.0;\n    dtime -= time1.tv_sec + time1.tv_usec / 1000000.0;\n#endif\n\n    if ((loc_config.flags &amp; CONFIG_CALC_NOISE) &amp;&amp; WavpackGetEncodedNoise (outfile, NULL) &gt; 0.0) {\n        int full_scale_bits = WavpackGetBitsPerSample (outfile);\n        double full_scale_rms = 0.5, sum, peak;\n\n        while (full_scale_bits--)\n            full_scale_rms *= 2.0;\n\n        full_scale_rms = full_scale_rms * (full_scale_rms - 1.0) * 0.5;\n        sum = WavpackGetEncodedNoise (outfile, &amp;peak);\n\n        error_line (&quot;ave noise = %.2f dB, peak noise = %.2f dB&quot;,\n            log10 (sum / WavpackGetNumSamples (outfile) / full_scale_rms) * 10,\n            log10 (peak / full_scale_rms) * 10);\n    }\n\n    if (!quiet_mode) {\n        char *file, *fext, *oper, *cmode, cratio [16] = &quot;&quot;;\n\n        if (imported_tag_items)\n            error_line (&quot;successfully imported %d items from ID3v2 tag&quot;, imported_tag_items);\n\n        if (config-&gt;flags &amp; CONFIG_MD5_CHECKSUM) {\n            char md5_string [] = &quot;original md5 signature: 00000000000000000000000000000000&quot;;\n            int i;\n\n            for (i = 0; i &lt; 16; ++i)\n                sprintf (md5_string + 24 + (i * 2), &quot;%02x&quot;, md5_display [i]);\n\n            error_line (md5_string);\n        }\n\n        if (outfilename &amp;&amp; *outfilename != &#x27;-&#x27;) {\n            file = FN_FIT (outfilename);\n            fext = wvc_file.bytes_written ? &quot; (+.wvc)&quot; : &quot;&quot;;\n            oper = verify_mode ? &quot;created (and verified)&quot; : &quot;created&quot;;\n        }\n        else {\n            file = (*infilename == &#x27;-&#x27;) ? &quot;stdin&quot; : FN_FIT (infilename);\n            fext = &quot;&quot;;\n            oper = &quot;packed&quot;;\n        }\n\n        if (WavpackLossyBlocks (outfile)) {\n            cmode = &quot;lossy&quot;;\n\n            if (WavpackGetAverageBitrate (outfile, TRUE) != 0.0)\n                sprintf (cratio, &quot;, %d kbps&quot;, (int) (WavpackGetAverageBitrate (outfile, TRUE) / 1000.0));\n        }\n        else {\n            cmode = &quot;lossless&quot;;\n\n            if (WavpackGetRatio (outfile) != 0.0)\n                sprintf (cratio, &quot;, %.2f%%&quot;, 100.0 - WavpackGetRatio (outfile) * 100.0);\n        }\n\n        error_line (&quot;%s %s%s in %.2f secs (%s%s)&quot;, oper, file, fext, dtime, cmode, cratio);\n    }\n\n    WavpackCloseFile (outfile);\n    return WAVPACK_NO_ERROR;\n}\n\n// This function handles the actual audio data transcoding. It assumes that the\n// input file is positioned at the beginning of the audio data and that the\n// WavPack configuration has been set. If the &quot;md5_digest_source&quot; pointer is not\n// NULL, then a MD5 sum is calculated on the audio data during the transcoding\n// and stored there at the completion. Note that the md5 requires a conversion\n// to the native data format (endianness and bytes per sample) that is not\n// required otherwise.\n\nstatic int repack_audio (WavpackContext *outfile, WavpackContext *infile, unsigned char *md5_digest_source)\n{\n    int bps = WavpackGetBytesPerSample (infile), num_channels = WavpackGetNumChannels (infile);\n    int qmode = WavpackGetQualifyMode (infile);\n    unsigned char *new_channel_order = NULL;\n    uint32_t input_samples = INPUT_SAMPLES;\n    unsigned char *format_buffer;\n    int32_t *sample_buffer;\n    double progress = -1.0;\n    MD5_CTX md5_context;\n    int32_t quantize_bit_mask = 0;\n    double fquantize_scale = 1.0, fquantize_iscale = 1.0;\n\n    if (worker_threads &amp;&amp; num_channels &lt;= 2)\n        input_samples = (worker_threads + 1) * DSD_BLOCKSIZE * 12;\n    else\n        while (input_samples * num_channels &gt; 8388608 / sizeof (int32_t))\n            input_samples &gt;&gt;= 1;\n\n    if (md5_digest_source) {\n        format_buffer = malloc (input_samples * bps * WavpackGetNumChannels (outfile));\n        MD5_Init (&amp;md5_context);\n\n        if (qmode &amp; QMODE_REORDERED_CHANS) {\n            int layout = WavpackGetChannelLayout (infile, NULL), i;\n\n            if ((layout &amp; 0xff) &lt;= num_channels) {\n                new_channel_order = malloc (num_channels);\n\n                for (i = 0; i &lt; num_channels; ++i)\n                    new_channel_order [i] = i;\n\n                WavpackGetChannelLayout (infile, new_channel_order);\n            }\n        }\n    }\n\n    WavpackPackInit (outfile);\n    sample_buffer = malloc (input_samples * sizeof (int32_t) * WavpackGetNumChannels (outfile));\n\n    if (quantize_bits &amp;&amp; quantize_bits &lt; bps*8) {\n        quantize_bit_mask = ~((1&lt;&lt;(bps*8-quantize_bits))-1);\n        if (MODE_FLOAT == (WavpackGetMode(infile) &amp; MODE_FLOAT)) {\n            int float_norm_exp = WavpackGetFloatNormExp (infile);\n            fquantize_scale = exp2 (quantize_bits + 126 - float_norm_exp);\n            fquantize_iscale = exp2 (float_norm_exp - 126 - quantize_bits);\n        }\n    }\n\n    while (1) {\n        uint32_t sample_count = WavpackUnpackSamples (infile, sample_buffer, input_samples);\n\n        if (!sample_count)\n            break;\n\n        if (quantize_bit_mask) {\n            unsigned int x,l = sample_count * num_channels;\n            if (0 == (WavpackGetMode(infile) &amp; MODE_FLOAT)) {\n                if (quantize_round) {\n                    int32_t offset = (quantize_bit_mask &gt;&gt; 1) ^ quantize_bit_mask;\n                    int shift = 32 - bps * 8;\n\n                    for (x = 0; x &lt; l; x ++)\n                        if (sample_buffer[x] &lt; 0 || ((sample_buffer[x] + offset) &lt;&lt; shift) &gt; 0)\n                            sample_buffer[x] += offset;\n                }\n\n                for (x = 0; x &lt; l; x ++) sample_buffer[x] &amp;= quantize_bit_mask;\n            }\n            else {\n                for (x = 0; x &lt; l; x ++) {\n                    const float f = *(float *)&amp;sample_buffer[x];\n                    *(float *)&amp;sample_buffer[x] = (float) (floor(f * fquantize_scale + 0.5) * fquantize_iscale);\n                }\n            }\n        }\n\n        if (!WavpackPackSamples (outfile, sample_buffer, sample_count)) {\n            error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n            free (sample_buffer);\n            return WAVPACK_HARD_ERROR;\n        }\n\n        if (md5_digest_source) {\n            if (new_channel_order)\n                unreorder_channels (sample_buffer, new_channel_order, num_channels, sample_count);\n\n            if (qmode &amp; QMODE_DSD_AUDIO) {\n                unsigned char *dptr = format_buffer;\n                int32_t *sptr = sample_buffer;\n\n                if (qmode &amp; QMODE_DSD_IN_BLOCKS) {\n                    while (sample_count) {\n                        uint32_t samples_this_block = sample_count &gt; DSD_BLOCKSIZE ? DSD_BLOCKSIZE : sample_count;\n                        int cc = num_channels;\n\n                        while (cc--) {\n                            uint32_t si;\n\n                            for (si = 0; si &lt; DSD_BLOCKSIZE; si++, sptr += num_channels)\n                                if (si &lt; samples_this_block)\n                                    *dptr++ = (qmode &amp; QMODE_DSD_LSB_FIRST) ? bit_reverse_table [*sptr &amp; 0xff] : *sptr;\n                                else\n                                    *dptr++ = 0;\n\n                            if (cc)\n                                sptr -= (DSD_BLOCKSIZE * num_channels) - 1;\n                            else\n                                sptr -= num_channels - 1;\n                        }\n\n                        if (samples_this_block &lt; sample_count)\n                            sample_count -= samples_this_block;\n                        else\n                            sample_count = 0;\n                    }\n\n                    sample_count = (uint32_t) ((dptr - format_buffer) / num_channels);\n                }\n                else {\n                    int scount = sample_count * num_channels;\n\n                    while (scount--)\n                        *dptr++ = *sptr++;\n                }\n            }\n            else\n                store_samples (format_buffer, sample_buffer, qmode, bps, sample_count * num_channels);\n\n            MD5_Update (&amp;md5_context, format_buffer, bps * sample_count * num_channels);\n        }\n\n        if (check_break ()) {\n#if defined(_WIN32)\n            fprintf (stderr, &quot;^C\\n&quot;);\n#else\n            fprintf (stderr, &quot;\\n&quot;);\n#endif\n            fflush (stderr);\n            free (sample_buffer);\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (WavpackGetProgress (outfile) != -1.0 &amp;&amp;\n            progress != floor (WavpackGetProgress (outfile) * encode_time_percent + 0.5)) {\n                int nobs = progress == -1.0;\n\n                progress = floor (WavpackGetProgress (outfile) * encode_time_percent + 0.5);\n                display_progress (progress / 100.0);\n\n                if (!quiet_mode) {\n                    fprintf (stderr, &quot;%s%3d%% done...&quot;,\n                        nobs ? &quot; &quot; : &quot;\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b&quot;, (int) progress);\n                    fflush (stderr);\n                }\n        }\n    }\n\n    if (new_channel_order)\n        free (new_channel_order);\n\n    free (sample_buffer);\n\n    if (!WavpackFlushSamples (outfile)) {\n        error_line (&quot;%s&quot;, WavpackGetErrorMessage (outfile));\n        return WAVPACK_HARD_ERROR;\n    }\n\n    if (md5_digest_source) {\n        MD5_Final (md5_digest_source, &amp;md5_context);\n        free (format_buffer);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nstatic void reorder_channels (void *data, unsigned char *order, int num_chans,\n    int num_samples, int bytes_per_sample)\n{\n    char reorder_buffer [64], *temp = reorder_buffer;\n    char *src = data;\n\n    if (num_chans * bytes_per_sample &gt; 64)\n        temp = malloc (num_chans * bytes_per_sample);\n\n    while (num_samples--) {\n        char *start = src;\n        int chan;\n\n        for (chan = 0; chan &lt; num_chans; ++chan) {\n            char *dst = temp + (order [chan] * bytes_per_sample);\n            int bc = bytes_per_sample;\n\n            while (bc--)\n                *dst++ = *src++;\n        }\n\n        memcpy (start, temp, num_chans * bytes_per_sample);\n    }\n\n    if (num_chans * bytes_per_sample &gt; 64)\n        free (temp);\n}\n\nstatic void unreorder_channels (int32_t *data, unsigned char *order, int num_chans, int num_samples)\n{\n    int32_t reorder_buffer [16], *temp = reorder_buffer;\n\n    if (num_chans &gt; 16)\n        temp = malloc (num_chans * sizeof (*data));\n\n    while (num_samples--) {\n        int chan;\n\n        for (chan = 0; chan &lt; num_chans; ++chan)\n            temp [chan] = data [order[chan]];\n\n        memcpy (data, temp, num_chans * sizeof (*data));\n        data += num_chans;\n    }\n\n    if (num_chans &gt; 16)\n        free (temp);\n}\n\n// Verify the specified WavPack input file. This function uses the library\n// routines provided in wputils.c to do all unpacking. If an MD5 sum is provided\n// by the caller, then this function will take care of reformatting the data\n// (which is returned in native-endian longs) to the standard little-endian\n// for a proper MD5 verification. Otherwise a lossy verification is assumed,\n// and we only verify the exact number of samples and whether the decoding\n// library detected CRC errors in any WavPack blocks.\n\n#define VERIFY_BLOCKSIZE DSD_BLOCKSIZE\n\nstatic int verify_audio (char *infilename, unsigned char *md5_digest_source)\n{\n    int open_flags = OPEN_WVC | OPEN_DSD_NATIVE | OPEN_ALT_TYPES, blocks = 1;\n    int num_channels, bps, qmode, result = WAVPACK_NO_ERROR;\n    unsigned char *new_channel_order = NULL;\n    int64_t total_unpacked_samples = 0;\n    unsigned char md5_digest_result [16];\n    double progress = -1.0;\n    int32_t *temp_buffer;\n    MD5_CTX md5_context;\n    WavpackContext *wpc;\n    char error [80];\n\n    // use library to open WavPack file\n\n#ifdef _WIN32\n    open_flags |= OPEN_FILE_UTF8;\n#endif\n\n    if (worker_threads)\n        open_flags |= worker_threads &lt;&lt; OPEN_THREADS_SHFT;\n\n    wpc = WavpackOpenFileInput (infilename, error, open_flags, 0);\n\n    if (!wpc) {\n        error_line (error);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (md5_digest_source)\n        MD5_Init (&amp;md5_context);\n\n    qmode = WavpackGetQualifyMode (wpc);\n    num_channels = WavpackGetNumChannels (wpc);\n    bps = WavpackGetBytesPerSample (wpc);\n\n    if (worker_threads &amp;&amp; num_channels &lt;= 2)\n        blocks = (worker_threads + 1) * 12;\n\n    temp_buffer = malloc (VERIFY_BLOCKSIZE * blocks * num_channels * 4);\n\n    if (qmode &amp; QMODE_REORDERED_CHANS) {\n        int layout = WavpackGetChannelLayout (wpc, NULL), i;\n\n        if ((layout &amp; 0xff) &lt;= num_channels) {\n            new_channel_order = malloc (num_channels);\n\n            for (i = 0; i &lt; num_channels; ++i)\n                new_channel_order [i] = i;\n\n            WavpackGetChannelLayout (wpc, new_channel_order);\n        }\n    }\n\n    while (result == WAVPACK_NO_ERROR) {\n        int32_t *sptr = temp_buffer;\n        uint32_t samples_unpacked;\n\n        samples_unpacked = WavpackUnpackSamples (wpc, temp_buffer, VERIFY_BLOCKSIZE * blocks);\n        total_unpacked_samples += samples_unpacked;\n\n        if (!samples_unpacked)\n            break;\n\n        if (md5_digest_source &amp;&amp; new_channel_order)\n            unreorder_channels (temp_buffer, new_channel_order, num_channels, samples_unpacked);\n\n        while (samples_unpacked) {\n            uint32_t samples_this_block = samples_unpacked &gt; VERIFY_BLOCKSIZE ? VERIFY_BLOCKSIZE : samples_unpacked;\n\n            if (md5_digest_source) {\n                if (qmode &amp; QMODE_DSD_AUDIO) {\n                    unsigned char *dsd_buffer = malloc (DSD_BLOCKSIZE * num_channels);\n                    unsigned char *dptr = dsd_buffer;\n\n                    if (qmode &amp; QMODE_DSD_IN_BLOCKS) {\n                        int cc = num_channels;\n\n                        while (cc--) {\n                            uint32_t si;\n\n                            for (si = 0; si &lt; DSD_BLOCKSIZE; si++, sptr += num_channels)\n                                if (si &lt; samples_this_block)\n                                    *dptr++ = (qmode &amp; QMODE_DSD_LSB_FIRST) ? bit_reverse_table [*sptr &amp; 0xff] : *sptr;\n                                else\n                                    *dptr++ = 0;\n\n                            if (cc)\n                                sptr -= (DSD_BLOCKSIZE * num_channels) - 1;\n                            else\n                                sptr -= num_channels - 1;\n                        }\n\n                        samples_this_block = DSD_BLOCKSIZE;   // count the entire block for MD5 (even if partial/last)\n                    }\n                    else {\n                        int scount = samples_this_block * num_channels;\n\n                        while (scount--)\n                            *dptr++ = *sptr++;\n                    }\n\n                    MD5_Update (&amp;md5_context, dsd_buffer, samples_this_block * num_channels);\n                    free (dsd_buffer);\n                }\n                else {\n                    store_samples (sptr, sptr, qmode, bps, samples_this_block * num_channels);\n                    MD5_Update (&amp;md5_context, (unsigned char *) sptr, bps * samples_this_block * num_channels);\n                    sptr += samples_this_block * num_channels;\n                }\n            }\n\n            if (samples_this_block &lt; samples_unpacked)\n                samples_unpacked -= samples_this_block;\n            else\n                samples_unpacked = 0;\n        }\n\n        if (check_break ()) {\n#if defined(_WIN32)\n            fprintf (stderr, &quot;^C\\n&quot;);\n#else\n            fprintf (stderr, &quot;\\n&quot;);\n#endif\n            fflush (stderr);\n            result = WAVPACK_SOFT_ERROR;\n            break;\n        }\n\n        if (WavpackGetProgress (wpc) != -1.0 &amp;&amp;\n            progress != floor (WavpackGetProgress (wpc) * (100.0 - encode_time_percent) + encode_time_percent + 0.5)) {\n\n                progress = floor (WavpackGetProgress (wpc) * (100.0 - encode_time_percent) + encode_time_percent + 0.5);\n                display_progress (progress / 100.0);\n\n                if (!quiet_mode) {\n                    fprintf (stderr, &quot;%s%3d%% done...&quot;,\n                        &quot;\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b&quot;, (int) progress);\n                    fflush (stderr);\n                }\n        }\n    }\n\n    free (temp_buffer);\n\n    if (new_channel_order)\n        free (new_channel_order);\n\n    // If we have been provided an MD5 sum, then the assumption is that we are doing lossless compression (either explicitly\n    // with lossless mode or having a high enough bitrate that the result is lossless) and we can use the MD5 sum as a pretty\n    // definitive verification.\n\n    if (result == WAVPACK_NO_ERROR &amp;&amp; md5_digest_source) {\n        MD5_Final (md5_digest_result, &amp;md5_context);\n\n        if (memcmp (md5_digest_result, md5_digest_source, 16)) {\n            char md5_string1 [] = &quot;00000000000000000000000000000000&quot;;\n            char md5_string2 [] = &quot;00000000000000000000000000000000&quot;;\n            int i;\n\n            for (i = 0; i &lt; 16; ++i) {\n                sprintf (md5_string1 + (i * 2), &quot;%02x&quot;, md5_digest_source [i]);\n                sprintf (md5_string2 + (i * 2), &quot;%02x&quot;, md5_digest_result [i]);\n            }\n\n            error_line (&quot;original md5: %s&quot;, md5_string1);\n            error_line (&quot;verified md5: %s&quot;, md5_string2);\n            error_line (&quot;MD5 signatures should match, but do not!&quot;);\n            result = WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    // If we have not been provided an MD5 sum, then the assumption is that we are doing lossy compression and cannot rely\n    // (obviously) on that for verification. For these cases we make sure that the number of samples generated was exactly\n    // correct and that the WavPack decoding library did not detect an error. There is a simple CRC on every WavPack block\n    // that should catch any random corruption, although it&#x27;s possible that this might miss some decoder bug that occurs\n    // late in the decoding process (e.g., after the CRC).\n\n    if (result == WAVPACK_NO_ERROR) {\n        if (WavpackGetNumSamples64 (wpc) != -1) {\n            if (total_unpacked_samples &lt; WavpackGetNumSamples64 (wpc)) {\n                error_line (&quot;file is missing %llu samples!&quot;,\n                    WavpackGetNumSamples64 (wpc) - total_unpacked_samples);\n                result = WAVPACK_SOFT_ERROR;\n            }\n            else if (total_unpacked_samples &gt; WavpackGetNumSamples64 (wpc)) {\n                error_line (&quot;file has %llu extra samples!&quot;,\n                    total_unpacked_samples - WavpackGetNumSamples64 (wpc));\n                result = WAVPACK_SOFT_ERROR;\n            }\n        }\n\n        if (WavpackGetNumErrors (wpc)) {\n            error_line (&quot;missing data or crc errors detected in %d block(s)!&quot;, WavpackGetNumErrors (wpc));\n            result = WAVPACK_SOFT_ERROR;\n        }\n    }\n\n    WavpackCloseFile (wpc);\n    return result;\n}\n\n// Create a string from the specified configuration that can be used for the &quot;settings&quot;\n// tag. Note that the module globals allow_huge_tags and quantize_bits are also accessed.\n// Room for 256 characters should be plenty.\n\nstatic void make_settings_string (char *settings, WavpackConfig *config)\n{\n    strcpy (settings, &quot;-&quot;);\n\n    // basic settings\n\n    if (config-&gt;flags &amp; CONFIG_FAST_FLAG)\n        strcat (settings, &quot;f&quot;);\n    else if (config-&gt;flags &amp; CONFIG_VERY_HIGH_FLAG)\n        strcat (settings, &quot;hh&quot;);\n    else if (config-&gt;flags &amp; CONFIG_HIGH_FLAG)\n        strcat (settings, &quot;h&quot;);\n\n    if (config-&gt;flags &amp; CONFIG_HYBRID_FLAG) {\n        sprintf (settings + strlen (settings), &quot;b%g&quot;, config-&gt;bitrate);\n\n        if (config-&gt;flags &amp; CONFIG_OPTIMIZE_WVC)\n            strcat (settings, &quot;cc&quot;);\n        else if (config-&gt;flags &amp; CONFIG_CREATE_WVC)\n            strcat (settings, &quot;c&quot;);\n    }\n\n    if (config-&gt;flags &amp; CONFIG_EXTRA_MODE)\n        sprintf (settings + strlen (settings), &quot;x%d&quot;, config-&gt;xmode ? config-&gt;xmode : 1);\n\n    // override settings\n\n    if (config-&gt;flags &amp; CONFIG_JOINT_OVERRIDE) {\n        if (config-&gt;flags &amp; CONFIG_JOINT_STEREO)\n            strcat (settings, &quot;j1&quot;);\n        else\n            strcat (settings, &quot;j0&quot;);\n    }\n\n    if (config-&gt;flags &amp; CONFIG_SHAPE_OVERRIDE)\n        sprintf (settings + strlen (settings), &quot;s%g&quot;, config-&gt;shaping_weight);\n\n    // long options\n\n    if (quantize_bits)\n        sprintf (settings + strlen (settings), &quot; --pre-quantize%s=%d&quot;,\n            quantize_round ? &quot;-round&quot; : &quot;&quot;, quantize_bits);\n\n    if (config-&gt;block_samples)\n        sprintf (settings + strlen (settings), &quot; --blocksize=%d&quot;, config-&gt;block_samples);\n\n    if (config-&gt;flags &amp; CONFIG_DYNAMIC_SHAPING)\n        strcat (settings, &quot; --use-dns&quot;);\n\n    if (config-&gt;flags &amp; CONFIG_CROSS_DECORR)\n        strcat (settings, &quot; --cross-decorr&quot;);\n\n    if (config-&gt;flags &amp; CONFIG_MERGE_BLOCKS)\n        strcat (settings, &quot; --merge-blocks&quot;);\n\n    if (config-&gt;flags &amp; CONFIG_PAIR_UNDEF_CHANS)\n        strcat (settings, &quot; --pair-unassigned-chans&quot;);\n\n    if (allow_huge_tags)\n        strcat (settings, &quot; --allow-huge-tags&quot;);\n}\n\n// Code to load samples. Destination is an array of int32_t data (which is what WavPack uses\n// internally), but the source can have from 1 to 4 bytes per sample. Also, the source data\n// is assumed to be little-endian and signed, except for byte data which is unsigned (these\n// are WAV file defaults). The endian and signedness can be overridden with the qmode flags\n// to support other formats.\n\nstatic void load_little_endian_unsigned_samples (int32_t *dst, void *src, int bps, int count);\nstatic void load_little_endian_signed_samples (int32_t *dst, void *src, int bps, int count);\nstatic void load_big_endian_unsigned_samples (int32_t *dst, void *src, int bps, int count);\nstatic void load_big_endian_signed_samples (int32_t *dst, void *src, int bps, int count);\n\nstatic void load_samples (int32_t *dst, void *src, int qmode, int bps, int count)\n{\n    if (qmode &amp; QMODE_BIG_ENDIAN) {\n        if ((qmode &amp; QMODE_UNSIGNED_WORDS) || (bps == 1 &amp;&amp; !(qmode &amp; QMODE_SIGNED_BYTES)))\n            load_big_endian_unsigned_samples (dst, src, bps, count);\n        else\n            load_big_endian_signed_samples (dst, src, bps, count);\n    }\n    else if ((qmode &amp; QMODE_UNSIGNED_WORDS) || (bps == 1 &amp;&amp; !(qmode &amp; QMODE_SIGNED_BYTES)))\n        load_little_endian_unsigned_samples (dst, src, bps, count);\n    else\n        load_little_endian_signed_samples (dst, src, bps, count);\n}\n\nstatic void load_little_endian_unsigned_samples (int32_t *dst, void *src, int bps, int count)\n{\n    unsigned char *sptr = src;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dst++ = *sptr++ - 0x80;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dst++ = (sptr [0] | ((int32_t) sptr [1] &lt;&lt; 8)) - 0x8000;\n                sptr += 2;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dst++ = (sptr [0] | ((int32_t) sptr [1] &lt;&lt; 8) | ((int32_t) sptr [2] &lt;&lt; 16)) - 0x800000;\n                sptr += 3;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dst++ = (sptr [0] | sptr [1] &lt;&lt; 8 | sptr [2] &lt;&lt; 16 | (uint32_t) sptr [3] &lt;&lt; 24) ^ 0x80000000;\n                sptr += 4;\n            }\n\n            break;\n    }\n}\n\nstatic void load_little_endian_signed_samples (int32_t *dst, void *src, int bps, int count)\n{\n    unsigned char *sptr = src;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dst++ = (signed char) *sptr++;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dst++ = (int16_t)(sptr [0] | sptr [1] &lt;&lt; 8);\n                sptr += 2;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dst++ = (int32_t)((uint32_t)(sptr [0] | sptr [1] &lt;&lt; 8 | sptr [2] &lt;&lt; 16) &lt;&lt; 8) &gt;&gt; 8;\n                sptr += 3;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dst++ = sptr [0] | sptr [1] &lt;&lt; 8 | sptr [2] &lt;&lt; 16 | (uint32_t) sptr [3] &lt;&lt; 24;\n                sptr += 4;\n            }\n\n            break;\n    }\n}\n\nstatic void load_big_endian_unsigned_samples (int32_t *dst, void *src, int bps, int count)\n{\n    unsigned char *sptr = src;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dst++ = *sptr++ - 0x80;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dst++ = (sptr [1] | ((int32_t) sptr [0] &lt;&lt; 8)) - 0x8000;\n                sptr += 2;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dst++ = (sptr [2] | ((int32_t) sptr [1] &lt;&lt; 8) | ((int32_t) sptr [0] &lt;&lt; 16)) - 0x800000;\n                sptr += 3;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dst++ = (sptr [3] | sptr [2] &lt;&lt; 8 | sptr [1] &lt;&lt; 16 | (uint32_t) sptr [0] &lt;&lt; 24) ^ 0x80000000;\n                sptr += 4;\n            }\n\n            break;\n    }\n}\n\nstatic void load_big_endian_signed_samples (int32_t *dst, void *src, int bps, int count)\n{\n    unsigned char *sptr = src;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dst++ = (signed char) *sptr++;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dst++ = (int16_t)(sptr [1] | sptr [0] &lt;&lt; 8);\n                sptr += 2;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dst++ = (int32_t)((uint32_t)(sptr [2] | sptr [1] &lt;&lt; 8 | sptr [0] &lt;&lt; 16) &lt;&lt; 8) &gt;&gt; 8;\n                sptr += 3;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dst++ = sptr [3] | sptr [2] &lt;&lt; 8 | sptr [1] &lt;&lt; 16 | (uint32_t) sptr [0] &lt;&lt; 24;\n                sptr += 4;\n            }\n\n            break;\n    }\n}\n\n// Code to store samples. Source is an array of int32_t data (which is what WavPack uses\n// internally), but the destination can have from 1 to 4 bytes per sample. Also, the destination\n// data is assumed to be little-endian and signed, except for byte data which is unsigned (these\n// are WAV file defaults). The endian and signedness can be overridden with the qmode flags\n// to support other formats.\n\nstatic void *store_little_endian_unsigned_samples (void *dst, int32_t *src, int bps, int count);\nstatic void *store_little_endian_signed_samples (void *dst, int32_t *src, int bps, int count);\nstatic void *store_big_endian_unsigned_samples (void *dst, int32_t *src, int bps, int count);\nstatic void *store_big_endian_signed_samples (void *dst, int32_t *src, int bps, int count);\n\nstatic void *store_samples (void *dst, int32_t *src, int qmode, int bps, int count)\n{\n    if (qmode &amp; QMODE_BIG_ENDIAN) {\n        if ((qmode &amp; QMODE_UNSIGNED_WORDS) || (bps == 1 &amp;&amp; !(qmode &amp; QMODE_SIGNED_BYTES)))\n            return store_big_endian_unsigned_samples (dst, src, bps, count);\n        else\n            return store_big_endian_signed_samples (dst, src, bps, count);\n    }\n    else if ((qmode &amp; QMODE_UNSIGNED_WORDS) || (bps == 1 &amp;&amp; !(qmode &amp; QMODE_SIGNED_BYTES)))\n        return store_little_endian_unsigned_samples (dst, src, bps, count);\n    else\n        return store_little_endian_signed_samples (dst, src, bps, count);\n}\n\nstatic void *store_little_endian_unsigned_samples (void *dst, int32_t *src, int bps, int count)\n{\n    unsigned char *dptr = dst;\n    int32_t temp;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dptr++ = *src++ + 0x80;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++ + 0x8000);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++ + 0x800000);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++ + 0x80000000);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 24);\n            }\n\n            break;\n    }\n\n    return dptr;\n}\n\nstatic void *store_little_endian_signed_samples (void *dst, int32_t *src, int bps, int count)\n{\n    unsigned char *dptr = dst;\n    int32_t temp;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dptr++ = *src++;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dptr++ = (unsigned char) (temp = *src++);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 24);\n            }\n\n            break;\n    }\n\n    return dptr;\n}\n\nstatic void *store_big_endian_unsigned_samples (void *dst, int32_t *src, int bps, int count)\n{\n    unsigned char *dptr = dst;\n    int32_t temp;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dptr++ = *src++ + 0x80;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++ + 0x8000) &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++ + 0x800000) &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++ + 0x80000000) &gt;&gt; 24);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n    }\n\n    return dptr;\n}\n\nstatic void *store_big_endian_signed_samples (void *dst, int32_t *src, int bps, int count)\n{\n    unsigned char *dptr = dst;\n    int32_t temp;\n\n    switch (bps) {\n\n        case 1:\n            while (count--)\n                *dptr++ = *src++;\n\n            break;\n\n        case 2:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++) &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n\n        case 3:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++) &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n\n        case 4:\n            while (count--) {\n                *dptr++ = (unsigned char) ((temp = *src++) &gt;&gt; 24);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 16);\n                *dptr++ = (unsigned char) (temp &gt;&gt; 8);\n                *dptr++ = (unsigned char) temp;\n            }\n\n            break;\n    }\n\n    return dptr;\n}\n\n#if defined(_WIN32)\n\n// Convert the Unicode wide-format string into a UTF-8 string using no more\n// than the specified buffer length. The wide-format string must be NULL\n// terminated and the resulting string will be NULL terminated. The actual\n// number of characters converted (not counting terminator) is returned, which\n// may be less than the number of characters in the wide string if the buffer\n// length is exceeded.\n\nstatic int WideCharToUTF8 (const wchar_t *Wide, unsigned char *pUTF8, int len)\n{\n    const wchar_t *pWide = Wide;\n    int outndx = 0;\n\n    while (*pWide) {\n        if (*pWide &lt; 0x80 &amp;&amp; outndx + 1 &lt; len)\n            pUTF8 [outndx++] = (unsigned char) *pWide++;\n        else if (*pWide &lt; 0x800 &amp;&amp; outndx + 2 &lt; len) {\n            pUTF8 [outndx++] = (unsigned char) (0xc0 | ((*pWide &gt;&gt; 6) &amp; 0x1f));\n            pUTF8 [outndx++] = (unsigned char) (0x80 | (*pWide++ &amp; 0x3f));\n        }\n        else if (outndx + 3 &lt; len) {\n            pUTF8 [outndx++] = (unsigned char) (0xe0 | ((*pWide &gt;&gt; 12) &amp; 0xf));\n            pUTF8 [outndx++] = (unsigned char) (0x80 | ((*pWide &gt;&gt; 6) &amp; 0x3f));\n            pUTF8 [outndx++] = (unsigned char) (0x80 | (*pWide++ &amp; 0x3f));\n        }\n        else\n            break;\n    }\n\n    pUTF8 [outndx] = 0;\n    return (int)(pWide - Wide);\n}\n\n// Convert a text string into its Unicode UTF-8 format equivalent. The\n// conversion is done in-place so the maximum length of the string buffer must\n// be specified because the string may become longer or shorter. If the\n// resulting string will not fit in the specified buffer size then it is\n// truncated.\n\nstatic void TextToUTF8 (void *string, int len)\n{\n    unsigned char *inp = string;\n\n    // simple case: test for UTF8 BOM and if so, simply delete the BOM\n\n    if (len &gt; 3 &amp;&amp; inp [0] == 0xEF &amp;&amp; inp [1] == 0xBB &amp;&amp; inp [2] == 0xBF) {\n        memmove (inp, inp + 3, len - 3);\n        inp [len - 3] = 0;\n    }\n    else if (* (wchar_t *) string == 0xFEFF) {\n        wchar_t *temp = _wcsdup (string);\n\n        WideCharToUTF8 (temp + 1, (unsigned char *) string, len);\n        free (temp);\n    }\n    else {\n        int max_chars = (int) strlen (string);\n        wchar_t *temp = (wchar_t *) malloc ((max_chars + 1) * 2);\n\n        MultiByteToWideChar (CP_ACP, 0, string, -1, temp, max_chars + 1);\n        WideCharToUTF8 (temp, (unsigned char *) string, len);\n        free (temp);\n    }\n}\n\n#else\n\nstatic void TextToUTF8 (void *string, int len)\n{\n    char *temp = malloc (len);\n    char *outp = temp;\n    char *inp = string;\n    size_t insize = 0;\n    size_t outsize = len - 1;\n    int err = 0;\n    char *old_locale;\n    iconv_t converter;\n\n    // simple case: test for UTF8 BOM and if so, simply delete the BOM and return\n\n    if (len &gt; 3 &amp;&amp; (unsigned char) inp [0] == 0xEF &amp;&amp; (unsigned char) inp [1] == 0xBB &amp;&amp;\n        (unsigned char) inp [2] == 0xBF) {\n            memmove (inp, inp + 3, len - 3);\n            inp [len - 3] = 0;\n            return;\n    }\n\n    memset(temp, 0, len);\n    old_locale = setlocale (LC_CTYPE, &quot;&quot;);\n\n    if ((unsigned char) inp [0] == 0xFF &amp;&amp; (unsigned char) inp [1] == 0xFE) {\n        uint16_t *utf16p = (uint16_t *) (inp += 2);\n\n        while (*utf16p++)\n            insize += 2;\n\n        converter = iconv_open (&quot;UTF-8&quot;, &quot;UTF-16LE&quot;);\n    }\n    else {\n        insize = strlen (string);\n        converter = iconv_open (&quot;UTF-8&quot;, &quot;&quot;);\n    }\n\n    if (converter != (iconv_t) -1) {\n        err = iconv (converter, &amp;inp, &amp;insize, &amp;outp, &amp;outsize);\n        iconv_close (converter);\n    }\n    else\n        err = -1;\n\n    setlocale (LC_CTYPE, old_locale);\n\n    if (err == -1) {\n        free(temp);\n        return;\n    }\n\n    memmove (string, temp, len);\n    free (temp);\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n// This function displays the progress status on the title bar of the DOS   //\n// window that WavPack is running in. The &quot;file_progress&quot; argument is for   //\n// the current file only and ranges from 0 - 1; this function takes into    //\n// account the total number of files to generate a batch progress number.   //\n//////////////////////////////////////////////////////////////////////////////\n\nstatic void display_progress (double file_progress)\n{\n    char title [40];\n\n    if (set_console_title) {\n        file_progress = (file_index + file_progress) / num_files;\n        sprintf (title, &quot;%d%% (WavPack)&quot;, (int) ((file_progress * 100.0) + 0.5));\n        DoSetConsoleTitle (title);\n    }\n}\n"}, "/project/WavPack/src/open_filename.c": {"id": "/project/WavPack/src/open_filename.c", "filePath": "/project/WavPack/src/open_filename.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2024 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// open_filename.c\n\n// This module provides all the code required to open an existing WavPack\n// file, by filename, for reading. It does not contain the actual code to\n// unpack audio data and this was done so that programs that just want to\n// query WavPack files for information (like, for example, taggers) don&#x27;t\n// need to link in a lot of unnecessary code.\n//\n// To allow opening files by filename, this code provides an interface\n// between the reader callback mechanism that WavPack uses internally and\n// the standard fstream C library. Note that in applications that do not\n// require opening files by filename, this module can be omitted (which\n// might make building easier).\n//\n// For Unicode support on Windows, a flag has been added (OPEN_FILE_UTF8)\n// that forces the filename string to be assumed UTF-8 and converted to\n// a widechar string suitable for _wfopen(). Without this flag we revert\n// to the previous behavior of simply calling fopen() and hoping that the\n// local character set works. This is ignored on non-Windows platforms\n// (which is okay because they are probably UTF-8 anyway).\n\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\n#include &lt;windows.h&gt;\n#include &lt;io.h&gt;\n#endif\n\n#if defined(__OS2__) &amp;&amp; defined(__WATCOMC__)\n#define INCL_DOSMODULEMGR\n#define INCL_LONGLONG\n#define INCL_DOSFILEMGR\n#include &lt;os2.h&gt;\n#endif\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &quot;wavpack_local.h&quot;\n\n#include &lt;fcntl.h&gt;\n#include &lt;sys/stat.h&gt;\n\n#if (defined(__GNUC__) || defined(__sun)) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__WATCOMC__)\n#include &lt;unistd.h&gt;\n#endif\n\n#ifdef __OS2__\n#include &lt;io.h&gt;\n#endif\n\n#ifdef _WIN32\nstatic FILE *fopen_utf8 (const char *filename_utf8, const char *mode_utf8);\n#if !defined(S_ISREG) &amp;&amp; defined(S_IFMT) &amp;&amp; defined(S_IFREG)\n#define S_ISREG(m) (((m) &amp; S_IFMT) == S_IFREG)\n#endif\n#endif\n\n#ifdef HAVE_FSEEKO\n#define fseek fseeko\n#define ftell ftello\n#endif\n\n#ifdef __MINGW32__              // mingw32&#x27;s _ftelli64() and _fseeki64() are defective\n#define _ftelli64 ftello64\n#define _fseeki64 fseeko64\n#endif\n\nstatic int32_t read_bytes (void *id, void *data, int32_t bcount)\n{\n    return (int32_t) fread (data, 1, bcount, (FILE*) id);\n}\n\nstatic int64_t get_pos (void *id)\n{\n#if defined(_WIN32) || defined(__WATCOMC__)\n    return _ftelli64 ((FILE*) id);\n#else\n    return ftell ((FILE*) id);\n#endif\n}\n\nstatic int set_pos_abs (void *id, int64_t pos)\n{\n#if defined(_WIN32) || defined(__WATCOMC__)\n    return _fseeki64 (id, pos, SEEK_SET);\n#else\n    return fseek (id, pos, SEEK_SET);\n#endif\n}\n\nstatic int set_pos_rel (void *id, int64_t delta, int mode)\n{\n#if defined(_WIN32) || defined(__WATCOMC__)\n    return _fseeki64 (id, delta, mode);\n#else\n    return fseek (id, delta, mode);\n#endif\n}\n\nstatic int push_back_byte (void *id, int c)\n{\n    return ungetc (c, id);\n}\n\n#if defined(_WIN32) || defined(__WATCOMC__)\n\nstatic int can_seek (void *id)\n{\n    struct _stati64 statbuf;\n    return id &amp;&amp; !_fstati64 (_fileno ((FILE *)id), &amp;statbuf) &amp;&amp; S_ISREG(statbuf.st_mode);\n}\n\nstatic int64_t get_length (void *id)\n{\n    FILE *file = id;\n    struct _stati64 statbuf;\n\n    if (!file || _fstati64 (_fileno (file), &amp;statbuf) || !S_ISREG(statbuf.st_mode))\n        return 0;\n\n    return statbuf.st_size;\n}\n\n#else\n\nstatic int can_seek (void *id)\n{\n    FILE *file = id;\n    struct stat statbuf;\n\n    return file &amp;&amp; !fstat (fileno (file), &amp;statbuf) &amp;&amp; S_ISREG(statbuf.st_mode);\n}\n\nstatic int64_t get_length (void *id)\n{\n    FILE *file = id;\n    struct stat statbuf;\n\n    if (!file || fstat (fileno (file), &amp;statbuf) || !S_ISREG(statbuf.st_mode))\n        return 0;\n\n    return statbuf.st_size;\n}\n\n#endif\n\nstatic int32_t write_bytes (void *id, void *data, int32_t bcount)\n{\n    return (int32_t) fwrite (data, 1, bcount, (FILE*) id);\n}\n\n#if defined(__WATCOMC__) &amp;&amp; defined(_WIN32) /* no _chsize_s() in watcom... */\n\nstatic int truncate_here (void *id)\n{\n    int fd = _fileno ((FILE *)id);\n    HANDLE handle = (HANDLE) _get_osfhandle (fd);\n    return (SetEndOfFile(handle) != 0) ? 0 : -1;\n}\n\n#elif defined(__WATCOMC__) &amp;&amp; defined(__OS2__)\n\nstatic int chk_DosSetFileSizeL = 0;\n#define ORD_DosSetFileSizeL  989\ntypedef APIRET (APIENTRY *DosSetFileSizeL_t)(HFILE,LONGLONG);\nstatic DosSetFileSizeL_t pDosSetFileSizeL = NULL;\n\nstatic void init_os2file64api (void)\n{\n    HMODULE handle;\n    if (DosQueryModuleHandle(&quot;DOSCALLS&quot;, &amp;handle) == 0) {\n        if (DosQueryProcAddr(handle, ORD_DosSetFileSizeL, NULL, (PFN *)&amp;pDosSetFileSizeL) != 0) {\n            pDosSetFileSizeL = NULL;\n        }\n    }\n    chk_DosSetFileSizeL = 1;\n}\n\nstatic int truncate_here (void *id)\n{\n    int fd = fileno ((FILE *)id);\n    HFILE handle = (HFILE) _get_osfhandle (fd);\n    int64_t pos = _lseeki64 (fd, 0, SEEK_CUR);\n    if (!chk_DosSetFileSizeL) {\n        init_os2file64api();\n    }\n    if (pDosSetFileSizeL) {\n        return (pDosSetFileSizeL(handle, pos) == 0) ? 0 : -1;\n    }\n    return (DosSetFileSize(handle,(ULONG)pos) == 0) ? 0 : -1;\n}\n\n#elif defined(_WIN32)\n\nstatic int truncate_here (void *id)\n{\n    FILE *file = id;\n    int64_t curr_pos = _ftelli64 (file);\n\n    return _chsize_s (_fileno (file), curr_pos);\n}\n\n#else\n\nstatic int truncate_here (void *id)\n{\n    FILE *file = id;\n    off_t curr_pos = ftell (file);\n\n    return ftruncate (fileno (file), curr_pos);\n}\n\n#endif\n\nstatic int close_stream (void *id)\n{\n    return fclose ((FILE*) id);\n}\n\n//  int32_t (*read_bytes)(void *id, void *data, int32_t bcount);\n//  int32_t (*write_bytes)(void *id, void *data, int32_t bcount);\n//  int64_t (*get_pos)(void *id);                               // new signature for large files\n//  int (*set_pos_abs)(void *id, int64_t pos);                  // new signature for large files\n//  int (*set_pos_rel)(void *id, int64_t delta, int mode);      // new signature for large files\n//  int (*push_back_byte)(void *id, int c);\n//  int64_t (*get_length)(void *id);                            // new signature for large files\n//  int (*can_seek)(void *id);\n//  int (*truncate_here)(void *id);                             // new function to truncate file at current position\n//  int (*close)(void *id);                                     // new function to close file\n\nstatic WavpackStreamReader64 freader = {\n    read_bytes, write_bytes, get_pos, set_pos_abs, set_pos_rel,\n    push_back_byte, get_length, can_seek, truncate_here, close_stream\n};\n\n// This function attempts to open the specified WavPack file for reading. If\n// this fails for any reason then an appropriate message is copied to &quot;error&quot;\n// (which must accept 80 characters) and NULL is returned, otherwise a\n// pointer to a WavpackContext structure is returned (which is used to call\n// all other functions in this module). A filename beginning with &quot;-&quot; is\n// assumed to be stdin. The &quot;flags&quot; argument has the following bit mask\n// values to specify details of the open operation:\n\n// OPEN_WVC:  attempt to open/read &quot;correction&quot; file\n// OPEN_TAGS:  attempt to read ID3v1 / APEv2 tags (requires seekable file)\n// OPEN_WRAPPER:  make audio wrapper available (i.e. RIFF) to caller\n// OPEN_2CH_MAX:  open only first stream of multichannel file (usually L/R)\n// OPEN_NORMALIZE:  normalize floating point data to +/- 1.0 (w/ offset exp)\n// OPEN_STREAMING:  blindly unpacks blocks w/o regard to header file position\n// OPEN_EDIT_TAGS:  allow editing of tags (file must be writable)\n// OPEN_FILE_UTF8:  assume infilename is UTF-8 encoded (Windows only)\n\n// Version 4.2 of the WavPack library adds the OPEN_STREAMING flag. This is\n// essentially a &quot;raw&quot; mode where the library will simply decode any blocks\n// fed it through the reader callback, regardless of where those blocks came\n// from in a stream. The only requirement is that complete WavPack blocks are\n// fed to the decoder (and this may require multiple blocks in multichannel\n// mode) and that complete blocks are decoded (even if all samples are not\n// actually required). All the blocks must contain the same number of channels\n// and bit resolution, and the correction data must be either present or not.\n// All other parameters may change from block to block (like lossy/lossless).\n// Obviously, in this mode any seeking must be performed by the application\n// (and again, decoding must start at the beginning of the block containing\n// the seek sample).\n\nWavpackContext *WavpackOpenFileInput (const char *infilename, char *error, int flags, int norm_offset)\n{\n    char *file_mode = (flags &amp; OPEN_EDIT_TAGS) ? &quot;r+b&quot; : &quot;rb&quot;;\n    FILE *(*fopen_func)(const char *, const char *) = fopen;\n    FILE *wv_id, *wvc_id;\n\n#ifdef _WIN32\n    if (flags &amp; OPEN_FILE_UTF8)\n        fopen_func = fopen_utf8;\n#endif\n\n    if (*infilename == &#x27;-&#x27;) {\n        wv_id = stdin;\n#if defined(_WIN32)\n        _setmode (_fileno (stdin), O_BINARY);\n#endif\n#if defined(__OS2__)\n        setmode (fileno (stdin), O_BINARY);\n#endif\n    }\n    else if ((wv_id = fopen_func (infilename, file_mode)) == NULL) {\n        if (error) strcpy (error, (flags &amp; OPEN_EDIT_TAGS) ? &quot;can&#x27;t open file for editing&quot; : &quot;can&#x27;t open file&quot;);\n        return NULL;\n    }\n\n    if (*infilename != &#x27;-&#x27; &amp;&amp; (flags &amp; OPEN_WVC)) {\n        char *in2filename = malloc (strlen (infilename) + 10);\n\n        strcpy (in2filename, infilename);\n        strcat (in2filename, &quot;c&quot;);\n        wvc_id = fopen_func (in2filename, &quot;rb&quot;);\n        free (in2filename);\n    }\n    else\n        wvc_id = NULL;\n\n    return WavpackOpenFileInputEx64 (&amp;freader, wv_id, wvc_id, error, flags, norm_offset);\n}\n\n#ifdef _WIN32\n\n// The following code Copyright (c) 2004-2012 LoRd_MuldeR &lt;mulder2@gmx.de&gt;\n// (see cli/win32_unicode_support.c for full license)\n\nstatic wchar_t *utf8_to_utf16(const char *input)\n{\n\twchar_t *Buffer;\n\tint BuffSize = 0, Result = 0;\n\n\tBuffSize = MultiByteToWideChar(CP_UTF8, 0, input, -1, NULL, 0);\n\tBuffer = (wchar_t*) malloc(sizeof(wchar_t) * BuffSize);\n\tif(Buffer)\n\t{\n\t\tResult = MultiByteToWideChar(CP_UTF8, 0, input, -1, Buffer, BuffSize);\n\t}\n\n\treturn ((Result &gt; 0) &amp;&amp; (Result &lt;= BuffSize)) ? Buffer : NULL;\n}\n\n\nstatic FILE *fopen_utf8(const char *filename_utf8, const char *mode_utf8)\n{\n\tFILE *ret = NULL;\n\twchar_t *filename_utf16 = utf8_to_utf16(filename_utf8);\n\twchar_t *mode_utf16 = utf8_to_utf16(mode_utf8);\n\n\tif(filename_utf16 &amp;&amp; mode_utf16)\n\t{\n\t\tret = _wfopen(filename_utf16, mode_utf16);\n\t}\n\n\tif(filename_utf16) free(filename_utf16);\n\tif(mode_utf16) free(mode_utf16);\n\n\treturn ret;\n}\n\n#endif\n\n\n"}, "/project/WavPack/src/open_utils.c": {"id": "/project/WavPack/src/open_utils.c", "filePath": "/project/WavPack/src/open_utils.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2024 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// open_utils.c\n\n// This module provides all the code required to open an existing WavPack file\n// for reading by using a reader callback mechanism (NOT a filename). This\n// includes the code required to find and parse WavPack blocks, process any\n// included metadata, and queue up the bitstreams containing the encoded audio\n// data. It does not the actual code to unpack audio data and this was done so\n// that programs that just want to query WavPack files for information (like,\n// for example, taggers) don&#x27;t need to link in a lot of unnecessary code.\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\n#include &quot;wavpack_local.h&quot;\n\n// This function is identical to WavpackOpenFileInput() except that instead\n// of providing a filename to open, the caller provides a pointer to a set of\n// reader callbacks and instances of up to two streams. The first of these\n// streams is required and contains the regular WavPack data stream; the second\n// contains the &quot;correction&quot; file if desired. Unlike the standard open\n// function which handles the correction file transparently, in this case it\n// is the responsibility of the caller to be aware of correction files.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper);\n\nWavpackContext *WavpackOpenFileInputEx64 (WavpackStreamReader64 *reader, void *wv_id, void *wvc_id, char *error, int flags, int norm_offset)\n{\n    WavpackContext *wpc = (WavpackContext *)malloc (sizeof (WavpackContext));\n    WavpackStream *wps;\n    int num_blocks = 0;\n    unsigned char first_byte;\n    uint32_t bcount;\n\n    if (!wpc) {\n        if (error) strcpy (error, &quot;can&#x27;t allocate memory&quot;);\n        return NULL;\n    }\n\n    CLEAR (*wpc);\n    wpc-&gt;wv_in = wv_id;\n    wpc-&gt;wvc_in = wvc_id;\n    wpc-&gt;reader = reader;\n    wpc-&gt;total_samples = -1;\n    wpc-&gt;norm_offset = norm_offset;\n    wpc-&gt;max_streams = OLD_MAX_STREAMS;     // use this until overwritten with actual number\n    wpc-&gt;open_flags = flags;\n\n    wpc-&gt;filelen = wpc-&gt;reader-&gt;get_length (wpc-&gt;wv_in);\n\n#ifndef NO_TAGS\n    if ((flags &amp; (OPEN_TAGS | OPEN_EDIT_TAGS)) &amp;&amp; wpc-&gt;reader-&gt;can_seek (wpc-&gt;wv_in)) {\n        load_tag (wpc);\n        wpc-&gt;reader-&gt;set_pos_abs (wpc-&gt;wv_in, 0);\n\n        if ((flags &amp; OPEN_EDIT_TAGS) &amp;&amp; !editable_tag (&amp;wpc-&gt;m_tag)) {\n            if (error) strcpy (error, &quot;can&#x27;t edit tags located at the beginning of files!&quot;);\n            return WavpackCloseFile (wpc);\n        }\n    }\n#endif\n\n    if (wpc-&gt;reader-&gt;read_bytes (wpc-&gt;wv_in, &amp;first_byte, 1) != 1) {\n        if (error) strcpy (error, &quot;can&#x27;t read all of WavPack file!&quot;);\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc-&gt;reader-&gt;push_back_byte (wpc-&gt;wv_in, first_byte);\n\n    if (first_byte == &#x27;R&#x27;) {\n#ifdef ENABLE_LEGACY\n        return open_file3 (wpc, error);\n#else\n        if (error) strcpy (error, &quot;this legacy WavPack file is deprecated, use version 4.80.0 to transcode&quot;);\n        return WavpackCloseFile (wpc);\n#endif\n    }\n\n    wpc-&gt;streams = (WavpackStream **)(malloc ((wpc-&gt;num_streams = 1) * sizeof (wpc-&gt;streams [0])));\n    if (!wpc-&gt;streams) {\n        if (error) strcpy (error, &quot;can&#x27;t allocate memory&quot;);\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc-&gt;streams [0] = wps = (WavpackStream *)calloc (1, sizeof (WavpackStream));\n    if (!wps) {\n        if (error) strcpy (error, &quot;can&#x27;t allocate memory&quot;);\n        return WavpackCloseFile (wpc);\n    }\n\n    wps-&gt;wpc = wpc;\n\n    while (!wps-&gt;wphdr.block_samples) {\n\n        wpc-&gt;filepos = wpc-&gt;reader-&gt;get_pos (wpc-&gt;wv_in);\n        bcount = read_next_header (wpc-&gt;reader, wpc-&gt;wv_in, &amp;wps-&gt;wphdr);\n\n        if (bcount == (uint32_t) -1 ||\n            (!wps-&gt;wphdr.block_samples &amp;&amp; num_blocks++ &gt; 16)) {\n                if (error) strcpy (error, &quot;not compatible with this version of WavPack file!&quot;);\n                return WavpackCloseFile (wpc);\n        }\n\n        wpc-&gt;filepos += bcount;\n        wps-&gt;blockbuff = (unsigned char *)malloc (wps-&gt;wphdr.ckSize + 8);\n        if (!wps-&gt;blockbuff) {\n            if (error) strcpy (error, &quot;can&#x27;t allocate memory&quot;);\n            return WavpackCloseFile (wpc);\n        }\n        memcpy (wps-&gt;blockbuff, &amp;wps-&gt;wphdr, 32);\n\n        if (wpc-&gt;reader-&gt;read_bytes (wpc-&gt;wv_in, wps-&gt;blockbuff + 32, wps-&gt;wphdr.ckSize - 24) != wps-&gt;wphdr.ckSize - 24) {\n            if (error) strcpy (error, &quot;can&#x27;t read all of WavPack file!&quot;);\n            return WavpackCloseFile (wpc);\n        }\n\n        // if block does not verify, flag error, free buffer, and continue\n        if (!WavpackVerifySingleBlock (wps-&gt;blockbuff, !(flags &amp; OPEN_NO_CHECKSUM))) {\n            wps-&gt;wphdr.block_samples = 0;\n            free (wps-&gt;blockbuff);\n            wps-&gt;blockbuff = NULL;\n            wpc-&gt;crc_errors++;\n            continue;\n        }\n\n        wps-&gt;init_done = FALSE;\n\n        if (wps-&gt;wphdr.block_samples) {\n            if (flags &amp; OPEN_STREAMING)\n                SET_BLOCK_INDEX (wps-&gt;wphdr, 0);\n            else if (wpc-&gt;total_samples == -1) {\n                if (GET_BLOCK_INDEX (wps-&gt;wphdr) || GET_TOTAL_SAMPLES (wps-&gt;wphdr) == -1) {\n                    wpc-&gt;initial_index = GET_BLOCK_INDEX (wps-&gt;wphdr);\n                    SET_BLOCK_INDEX (wps-&gt;wphdr, 0);\n\n                    if (wpc-&gt;reader-&gt;can_seek (wpc-&gt;wv_in)) {\n                        int64_t final_index = -1;\n\n                        seek_eof_information (wpc, &amp;final_index, FALSE);\n\n                        if (final_index != -1)\n                            wpc-&gt;total_samples = final_index - wpc-&gt;initial_index;\n                    }\n                }\n                else\n                    wpc-&gt;total_samples = GET_TOTAL_SAMPLES (wps-&gt;wphdr);\n            }\n        }\n        else if (wpc-&gt;total_samples == -1 &amp;&amp; !GET_BLOCK_INDEX (wps-&gt;wphdr) &amp;&amp; GET_TOTAL_SAMPLES (wps-&gt;wphdr))\n            wpc-&gt;total_samples = GET_TOTAL_SAMPLES (wps-&gt;wphdr);\n\n        if (wpc-&gt;wvc_in &amp;&amp; wps-&gt;wphdr.block_samples &amp;&amp; (wps-&gt;wphdr.flags &amp; HYBRID_FLAG)) {\n            unsigned char ch;\n\n            if (wpc-&gt;reader-&gt;read_bytes (wpc-&gt;wvc_in, &amp;ch, 1) == 1) {\n                wpc-&gt;reader-&gt;push_back_byte (wpc-&gt;wvc_in, ch);\n                wpc-&gt;file2len = wpc-&gt;reader-&gt;get_length (wpc-&gt;wvc_in);\n                wpc-&gt;wvc_flag = TRUE;\n            }\n        }\n\n        if (wpc-&gt;wvc_flag &amp;&amp; !read_wvc_block (wpc, 0)) {\n            if (error) strcpy (error, &quot;not compatible with this version of correction file!&quot;);\n            return WavpackCloseFile (wpc);\n        }\n\n        if (!wps-&gt;init_done &amp;&amp; !unpack_init (wpc, 0)) {\n            if (error) strcpy (error, wpc-&gt;error_message [0] ? wpc-&gt;error_message :\n                &quot;not compatible with this version of WavPack file!&quot;);\n\n            return WavpackCloseFile (wpc);\n        }\n\n        if (!wps-&gt;wphdr.block_samples) {    // free blockbuff if we&#x27;re going to loop again\n            free (wps-&gt;blockbuff);\n            wps-&gt;blockbuff = NULL;\n        }\n\n        wps-&gt;init_done = TRUE;\n    }\n\n    wpc-&gt;config.flags &amp;= ~0xff;\n    wpc-&gt;config.flags |= wps-&gt;wphdr.flags &amp; 0xff;\n\n    if (!wpc-&gt;config.num_channels) {\n        wpc-&gt;config.num_channels = (wps-&gt;wphdr.flags &amp; MONO_FLAG) ? 1 : 2;\n        wpc-&gt;config.channel_mask = 0x5 - wpc-&gt;config.num_channels;\n    }\n\n    if ((flags &amp; OPEN_2CH_MAX) &amp;&amp; !(wps-&gt;wphdr.flags &amp; FINAL_BLOCK))\n        wpc-&gt;reduced_channels = (wps-&gt;wphdr.flags &amp; MONO_FLAG) ? 1 : 2;\n\n    if (wps-&gt;wphdr.flags &amp; DSD_FLAG) {\n#ifdef ENABLE_DSD\n        if (flags &amp; OPEN_DSD_NATIVE) {\n            wpc-&gt;config.bytes_per_sample = 1;\n            wpc-&gt;config.bits_per_sample = 8;\n        }\n        else if (flags &amp; OPEN_DSD_AS_PCM) {\n            wpc-&gt;decimation_context = decimate_dsd_init (wpc-&gt;reduced_channels ?\n                wpc-&gt;reduced_channels : wpc-&gt;config.num_channels);\n\n            wpc-&gt;config.bytes_per_sample = 3;\n            wpc-&gt;config.bits_per_sample = 24;\n        }\n        else {\n            if (error) strcpy (error, &quot;not configured to handle DSD WavPack files!&quot;);\n            return WavpackCloseFile (wpc);\n        }\n#else\n        if (error) strcpy (error, &quot;not configured to handle DSD WavPack files!&quot;);\n        return WavpackCloseFile (wpc);\n#endif\n    }\n    else {\n        wpc-&gt;config.bytes_per_sample = (wps-&gt;wphdr.flags &amp; BYTES_STORED) + 1;\n        wpc-&gt;config.float_norm_exp = wps-&gt;float_norm_exp;\n\n        wpc-&gt;config.bits_per_sample = (wpc-&gt;config.bytes_per_sample * 8) -\n            ((wps-&gt;wphdr.flags &amp; SHIFT_MASK) &gt;&gt; SHIFT_LSB);\n    }\n\n    if (!wpc-&gt;config.sample_rate) {\n        if (!wps-&gt;wphdr.block_samples || (wps-&gt;wphdr.flags &amp; SRATE_MASK) == SRATE_MASK)\n            wpc-&gt;config.sample_rate = 44100;\n        else\n            wpc-&gt;config.sample_rate = sample_rates [(wps-&gt;wphdr.flags &amp; SRATE_MASK) &gt;&gt; SRATE_LSB];\n    }\n\n#ifdef ENABLE_THREADS\n    if (!wpc-&gt;reduced_channels &amp;&amp; (wpc-&gt;open_flags &amp; OPEN_THREADS_MASK)) {\n        wpc-&gt;num_workers = ((wpc-&gt;open_flags &amp; OPEN_THREADS_MASK) &gt;&gt; OPEN_THREADS_SHFT) &amp; 0xf;\n\n        // for multichannel files we can limit the number of workers\n        // because we only do spatial multithreading (not temporal)\n\n        if (!(wps-&gt;wphdr.flags &amp; FINAL_BLOCK)) {\n            if (wpc-&gt;num_workers &gt; wpc-&gt;max_streams - 1)\n                wpc-&gt;num_workers = wpc-&gt;max_streams - 1;\n\n            if (wpc-&gt;num_workers &gt; wpc-&gt;config.num_channels - 1)\n                wpc-&gt;num_workers = wpc-&gt;config.num_channels - 1;\n        }\n    }\n#endif\n\n    return wpc;\n}\n\n// This function returns the major version number of the WavPack program\n// (or library) that created the open file. Currently, this can be 1 to 5.\n// Minor versions are not recorded in WavPack files.\n\nint WavpackGetVersion (WavpackContext *wpc)\n{\n    if (wpc) {\n#ifdef ENABLE_LEGACY\n        if (wpc-&gt;stream3)\n            return get_version3 (wpc);\n#endif\n        return wpc-&gt;version_five ? 5 : 4;\n    }\n\n    return 0;\n}\n\n// Return the file format specified in the call to WavpackSetFileInformation()\n// when the file was created. For all files created prior to WavPack 5.0 this\n// will 0 (WP_FORMAT_WAV).\n\nunsigned char WavpackGetFileFormat (WavpackContext *wpc)\n{\n    return wpc-&gt;file_format;\n}\n\n// Return a string representing the recommended file extension for the open\n// WavPack file. For all files created prior to WavPack 5.0 this will be &quot;wav&quot;,\n// even for raw files with no RIFF into. This string is specified in the\n// call to WavpackSetFileInformation() when the file was created.\n\nchar *WavpackGetFileExtension (WavpackContext *wpc)\n{\n    if (wpc &amp;&amp; wpc-&gt;file_extension [0])\n        return wpc-&gt;file_extension;\n    else\n        return &quot;wav&quot;;\n}\n\n// This function initializes everything required to unpack a WavPack block\n// and must be called before unpack_samples() is called to obtain audio data.\n// It is assumed that the WavpackHeader has been read into the wps-&gt;wphdr\n// (in the current WavpackStream) and that the entire block has been read at\n// wps-&gt;blockbuff. If a correction file is available (wpc-&gt;wvc_flag = TRUE)\n// then the corresponding correction block must be read into wps-&gt;block2buff\n// and its WavpackHeader has overwritten the header at wps-&gt;wphdr. This is\n// where all the metadata blocks are scanned including those that contain\n// bitstream data.\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr);\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd, int stream);\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end);\n\nint unpack_init (WavpackContext *wpc, int stream)\n{\n    WavpackStream *wps = wpc-&gt;streams [stream];\n    unsigned char *blockptr, *block2ptr;\n    WavpackMetadata wpmd;\n\n    wps-&gt;num_terms = 0;\n    wps-&gt;mute_error = FALSE;\n    wps-&gt;crc = wps-&gt;crc_x = 0xffffffff;\n    wps-&gt;dsd.ready = 0;\n    CLEAR (wps-&gt;wvbits);\n    CLEAR (wps-&gt;wvcbits);\n    CLEAR (wps-&gt;wvxbits);\n    CLEARA(wps-&gt;decorr_passes);\n    CLEAR (wps-&gt;dc);\n    CLEAR (wps-&gt;w);\n\n    if (!(wps-&gt;wphdr.flags &amp; MONO_FLAG) &amp;&amp; wpc-&gt;config.num_channels &amp;&amp; wps-&gt;wphdr.block_samples &amp;&amp;\n        (wpc-&gt;reduced_channels == 1 || wpc-&gt;config.num_channels == 1)) {\n            wps-&gt;mute_error = TRUE;\n            return FALSE;\n    }\n\n    if ((wps-&gt;wphdr.flags &amp; UNKNOWN_FLAGS) || (wps-&gt;wphdr.flags &amp; MONO_DATA) == MONO_DATA) {\n        wps-&gt;mute_error = TRUE;\n        return FALSE;\n    }\n\n    blockptr = wps-&gt;blockbuff + sizeof (WavpackHeader);\n\n    while (read_metadata_buff (&amp;wpmd, wps-&gt;blockbuff, &amp;blockptr))\n        if (!process_metadata (wpc, &amp;wpmd, stream)) {\n            wps-&gt;mute_error = TRUE;\n            return FALSE;\n        }\n\n    if (wps-&gt;wphdr.block_samples &amp;&amp; wpc-&gt;wvc_flag &amp;&amp; wps-&gt;block2buff) {\n        block2ptr = wps-&gt;block2buff + sizeof (WavpackHeader);\n\n        while (read_metadata_buff (&amp;wpmd, wps-&gt;block2buff, &amp;block2ptr))\n            if (!process_metadata (wpc, &amp;wpmd, stream)) {\n                wps-&gt;mute_error = TRUE;\n                return FALSE;\n            }\n    }\n\n    if (wps-&gt;wphdr.block_samples &amp;&amp; ((wps-&gt;wphdr.flags &amp; DSD_FLAG) ? !wps-&gt;dsd.ready : !bs_is_open (&amp;wps-&gt;wvbits))) {\n        if (bs_is_open (&amp;wps-&gt;wvcbits))\n            strcpy (wpc-&gt;error_message, &quot;can&#x27;t unpack correction files alone!&quot;);\n\n        wps-&gt;mute_error = TRUE;\n        return FALSE;\n    }\n\n    if (wps-&gt;wphdr.block_samples &amp;&amp; !bs_is_open (&amp;wps-&gt;wvxbits)) {\n        if ((wps-&gt;wphdr.flags &amp; INT32_DATA) &amp;&amp; wps-&gt;int32_sent_bits)\n            wpc-&gt;lossy_blocks = TRUE;\n\n        if ((wps-&gt;wphdr.flags &amp; FLOAT_DATA) &amp;&amp;\n            wps-&gt;float_flags &amp; (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME))\n                wpc-&gt;lossy_blocks = TRUE;\n    }\n\n    if (wps-&gt;wphdr.block_samples)\n        wps-&gt;sample_index = GET_BLOCK_INDEX (wps-&gt;wphdr);\n\n    return TRUE;\n}\n\n//////////////////////////////// metadata handlers ///////////////////////////////\n\n// These functions handle specific metadata types and are called directly\n// during WavPack block parsing by process_metadata() at the bottom.\n\n// This function initializes the main bitstream for audio samples, which must\n// be in the &quot;wv&quot; file.\n\nstatic int init_wv_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd-&gt;byte_length || (wpmd-&gt;byte_length &amp; 1))\n        return FALSE;\n\n    bs_open_read (&amp;wps-&gt;wvbits, wpmd-&gt;data, (unsigned char *) wpmd-&gt;data + wpmd-&gt;byte_length);\n    return TRUE;\n}\n\n// This function initializes the &quot;correction&quot; bitstream for audio samples,\n// which currently must be in the &quot;wvc&quot; file.\n\nstatic int init_wvc_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd-&gt;byte_length || (wpmd-&gt;byte_length &amp; 1))\n        return FALSE;\n\n    bs_open_read (&amp;wps-&gt;wvcbits, wpmd-&gt;data, (unsigned char *) wpmd-&gt;data + wpmd-&gt;byte_length);\n    return TRUE;\n}\n\n// This function initializes the &quot;extra&quot; bitstream for audio samples which\n// contains the information required to losslessly decompress 32-bit float data\n// or integer data that exceeds 24 bits. This bitstream is in the &quot;wv&quot; file\n// for pure lossless data or the &quot;wvc&quot; file for hybrid lossless. This data\n// would not be used for hybrid lossy mode. There is also a 32-bit CRC stored\n// in the first 4 bytes of these blocks.\n\nstatic int init_wvx_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    unsigned char *cp = (unsigned char *)wpmd-&gt;data;\n\n    if (wpmd-&gt;byte_length &lt;= 4 || (wpmd-&gt;byte_length &amp; 1))\n        return FALSE;\n\n    wps-&gt;crc_wvx = *cp++;\n    wps-&gt;crc_wvx |= (uint32_t) *cp++ &lt;&lt; 8;\n    wps-&gt;crc_wvx |= (uint32_t) *cp++ &lt;&lt; 16;\n    wps-&gt;crc_wvx |= (uint32_t) *cp++ &lt;&lt; 24;\n\n    bs_open_read (&amp;wps-&gt;wvxbits, cp, (unsigned char *) wpmd-&gt;data + wpmd-&gt;byte_length);\n\n    // the new WVX bitstream format starts with one or two new 5-bit fields\n\n    if (wpmd-&gt;id == ID_WVX_NEW_BITSTREAM) {\n        if (wps-&gt;wphdr.flags &amp; FLOAT_DATA) {\n            getbits (&amp;wps-&gt;float_min_shifted_zeros, 5, &amp;wps-&gt;wvxbits);\n            wps-&gt;float_min_shifted_zeros &amp;= 0x1f;\n            getbits (&amp;wps-&gt;float_max_shifted_ones, 5, &amp;wps-&gt;wvxbits);\n            wps-&gt;float_max_shifted_ones &amp;= 0x1f;\n        }\n        else {\n            getbits (&amp;wps-&gt;int32_max_width, 5, &amp;wps-&gt;wvxbits);\n            wps-&gt;int32_max_width &amp;= 0x1f;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read the int32 data from the specified metadata into the specified stream.\n// This data is used for integer data that has more than 24 bits of magnitude\n// or, in some cases, used to eliminate redundant bits from any audio stream.\n\nstatic int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    char *byteptr = (char *)wpmd-&gt;data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps-&gt;int32_sent_bits = *byteptr++;\n    wps-&gt;int32_zeros = *byteptr++;\n    wps-&gt;int32_ones = *byteptr++;\n    wps-&gt;int32_dups = *byteptr;\n\n    return TRUE;\n}\n\nstatic int read_float_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    char *byteptr = (char *)wpmd-&gt;data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps-&gt;float_flags = *byteptr++;\n    wps-&gt;float_shift = *byteptr++;\n    wps-&gt;float_max_exp = *byteptr++;\n    wps-&gt;float_norm_exp = *byteptr;\n    return TRUE;\n}\n\n// Read multichannel information from metadata. The first byte is the total\n// number of channels and the following bytes represent the channel_mask\n// as described for Microsoft WAVEFORMATEX.\n\nstatic int read_channel_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length, shift = 0, mask_bits;\n    unsigned char *byteptr = (unsigned char *)wpmd-&gt;data;\n    uint32_t mask = 0;\n\n    if (!bytecnt || bytecnt &gt; 7)\n        return FALSE;\n\n    if (!wpc-&gt;config.num_channels) {\n\n        // if bytecnt is 6 or 7 we are using new configuration with &quot;unlimited&quot; streams\n\n        if (bytecnt &gt;= 6) {\n            wpc-&gt;config.num_channels = (byteptr [0] | ((byteptr [2] &amp; 0xf) &lt;&lt; 8)) + 1;\n            wpc-&gt;max_streams = (byteptr [1] | ((byteptr [2] &amp; 0xf0) &lt;&lt; 4)) + 1;\n\n            if (wpc-&gt;config.num_channels &lt; wpc-&gt;max_streams)\n                return FALSE;\n\n            byteptr += 3;\n            mask = *byteptr++;\n            mask |= (uint32_t) *byteptr++ &lt;&lt; 8;\n            mask |= (uint32_t) *byteptr++ &lt;&lt; 16;\n\n            if (bytecnt == 7)                           // this was introduced in 5.0\n                mask |= (uint32_t) *byteptr &lt;&lt; 24;\n        }\n        else {\n            wpc-&gt;config.num_channels = *byteptr++;\n\n            while (--bytecnt) {\n                mask |= (uint32_t) *byteptr++ &lt;&lt; shift;\n                shift += 8;\n            }\n\n            // FFmpeg 6.1 generates non-compliant multichannel WavPack files that do not use the\n            // new (2016) channel format form introduced in WavPack 5.0. This hack allows those\n            // files to be decoded by the reference decoder. Surprisingly, the last time I\n            // checked, FFmpeg itself can&#x27;t decode many of them either!\n\n            if (wpc-&gt;config.num_channels &gt; OLD_MAX_STREAMS)\n                wpc-&gt;max_streams = wpc-&gt;config.num_channels;\n        }\n\n        if (wpc-&gt;config.num_channels &gt; wpc-&gt;max_streams * 2)\n            return FALSE;\n\n        wpc-&gt;config.channel_mask = mask;\n\n        for (mask_bits = 0; mask; mask &gt;&gt;= 1)\n            if ((mask &amp; 1) &amp;&amp; ++mask_bits &gt; wpc-&gt;config.num_channels)\n                return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Read multichannel identity information from metadata. Data is an array of\n// unsigned characters representing any channels in the file that DO NOT\n// match one the 18 Microsoft standard channels (and are represented in the\n// channel mask). A value of 0 is not allowed and 0xff means an unknown or\n// undefined channel identity.\n\nstatic int read_channel_identities (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    unsigned char *idents = wpmd-&gt;data;\n    int i;\n\n    if (!wpmd-&gt;data || !wpmd-&gt;byte_length)\n        return FALSE;\n\n    for (i = 0; i &lt; wpmd-&gt;byte_length; ++i)\n        if (!idents [i])\n            return FALSE;\n\n    if (!wpc-&gt;channel_identities) {\n        wpc-&gt;channel_identities = (unsigned char *)malloc (wpmd-&gt;byte_length + 1);\n        memcpy (wpc-&gt;channel_identities, wpmd-&gt;data, wpmd-&gt;byte_length);\n        wpc-&gt;channel_identities [wpmd-&gt;byte_length] = 0;\n    }\n\n    return TRUE;\n}\n\n// Read configuration information from metadata.\n\nstatic int read_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    unsigned char *byteptr = (unsigned char *)wpmd-&gt;data;\n\n    if (bytecnt &gt;= 3) {\n        wpc-&gt;config.flags &amp;= 0xff;\n        wpc-&gt;config.flags |= (uint32_t) *byteptr++ &lt;&lt; 8;\n        wpc-&gt;config.flags |= (uint32_t) *byteptr++ &lt;&lt; 16;\n        wpc-&gt;config.flags |= (uint32_t) *byteptr++ &lt;&lt; 24;\n        bytecnt -= 3;\n\n        if (bytecnt &amp;&amp; (wpc-&gt;config.flags &amp; CONFIG_EXTRA_MODE)) {\n            wpc-&gt;config.xmode = *byteptr++;\n            bytecnt--;\n        }\n\n        // we used an extra config byte here for the 5.0.0 alpha, so still\n        // honor it now (but this has been replaced with NEW_CONFIG)\n\n        if (bytecnt) {\n            wpc-&gt;config.qmode = (wpc-&gt;config.qmode &amp; ~0xff) | *byteptr;\n            wpc-&gt;version_five = 1;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read &quot;new&quot; configuration information from metadata.\n\nstatic int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    unsigned char *byteptr = (unsigned char *)wpmd-&gt;data;\n\n    wpc-&gt;version_five = 1;      // just having this block signals version 5.0\n\n    wpc-&gt;file_format = wpc-&gt;config.qmode = wpc-&gt;channel_layout = 0;\n\n    if (wpc-&gt;channel_reordering) {\n        free (wpc-&gt;channel_reordering);\n        wpc-&gt;channel_reordering = NULL;\n    }\n\n    // if there&#x27;s any data, the first two bytes are file_format and qmode flags\n\n    if (bytecnt &gt;= 2) {\n        wpc-&gt;file_format = *byteptr++;\n        wpc-&gt;config.qmode = (wpc-&gt;config.qmode &amp; ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n        // another byte indicates a channel layout\n\n        if (bytecnt) {\n            int nchans, i;\n\n            wpc-&gt;channel_layout = (uint32_t) *byteptr++ &lt;&lt; 16;\n            bytecnt--;\n\n            // another byte means we have a channel count for the layout and maybe a reordering\n\n            if (bytecnt) {\n                wpc-&gt;channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n                // any more means there&#x27;s a reordering string\n\n                if (bytecnt) {\n                    if (bytecnt &gt; nchans)\n                        return FALSE;\n\n                    wpc-&gt;channel_reordering = (unsigned char *)malloc (nchans);\n\n                    // note that redundant reordering info is not stored, so we fill in the rest\n\n                    if (wpc-&gt;channel_reordering) {\n                        for (i = 0; i &lt; nchans; ++i)\n                            if (bytecnt) {\n                                wpc-&gt;channel_reordering [i] = *byteptr++;\n\n                                if (wpc-&gt;channel_reordering [i] &gt;= nchans)  // make sure index is in range\n                                    wpc-&gt;channel_reordering [i] = 0;\n\n                                bytecnt--;\n                            }\n                            else\n                                wpc-&gt;channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc-&gt;channel_layout += wpc-&gt;config.num_channels;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read non-standard sampling rate from metadata.\n\nstatic int read_sample_rate (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd-&gt;byte_length;\n    unsigned char *byteptr = (unsigned char *)wpmd-&gt;data;\n\n    if (bytecnt == 3 || bytecnt == 4) {\n        wpc-&gt;config.sample_rate = (int32_t) *byteptr++;\n        wpc-&gt;config.sample_rate |= (int32_t) *byteptr++ &lt;&lt; 8;\n        wpc-&gt;config.sample_rate |= (int32_t) *byteptr++ &lt;&lt; 16;\n\n        // for sampling rates &gt; 16777215 (non-audio probably, or ...)\n\n        if (bytecnt == 4)\n            wpc-&gt;config.sample_rate |= (int32_t) (*byteptr &amp; 0x7f) &lt;&lt; 24;\n    }\n\n    return TRUE;\n}\n\n// Read wrapper data from metadata. Currently, this consists of the RIFF\n// header and trailer that wav files contain around the audio data but could\n// be used for other formats as well. Because WavPack files contain all the\n// information required for decoding and playback, this data can probably\n// be ignored except when an exact wavefile restoration is needed.\n\nstatic int read_wrapper_data (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    if ((wpc-&gt;open_flags &amp; OPEN_WRAPPER) &amp;&amp; wpc-&gt;wrapper_bytes &lt; MAX_WRAPPER_BYTES &amp;&amp; wpmd-&gt;byte_length) {\n        wpc-&gt;wrapper_data = (unsigned char *)realloc (wpc-&gt;wrapper_data, wpc-&gt;wrapper_bytes + wpmd-&gt;byte_length);\n\tif (!wpc-&gt;wrapper_data)\n\t    return FALSE;\n        memcpy (wpc-&gt;wrapper_data + wpc-&gt;wrapper_bytes, wpmd-&gt;data, wpmd-&gt;byte_length);\n        wpc-&gt;wrapper_bytes += wpmd-&gt;byte_length;\n    }\n\n    return TRUE;\n}\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) blockbuff;\n    unsigned char *buffend = blockbuff + wphdr-&gt;ckSize + 8;\n\n    if (buffend - *buffptr &lt; 2)\n        return FALSE;\n\n    wpmd-&gt;id = *(*buffptr)++;\n    wpmd-&gt;byte_length = *(*buffptr)++ &lt;&lt; 1;\n\n    if (wpmd-&gt;id &amp; ID_LARGE) {\n        wpmd-&gt;id &amp;= ~ID_LARGE;\n\n        if (buffend - *buffptr &lt; 2)\n            return FALSE;\n\n        wpmd-&gt;byte_length += *(*buffptr)++ &lt;&lt; 9;\n        wpmd-&gt;byte_length += *(*buffptr)++ &lt;&lt; 17;\n    }\n\n    if (wpmd-&gt;id &amp; ID_ODD_SIZE) {\n        if (!wpmd-&gt;byte_length)         // odd size and zero length makes no sense\n            return FALSE;\n        wpmd-&gt;id &amp;= ~ID_ODD_SIZE;\n        wpmd-&gt;byte_length--;\n    }\n\n    if (wpmd-&gt;byte_length) {\n        if (buffend - *buffptr &lt; wpmd-&gt;byte_length + (wpmd-&gt;byte_length &amp; 1)) {\n            wpmd-&gt;data = NULL;\n            return FALSE;\n        }\n\n        wpmd-&gt;data = *buffptr;\n        (*buffptr) += wpmd-&gt;byte_length + (wpmd-&gt;byte_length &amp; 1);\n    }\n    else\n        wpmd-&gt;data = NULL;\n\n    return TRUE;\n}\n\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd, int stream)\n{\n    WavpackStream *wps = wpc-&gt;streams [stream];\n\n    switch (wpmd-&gt;id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n        case ID_WVX_NEW_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wps, wpmd);\n#else\n            strcpy (wpc-&gt;error_message, &quot;not configured to handle DSD WavPack files!&quot;);\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc-&gt;open_flags &amp; OPEN_ALT_TYPES))\n                return TRUE;\n\n            // fall through\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc-&gt;open_flags &amp; OPEN_ALT_TYPES))\n                return TRUE;\n\n            // fall through\n        case ID_MD5_CHECKSUM:\n            if (wpmd-&gt;byte_length == 16) {\n                memcpy (wpc-&gt;config.md5_checksum, wpmd-&gt;data, 16);\n                wpc-&gt;config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc-&gt;config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd-&gt;byte_length &amp;&amp; wpmd-&gt;byte_length &lt; sizeof (wpc-&gt;file_extension)) {\n                int i, j;\n\n                for (i = j = 0; i &lt; wpmd-&gt;byte_length; ++i)\n                    if (isalnum (((char *) wpmd-&gt;data) [i]))\n                        wpc-&gt;file_extension [j++] = ((char *) wpmd-&gt;data) [i];\n\n                wpc-&gt;file_extension [j] = 0;\n            }\n\n            return TRUE;\n\n        // we don&#x27;t actually verify the checksum here (it&#x27;s done right after the\n        // block is read), but it&#x27;s a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc-&gt;version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd-&gt;id &amp; ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}\n\n//////////////////////////////// bitstream management ///////////////////////////////\n\n// Open the specified BitStream and associate with the specified buffer.\n\nstatic void bs_read (Bitstream *bs);\n\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs-&gt;error = bs-&gt;sr = bs-&gt;bc = 0;\n    bs-&gt;ptr = (bs-&gt;buf = buffer_start) - 1;\n    bs-&gt;end = buffer_end;\n    bs-&gt;wrap = bs_read;\n}\n\n// This function is only called from the getbit() and getbits() macros when\n// the BitStream has been exhausted and more data is required. Since these\n// bistreams no longer access files, this function simple sets an error and\n// resets the buffer.\n\nstatic void bs_read (Bitstream *bs)\n{\n    bs-&gt;ptr = bs-&gt;buf;\n    bs-&gt;error = 1;\n}\n\n// This function is called to close the bitstream. It returns the number of\n// full bytes actually read as bits.\n\nuint32_t bs_close_read (Bitstream *bs)\n{\n    uint32_t bytes_read;\n\n    if (bs-&gt;bc &lt; sizeof (*(bs-&gt;ptr)) * 8)\n        bs-&gt;ptr++;\n\n    bytes_read = (uint32_t)(bs-&gt;ptr - bs-&gt;buf) * sizeof (*(bs-&gt;ptr));\n\n    if (!(bytes_read &amp; 1))\n        ++bytes_read;\n\n    CLEAR (*bs);\n    return bytes_read;\n}\n\n// Normally the trailing wrapper will not be available when a WavPack file is first\n// opened for reading because it is stored in the final block of the file. This\n// function forces a seek to the end of the file to pick up any trailing wrapper\n// stored there (then use WavPackGetWrapper**() to obtain). This can obviously only\n// be used for seekable files (not pipes) and is not available for pre-4.0 WavPack\n// files.\n\nvoid WavpackSeekTrailingWrapper (WavpackContext *wpc)\n{\n    if ((wpc-&gt;open_flags &amp; OPEN_WRAPPER) &amp;&amp;\n        wpc-&gt;reader-&gt;can_seek (wpc-&gt;wv_in) &amp;&amp; !wpc-&gt;stream3)\n            seek_eof_information (wpc, NULL, TRUE);\n}\n\n// Get any MD5 checksum stored in the metadata (should be called after reading\n// last sample or an extra seek will occur). A return value of FALSE indicates\n// that no MD5 checksum was stored.\n\nint WavpackGetMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    if (wpc-&gt;config.flags &amp; CONFIG_MD5_CHECKSUM) {\n        if (!wpc-&gt;config.md5_read &amp;&amp; wpc-&gt;reader-&gt;can_seek (wpc-&gt;wv_in))\n            seek_eof_information (wpc, NULL, FALSE);\n\n        if (wpc-&gt;config.md5_read) {\n            memcpy (data, wpc-&gt;config.md5_checksum, 16);\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n// Read from current file position until a valid 32-byte WavPack 4.0 header is\n// found and read into the specified pointer. The number of bytes skipped is\n// returned. If no WavPack header is found within 1 meg, then a -1 is returned\n// to indicate the error. No additional bytes are read past the header and it\n// is returned in the processor&#x27;s native endian mode. Seeking is not required.\n\nuint32_t read_next_header (WavpackStreamReader64 *reader, void *id, WavpackHeader *wphdr)\n{\n    unsigned char buffer [sizeof (*wphdr)], *sp = buffer + sizeof (*wphdr), *ep = sp;\n    uint32_t bytes_skipped = 0;\n    int bleft;\n\n    while (1) {\n        if (sp &lt; ep) {\n            bleft = (int)(ep - sp);\n            memmove (buffer, sp, bleft);\n        }\n        else\n            bleft = 0;\n\n        if (reader-&gt;read_bytes (id, buffer + bleft, sizeof (*wphdr) - bleft) != sizeof (*wphdr) - bleft)\n            return -1;\n\n        sp = buffer;\n\n        if (*sp++ == &#x27;w&#x27; &amp;&amp; *sp == &#x27;v&#x27; &amp;&amp; *++sp == &#x27;p&#x27; &amp;&amp; *++sp == &#x27;k&#x27; &amp;&amp;\n            !(*++sp &amp; 1) &amp;&amp; sp [2] &lt; 16 &amp;&amp; !sp [3] &amp;&amp; (sp [2] || sp [1] || *sp &gt;= 24) &amp;&amp; sp [5] == 4 &amp;&amp;\n            sp [4] &gt;= (MIN_STREAM_VERS &amp; 0xff) &amp;&amp; sp [4] &lt;= (MAX_STREAM_VERS &amp; 0xff) &amp;&amp; sp [18] &lt; 3 &amp;&amp; !sp [19]) {\n                memcpy (wphdr, buffer, sizeof (*wphdr));\n                WavpackLittleEndianToNative (wphdr, WavpackHeaderFormat);\n                return bytes_skipped;\n            }\n\n        while (sp &lt; ep &amp;&amp; *sp != &#x27;w&#x27;)\n            sp++;\n\n        if ((bytes_skipped += (uint32_t)(sp - buffer)) &gt; 1024 * 1024)\n            return -1;\n    }\n}\n\n// Compare the regular wv file block header to a potential matching wvc\n// file block header and return action code based on analysis:\n//\n//   0 = use wvc block (assuming rest of block is readable)\n//   1 = bad match; try to read next wvc block\n//  -1 = bad match; ignore wvc file for this block and backup fp (if\n//       possible) and try to use this block next time\n\nstatic int match_wvc_header (WavpackHeader *wv_hdr, WavpackHeader *wvc_hdr)\n{\n    if (GET_BLOCK_INDEX (*wv_hdr) == GET_BLOCK_INDEX (*wvc_hdr) &amp;&amp;\n        wv_hdr-&gt;block_samples == wvc_hdr-&gt;block_samples) {\n            int wvi = 0, wvci = 0;\n\n            if (wv_hdr-&gt;flags == wvc_hdr-&gt;flags)\n                return 0;\n\n            if (wv_hdr-&gt;flags &amp; INITIAL_BLOCK)\n                wvi -= 1;\n\n            if (wv_hdr-&gt;flags &amp; FINAL_BLOCK)\n                wvi += 1;\n\n            if (wvc_hdr-&gt;flags &amp; INITIAL_BLOCK)\n                wvci -= 1;\n\n            if (wvc_hdr-&gt;flags &amp; FINAL_BLOCK)\n                wvci += 1;\n\n            return (wvci - wvi &lt; 0) ? 1 : -1;\n        }\n\n    if ((GET_BLOCK_INDEX (*wvc_hdr) - GET_BLOCK_INDEX (*wv_hdr)) &amp; 0x8000000000LL)\n        return 1;\n    else\n        return -1;\n}\n\n// Read the wvc block that matches the regular wv block that has been\n// read for the current stream. If an exact match is not found then\n// we either keep reading or back up and (possibly) use the block\n// later. The skip_wvc flag is set if not matching wvc block is found\n// so that we can still decode using only the lossy version (although\n// we flag this as an error). A return of FALSE indicates a serious\n// error (not just that we missed one wvc block).\n\nint read_wvc_block (WavpackContext *wpc, int stream)\n{\n    WavpackStream *wps = wpc-&gt;streams [stream];\n    int64_t bcount, file2pos;\n    WavpackHeader orig_wphdr;\n    WavpackHeader wphdr;\n    int compare_result;\n\n    while (1) {\n        file2pos = wpc-&gt;reader-&gt;get_pos (wpc-&gt;wvc_in);\n        bcount = read_next_header (wpc-&gt;reader, wpc-&gt;wvc_in, &amp;wphdr);\n\n        if (bcount == (uint32_t) -1) {\n            wps-&gt;wvc_skip = TRUE;\n            wpc-&gt;crc_errors++;\n            return FALSE;\n        }\n\n        memcpy (&amp;orig_wphdr, &amp;wphdr, 32);       // save original header for verify step\n\n        if (wpc-&gt;open_flags &amp; OPEN_STREAMING)\n            SET_BLOCK_INDEX (wphdr, wps-&gt;sample_index = 0);\n        else\n            SET_BLOCK_INDEX (wphdr, GET_BLOCK_INDEX (wphdr) - wpc-&gt;initial_index);\n\n        if (wphdr.flags &amp; INITIAL_BLOCK)\n            wpc-&gt;file2pos = file2pos + bcount;\n\n        compare_result = match_wvc_header (&amp;wps-&gt;wphdr, &amp;wphdr);\n\n        if (!compare_result) {\n            wps-&gt;block2buff = (unsigned char *)malloc (wphdr.ckSize + 8);\n\t    if (!wps-&gt;block2buff)\n\t        return FALSE;\n\n            if (wpc-&gt;reader-&gt;read_bytes (wpc-&gt;wvc_in, wps-&gt;block2buff + 32, wphdr.ckSize - 24) !=\n                wphdr.ckSize - 24) {\n                    free (wps-&gt;block2buff);\n                    wps-&gt;block2buff = NULL;\n                    wps-&gt;wvc_skip = TRUE;\n                    wpc-&gt;crc_errors++;\n                    return FALSE;\n            }\n\n            memcpy (wps-&gt;block2buff, &amp;orig_wphdr, 32);\n\n            // don&#x27;t use corrupt blocks\n            if (!WavpackVerifySingleBlock (wps-&gt;block2buff, !(wpc-&gt;open_flags &amp; OPEN_NO_CHECKSUM))) {\n                free (wps-&gt;block2buff);\n                wps-&gt;block2buff = NULL;\n                wps-&gt;wvc_skip = TRUE;\n                wpc-&gt;crc_errors++;\n                return TRUE;\n            }\n\n            wps-&gt;wvc_skip = FALSE;\n            memcpy (wps-&gt;block2buff, &amp;wphdr, 32);\n            memcpy (&amp;wps-&gt;wphdr, &amp;wphdr, 32);\n            return TRUE;\n        }\n        else if (compare_result == -1) {\n            wps-&gt;wvc_skip = TRUE;\n            wpc-&gt;reader-&gt;set_pos_rel (wpc-&gt;wvc_in, -32, SEEK_CUR);\n            wpc-&gt;crc_errors++;\n            return TRUE;\n        }\n    }\n}\n\n// This function is used to seek to end of a file to obtain certain information\n// that is stored there at the file creation time because it is not known at\n// the start. This includes the MD5 sum and and trailing part of the file\n// wrapper, and in some rare cases may include the total number of samples in\n// the file (although we usually try to back up and write that at the front of\n// the file). Note this function restores the file position to its original\n// location (and obviously requires a seekable file). The normal return value\n// is TRUE indicating no errors, although this does not actually mean that any\n// information was retrieved. An error return of FALSE usually means the file\n// terminated unexpectedly. Note that this could be used to get all three\n// types of information in one go, but it&#x27;s not actually used that way now.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper)\n{\n    int64_t restore_pos, last_pos = -1;\n    WavpackStreamReader64 *reader = wpc-&gt;reader;\n    int alt_types = wpc-&gt;open_flags &amp; OPEN_ALT_TYPES;\n    uint32_t blocks = 0, audio_blocks = 0;\n    void *id = wpc-&gt;wv_in;\n    WavpackHeader wphdr;\n\n    restore_pos = reader-&gt;get_pos (id);    // we restore file position when done\n\n    // start 1MB from the end-of-file, or from the start if the file is not that big\n\n    if (reader-&gt;get_length (id) &gt; (int64_t) 1048576)\n        reader-&gt;set_pos_rel (id, -1048576, SEEK_END);\n    else\n        reader-&gt;set_pos_abs (id, 0);\n\n    // Note that we go backward (without parsing inside blocks) until we find a block\n    // with audio (careful to not get stuck in a loop). Only then do we go forward\n    // parsing all blocks in their entirety.\n\n    while (1) {\n        uint32_t bcount = read_next_header (reader, id, &amp;wphdr);\n        int64_t current_pos = reader-&gt;get_pos (id);\n\n        // if we just got to the same place as last time, we&#x27;re stuck and need to give up\n\n        if (current_pos == last_pos) {\n            reader-&gt;set_pos_abs (id, restore_pos);\n            return FALSE;\n        }\n\n        last_pos = current_pos;\n\n        // We enter here if we just read 1 MB without seeing any WavPack block headers.\n        // Since WavPack blocks are &lt; 1 MB, that means we&#x27;re in a big APE tag, or we got\n        // to the end-of-file.\n\n        if (bcount == (uint32_t) -1) {\n\n            // if we have not seen any blocks at all yet, back up almost 2 MB (or to the\n            // beginning of the file) and try again\n\n            if (!blocks) {\n                if (current_pos &gt; (int64_t) 2000000)\n                    reader-&gt;set_pos_rel (id, -2000000, SEEK_CUR);\n                else\n                    reader-&gt;set_pos_abs (id, 0);\n\n                continue;\n            }\n\n            // if we have seen WavPack blocks, then this means we&#x27;ve done all we can do here\n\n            reader-&gt;set_pos_abs (id, restore_pos);\n            return TRUE;\n        }\n\n        blocks++;\n\n        // If the block has audio samples, calculate a final index, although this is not\n        // final since this may not be the last block with audio. On the other hand, if\n        // this block does not have audio, and we haven&#x27;t seen one with audio, we have\n        // to go back some more.\n\n        if (wphdr.block_samples) {\n            if (final_index)\n                *final_index = GET_BLOCK_INDEX (wphdr) + wphdr.block_samples;\n\n            audio_blocks++;\n        }\n        else if (!audio_blocks) {\n            if (current_pos &gt; (int64_t) 1048576)\n                reader-&gt;set_pos_rel (id, -1048576, SEEK_CUR);\n            else\n                reader-&gt;set_pos_abs (id, 0);\n\n            continue;\n        }\n\n        // at this point we have seen at least one block with audio, so we parse the\n        // entire block looking for MD5 metadata or (conditionally) trailing wrappers\n\n        bcount = wphdr.ckSize - sizeof (WavpackHeader) + 8;\n\n        while (bcount &gt;= 2) {\n            unsigned char meta_id, c1, c2;\n            uint32_t meta_bc, meta_size;\n\n            if (reader-&gt;read_bytes (id, &amp;meta_id, 1) != 1 ||\n                reader-&gt;read_bytes (id, &amp;c1, 1) != 1) {\n                    reader-&gt;set_pos_abs (id, restore_pos);\n                    return FALSE;\n            }\n\n            meta_bc = c1 &lt;&lt; 1;\n            bcount -= 2;\n\n            if (meta_id &amp; ID_LARGE) {\n                if (bcount &lt; 2 || reader-&gt;read_bytes (id, &amp;c1, 1) != 1 ||\n                    reader-&gt;read_bytes (id, &amp;c2, 1) != 1) {\n                        reader-&gt;set_pos_abs (id, restore_pos);\n                        return FALSE;\n                }\n\n                meta_bc += ((uint32_t) c1 &lt;&lt; 9) + ((uint32_t) c2 &lt;&lt; 17);\n                bcount -= 2;\n            }\n\n            meta_size = (meta_id &amp; ID_ODD_SIZE) ? meta_bc - 1 : meta_bc;\n            meta_id &amp;= ID_UNIQUE;\n\n            if (get_wrapper &amp;&amp; (meta_id == ID_RIFF_TRAILER || (alt_types &amp;&amp; meta_id == ID_ALT_TRAILER)) &amp;&amp; meta_bc) {\n                wpc-&gt;wrapper_data = (unsigned char *)realloc (wpc-&gt;wrapper_data, wpc-&gt;wrapper_bytes + meta_bc);\n\n                if (!wpc-&gt;wrapper_data) {\n                    reader-&gt;set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n\n                if (reader-&gt;read_bytes (id, wpc-&gt;wrapper_data + wpc-&gt;wrapper_bytes, meta_bc) == meta_bc)\n                    wpc-&gt;wrapper_bytes += meta_size;\n                else {\n                    reader-&gt;set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n            }\n            else if (meta_id == ID_MD5_CHECKSUM || (alt_types &amp;&amp; meta_id == ID_ALT_MD5_CHECKSUM)) {\n                if (meta_bc == 16 &amp;&amp; bcount &gt;= 16) {\n                    if (reader-&gt;read_bytes (id, wpc-&gt;config.md5_checksum, 16) == 16)\n                        wpc-&gt;config.md5_read = TRUE;\n                    else {\n                        reader-&gt;set_pos_abs (id, restore_pos);\n                        return FALSE;\n                    }\n                }\n                else\n                    reader-&gt;set_pos_rel (id, meta_bc, SEEK_CUR);\n            }\n            else\n                reader-&gt;set_pos_rel (id, meta_bc, SEEK_CUR);\n\n            bcount -= meta_bc;\n        }\n    }\n}\n\n// Quickly verify the referenced block. It is assumed that the WavPack header has been converted\n// to native endian format. If a block checksum is performed, that is done in little-endian\n// (file) format. It is also assumed that the caller has made sure that the block length\n// indicated in the header is correct (we won&#x27;t overflow the buffer). If a checksum is present,\n// then it is checked, otherwise we just check that all the metadata blocks are formatted\n// correctly (without looking at their contents). Returns FALSE for bad block.\n\nint WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr-&gt;ckID, &quot;wvpk&quot;, 4) || wphdr-&gt;ckSize + 8 &lt; sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr-&gt;ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount &gt;= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 &lt;&lt; 1;\n        bcount -= 2;\n\n        if (meta_id &amp; ID_LARGE) {\n            if (bcount &lt; 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 &lt;&lt; 9) + ((uint32_t) c2 &lt;&lt; 17);\n            bcount -= 2;\n        }\n\n        if (bcount &lt; meta_bc)\n            return FALSE;\n\n        if (verify_checksum &amp;&amp; (meta_id &amp; ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) &gt;&gt; 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id &amp; ID_ODD_SIZE) || meta_bc &lt; 2 || meta_bc &gt; 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] &lt;&lt; 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp != (csum &amp; 0xff) || dp[1] != ((csum &gt;&gt; 8) &amp; 0xff) || dp[2] != ((csum &gt;&gt; 16) &amp; 0xff) || dp[3] != ((csum &gt;&gt; 24) &amp; 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum &gt;&gt; 16;\n\n                if (*dp != (csum &amp; 0xff) || dp[1] != ((csum &gt;&gt; 8) &amp; 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) &amp;&amp; (!verify_checksum || !(wphdr-&gt;flags &amp; HAS_CHECKSUM) || checksum_passed);\n}\n"}, "/project/WavPack/src/pack.c": {"id": "/project/WavPack/src/pack.c", "filePath": "/project/WavPack/src/pack.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//               MMX optimizations (c) 2006 Joachim Henke                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// pack.c\n\n// This module actually handles the compression of the audio data, except for\n// the entropy encoding which is handled by the write_words.c module. For better\n// efficiency, the conversion is isolated to tight loops that handle an entire\n// buffer.\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n\n#include &quot;wavpack_local.h&quot;\n#include &quot;decorr_tables.h&quot;      // contains data, only include from this module!\n\n///////////////////////////// executable code ////////////////////////////////\n\n// This function initializes everything required to pack WavPack bitstreams and\n// must be called BEFORE any other function in this module. Normally the passed\n// WavpackStream structure would already be cleared, however this function can\n// also be used to clear the stream context of history which is required after\n// discontinuities caused by multi-threaded temporal encoding. This is why,\n// for example, we do not clear the sample_index here.\n\nvoid pack_init (WavpackStream *wps)\n{\n    wps-&gt;num_terms = 0;\n    wps-&gt;dc.error [0] = wps-&gt;dc.error [1] = 0;\n    CLEARA (wps-&gt;decorr_passes);\n    CLEAR (wps-&gt;dc);\n\n    if (wps-&gt;delta_decay == 0.0)\n        wps-&gt;delta_decay = 2.0;\n\n    if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_DYNAMIC_SHAPING) {\n        wps-&gt;dc.shaping_data = malloc (wps-&gt;wpc-&gt;max_samples * sizeof (*wps-&gt;dc.shaping_data));\n        CLEAR (wps-&gt;analysis_pass);\n        wps-&gt;analysis_pass.term = 18;\n        wps-&gt;analysis_pass.delta = 2;\n    }\n    else if (wps-&gt;wpc-&gt;config.shaping_weight) {\n        int32_t weight = (int32_t) floor (wps-&gt;wpc-&gt;config.shaping_weight * 1024.0 + 0.5);\n\n        if (weight &lt;= -1000)\n            weight = -1000;\n\n        wps-&gt;dc.shaping_acc [0] = wps-&gt;dc.shaping_acc [1] = weight &lt;&lt; 16;\n    }\n\n    if (!wps-&gt;wpc-&gt;config.xmode)\n        wps-&gt;num_passes = 0;\n    else if (wps-&gt;wpc-&gt;config.xmode == 1)\n        wps-&gt;num_passes = 2;\n    else if (wps-&gt;wpc-&gt;config.xmode == 2)\n        wps-&gt;num_passes = 4;\n    else\n        wps-&gt;num_passes = 9;\n\n#ifdef ENABLE_THREADS\n    // For temporal multithreading, add a couple of passes to the -x1 and -x2 modes to\n    // compensate for the compression degradation caused by the discontinuities.\n\n    if (wps-&gt;wpc-&gt;config.xmode &amp;&amp; wps-&gt;wpc-&gt;config.xmode &lt;= 2 &amp;&amp;\n        wps-&gt;wpc-&gt;num_workers &amp;&amp; wps-&gt;wpc-&gt;num_streams == 1)\n            wps-&gt;num_passes += 2;\n#endif\n\n    if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_VERY_HIGH_FLAG) {\n        wps-&gt;num_decorrs = NUM_VERY_HIGH_SPECS;\n        wps-&gt;decorr_specs = very_high_specs;\n    }\n    else if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_HIGH_FLAG) {\n        wps-&gt;num_decorrs = NUM_HIGH_SPECS;\n        wps-&gt;decorr_specs = high_specs;\n    }\n    else if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_FAST_FLAG) {\n        wps-&gt;num_decorrs = NUM_FAST_SPECS;\n        wps-&gt;decorr_specs = fast_specs;\n    }\n    else {\n        wps-&gt;num_decorrs = NUM_DEFAULT_SPECS;\n        wps-&gt;decorr_specs = default_specs;\n    }\n\n    init_words (wps);\n}\n\n// Allocate room for and copy the decorrelation terms from the decorr_passes\n// array into the specified metadata structure. Both the actual term id and\n// the delta are packed into single characters.\n\nstatic void write_decorr_terms (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int tcount = wps-&gt;num_terms;\n    struct decorr_pass *dpp;\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (tcount + 1);\n    wpmd-&gt;id = ID_DECORR_TERMS;\n\n    for (dpp = wps-&gt;decorr_passes; tcount--; ++dpp)\n        *byteptr++ = ((dpp-&gt;term + 5) &amp; 0x1f) | ((dpp-&gt;delta &lt;&lt; 5) &amp; 0xe0);\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the decorrelation term weights from the\n// decorr_passes array into the specified metadata structure. The weights\n// range +/-1024, but are rounded and truncated to fit in signed chars for\n// metadata storage. Weights are separate for the two channels\n\nstatic void write_decorr_weights (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    struct decorr_pass *dpp = wps-&gt;decorr_passes;\n    int tcount = wps-&gt;num_terms, i;\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc ((tcount * 2) + 1);\n    wpmd-&gt;id = ID_DECORR_WEIGHTS;\n\n    for (i = wps-&gt;num_terms - 1; i &gt;= 0; --i)\n        if (store_weight (dpp [i].weight_A) ||\n            (!(wps-&gt;wphdr.flags &amp; MONO_DATA) &amp;&amp; store_weight (dpp [i].weight_B)))\n                break;\n\n    tcount = i + 1;\n\n    for (i = 0; i &lt; wps-&gt;num_terms; ++i) {\n        if (i &lt; tcount) {\n            dpp [i].weight_A = restore_weight (*byteptr++ = store_weight (dpp [i].weight_A));\n\n            if (!(wps-&gt;wphdr.flags &amp; MONO_DATA))\n                dpp [i].weight_B = restore_weight (*byteptr++ = store_weight (dpp [i].weight_B));\n        }\n        else\n            dpp [i].weight_A = dpp [i].weight_B = 0;\n    }\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the decorrelation samples from the decorr_passes\n// array into the specified metadata structure. The samples are signed 32-bit\n// values, but are converted to signed log2 values for storage in metadata.\n// Values are stored for both channels and are specified from the first term\n// with unspecified samples set to zero. The number of samples stored varies\n// with the actual term value, so those must obviously be specified before\n// these in the metadata list. Any number of terms can have their samples\n// specified from no terms to all the terms, however I have found that\n// sending more than the first term&#x27;s samples is a waste. The &quot;wcount&quot;\n// variable can be set to the number of terms to have their samples stored.\n\nstatic void write_decorr_samples (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int tcount = wps-&gt;num_terms, wcount = 1, temp;\n    struct decorr_pass *dpp;\n    unsigned char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (256);\n    wpmd-&gt;id = ID_DECORR_SAMPLES;\n\n    for (dpp = wps-&gt;decorr_passes; tcount--; ++dpp)\n        if (wcount) {\n            if (dpp-&gt;term &gt; MAX_TERM) {\n                dpp-&gt;samples_A [0] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_A [0]));\n                *byteptr++ = temp;\n                *byteptr++ = temp &gt;&gt; 8;\n                dpp-&gt;samples_A [1] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_A [1]));\n                *byteptr++ = temp;\n                *byteptr++ = temp &gt;&gt; 8;\n\n                if (!(wps-&gt;wphdr.flags &amp; MONO_DATA)) {\n                    dpp-&gt;samples_B [0] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_B [0]));\n                    *byteptr++ = temp;\n                    *byteptr++ = temp &gt;&gt; 8;\n                    dpp-&gt;samples_B [1] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_B [1]));\n                    *byteptr++ = temp;\n                    *byteptr++ = temp &gt;&gt; 8;\n                }\n            }\n            else if (dpp-&gt;term &lt; 0) {\n                dpp-&gt;samples_A [0] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_A [0]));\n                *byteptr++ = temp;\n                *byteptr++ = temp &gt;&gt; 8;\n                dpp-&gt;samples_B [0] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_B [0]));\n                *byteptr++ = temp;\n                *byteptr++ = temp &gt;&gt; 8;\n            }\n            else {\n                int m = 0, cnt = dpp-&gt;term;\n\n                while (cnt--) {\n                    dpp-&gt;samples_A [m] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_A [m]));\n                    *byteptr++ = temp;\n                    *byteptr++ = temp &gt;&gt; 8;\n\n                    if (!(wps-&gt;wphdr.flags &amp; MONO_DATA)) {\n                        dpp-&gt;samples_B [m] = wp_exp2s (temp = wp_log2s (dpp-&gt;samples_B [m]));\n                        *byteptr++ = temp;\n                        *byteptr++ = temp &gt;&gt; 8;\n                    }\n\n                    m++;\n                }\n            }\n\n            wcount--;\n        }\n        else {\n            CLEARA (dpp-&gt;samples_A);\n            CLEARA (dpp-&gt;samples_B);\n        }\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (unsigned char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the noise shaping info into the specified\n// metadata structure. These would normally be written to the\n// &quot;correction&quot; file and are used for lossless reconstruction of\n// hybrid data. The &quot;delta&quot; parameter is not yet used in encoding as it\n// will be part of the &quot;quality&quot; mode.\n\nstatic void write_shaping_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr;\n    int temp;\n\n    byteptr = wpmd-&gt;data = malloc (12);\n    wpmd-&gt;id = ID_SHAPING_WEIGHTS;\n\n    wps-&gt;dc.error [0] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.error [0]));\n    *byteptr++ = temp;\n    *byteptr++ = temp &gt;&gt; 8;\n    wps-&gt;dc.shaping_acc [0] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.shaping_acc [0]));\n    *byteptr++ = temp;\n    *byteptr++ = temp &gt;&gt; 8;\n\n    if (!(wps-&gt;wphdr.flags &amp; MONO_DATA)) {\n        wps-&gt;dc.error [1] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.error [1]));\n        *byteptr++ = temp;\n        *byteptr++ = temp &gt;&gt; 8;\n        wps-&gt;dc.shaping_acc [1] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.shaping_acc [1]));\n        *byteptr++ = temp;\n        *byteptr++ = temp &gt;&gt; 8;\n    }\n\n    if (wps-&gt;dc.shaping_delta [0] | wps-&gt;dc.shaping_delta [1]) {\n        wps-&gt;dc.shaping_delta [0] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.shaping_delta [0]));\n        *byteptr++ = temp;\n        *byteptr++ = temp &gt;&gt; 8;\n\n        if (!(wps-&gt;wphdr.flags &amp; MONO_DATA)) {\n            wps-&gt;dc.shaping_delta [1] = wp_exp2s (temp = wp_log2s (wps-&gt;dc.shaping_delta [1]));\n            *byteptr++ = temp;\n            *byteptr++ = temp &gt;&gt; 8;\n        }\n    }\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the int32 data values into the specified\n// metadata structure. This data is used for integer data that has more\n// than 24 bits of magnitude or, in some cases, it&#x27;s used to eliminate\n// redundant bits from any audio stream.\n\nstatic void write_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (4);\n    wpmd-&gt;id = ID_INT32_INFO;\n    *byteptr++ = wps-&gt;int32_sent_bits;\n    *byteptr++ = wps-&gt;int32_zeros;\n    *byteptr++ = wps-&gt;int32_ones;\n    *byteptr++ = wps-&gt;int32_dups;\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\nstatic void write_float_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (4);\n    wpmd-&gt;id = ID_FLOAT_INFO;\n    *byteptr++ = wps-&gt;float_flags;\n    *byteptr++ = wps-&gt;float_shift;\n    *byteptr++ = wps-&gt;float_max_exp;\n    *byteptr++ = wps-&gt;float_norm_exp;\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the multichannel information into the specified\n// metadata structure. The first byte is the total number of channels and the\n// following bytes represent the channel_mask as described for Microsoft\n// WAVEFORMATEX.\n\nstatic void write_channel_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    uint32_t mask = wps-&gt;wpc-&gt;config.channel_mask;\n    char *byteptr = wpmd-&gt;data = malloc (8);\n\n    wpmd-&gt;id = ID_CHANNEL_INFO;\n\n    if (wps-&gt;wpc-&gt;num_streams &gt; OLD_MAX_STREAMS) {       // if &gt; 8 streams, use 6 or 7 bytes (breaks old decoders\n        *byteptr++ = wps-&gt;wpc-&gt;config.num_channels - 1;  // that could only handle 8 streams) and allow (in theory)\n        *byteptr++ = wps-&gt;wpc-&gt;num_streams - 1;          // up to 4096 channels\n        *byteptr++ = (((wps-&gt;wpc-&gt;num_streams - 1) &gt;&gt; 4) &amp; 0xf0) | (((wps-&gt;wpc-&gt;config.num_channels - 1) &gt;&gt; 8) &amp; 0xf);\n        *byteptr++ = mask;\n        *byteptr++ = (mask &gt;&gt; 8);\n        *byteptr++ = (mask &gt;&gt; 16);\n\n        if (mask &amp; 0xff000000)                      // this will break versions &lt; 5.0, but is RF64-specific\n            *byteptr++ = (mask &gt;&gt; 24);\n    }\n    else {                                          // otherwise use only 1 to 5 bytes\n        *byteptr++ = wps-&gt;wpc-&gt;config.num_channels;\n\n        while (mask) {\n            *byteptr++ = mask;\n            mask &gt;&gt;= 8;\n        }\n    }\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the multichannel identities into the specified\n// metadata structure. Data is an array of unsigned characters representing\n// any channels in the file that DO NOT match one the 18 Microsoft standard\n// channels (and are represented in the channel mask). A value of 0 is not\n// allowed and 0xff means an unknown or undefined channel identity.\n\nstatic void write_channel_identities_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    wpmd-&gt;byte_length = (int) strlen ((char *) wps-&gt;wpc-&gt;channel_identities);\n    wpmd-&gt;data = strdup ((char *) wps-&gt;wpc-&gt;channel_identities);\n    wpmd-&gt;id = ID_CHANNEL_IDENTITIES;\n}\n\n// Allocate room for and copy the configuration information into the specified\n// metadata structure. Currently, we just store the upper 3 bytes of\n// config.flags and only in the first block of audio data. Note that this is\n// for informational purposes not required for playback or decoding (like\n// whether high or fast mode was specified).\n\nstatic void write_config_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (8);\n    wpmd-&gt;id = ID_CONFIG_BLOCK;\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.flags &gt;&gt; 8);\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.flags &gt;&gt; 16);\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.flags &gt;&gt; 24);\n\n    if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_EXTRA_MODE)\n        *byteptr++ = (char) wps-&gt;wpc-&gt;config.xmode;\n\n    // for the 5.0.0 alpha, we wrote the qmode flags here, but this\n    // has been replaced with the new_config block\n    // *byteptr++ = (char) wps-&gt;wpc-&gt;config.qmode;\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the &quot;new&quot; configuration information into the\n// specified metadata structure. This is all the stuff introduced with version\n// 5.0 and includes the qmode flags (big-endian, etc.) and CAF extended\n// channel layouts (including optional reordering). Even if there is no new\n// configuration, we still send the empty metadata block to signal a 5.0 file.\n\nstatic void write_new_config_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr = wpmd-&gt;data = malloc (260);\n\n    wpmd-&gt;id = ID_NEW_CONFIG_BLOCK;\n\n    if (wps-&gt;wpc-&gt;file_format || (wps-&gt;wpc-&gt;config.qmode &amp; 0xff) || wps-&gt;wpc-&gt;channel_layout) {\n        *byteptr++ = (char) wps-&gt;wpc-&gt;file_format;\n        *byteptr++ = (char) wps-&gt;wpc-&gt;config.qmode;\n\n        if (wps-&gt;wpc-&gt;channel_layout) {\n            int nchans = wps-&gt;wpc-&gt;channel_layout &amp; 0xff;\n\n            *byteptr++ = (char) ((wps-&gt;wpc-&gt;channel_layout &amp; 0xff0000) &gt;&gt; 16);\n\n            if (wps-&gt;wpc-&gt;channel_reordering || nchans != wps-&gt;wpc-&gt;config.num_channels)\n                *byteptr++ = (char) nchans;\n\n            if (wps-&gt;wpc-&gt;channel_reordering) {\n                int i, num_to_send = 0;\n\n                // to save space, don&#x27;t send redundant reorder string bytes\n\n                for (i = 0; i &lt; nchans; ++i)\n                    if (wps-&gt;wpc-&gt;channel_reordering [i] != i)\n                        num_to_send = i + 1;\n\n                if (num_to_send) {\n                    memcpy (byteptr, wps-&gt;wpc-&gt;channel_reordering, num_to_send);\n                    byteptr += num_to_send;\n                }\n            }\n        }\n    }\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Allocate room for and copy the non-standard sampling rate into the specified\n// metadata structure. We normally store the lower 3 bytes of the sampling rate,\n// unless 4 bytes are required (introduced in version 5). Note that this would\n// only be used when the sampling rate was not included in the table of 15\n// &quot;standard&quot; values.\n\nstatic void write_sample_rate (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    char *byteptr;\n\n    byteptr = wpmd-&gt;data = malloc (4);\n    wpmd-&gt;id = ID_SAMPLE_RATE;\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.sample_rate);\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.sample_rate &gt;&gt; 8);\n    *byteptr++ = (char) (wps-&gt;wpc-&gt;config.sample_rate &gt;&gt; 16);\n\n    // handle 4-byte sampling rates for scientific applications, etc.\n\n    if (wps-&gt;wpc-&gt;config.sample_rate &amp; 0x7f000000)\n        *byteptr++ = (char) (wps-&gt;wpc-&gt;config.sample_rate &gt;&gt; 24) &amp; 0x7f;\n\n    wpmd-&gt;byte_length = (int32_t)(byteptr - (char *) wpmd-&gt;data);\n}\n\n// Pack an entire block of samples (either mono or stereo) into a completed\n// WavPack block. This function is actually a shell for pack_samples() and\n// performs tasks like handling any shift required by the format, preprocessing\n// of floating point data or integer data over 24 bits wide, and implementing\n// the &quot;extra&quot; mode (via the extra?.c modules). It is assumed that there is\n// sufficient space for the completed block at &quot;wps-&gt;blockbuff&quot; and that\n// &quot;wps-&gt;blockend&quot; points to the end of the available space. A return value of\n// FALSE indicates an error.\n\nstatic int scan_int32_data (WavpackStream *wps, int32_t *values, int32_t num_values);\nstatic void scan_int32_quick (WavpackStream *wps, int32_t *values, int32_t num_values);\nstatic void send_int32_data (WavpackStream *wps, int32_t *values, int32_t num_values);\nstatic int scan_redundancy (int32_t *values, int32_t num_values);\nstatic int pack_samples (WavpackStream *wps, int32_t *buffer);\nstatic void bs_open_write (Bitstream *bs, void *buffer_start, void *buffer_end);\nstatic uint32_t bs_close_write (Bitstream *bs);\n\nint pack_block (WavpackStream *wps, int32_t *buffer)\n{\n    uint32_t flags = wps-&gt;wphdr.flags, sflags = wps-&gt;wphdr.flags;\n    int32_t sample_count = wps-&gt;wphdr.block_samples, *orig_data = NULL;\n    int dynamic_shaping_done = FALSE;\n\n    // This is done first because this code can potentially change the size of the block about to\n    // be encoded. This can happen because the dynamic noise shaping algorithm wants to send a\n    // shorter block because the desired noise-shaping profile is changing quickly. It can also\n    // be that the --merge-blocks feature wants to create a longer block because it combines areas\n    // with equal redundancy. These are not applicable for anything besides the first stream of\n    // the file and they are not applicable with float data or &gt;24-bit data.\n\n    if (!wps-&gt;stream_index &amp;&amp; !(flags &amp; FLOAT_DATA) &amp;&amp; (flags &amp; MAG_MASK) &gt;&gt; MAG_LSB &lt; 24) {\n        if ((wps-&gt;wpc-&gt;config.flags &amp; CONFIG_DYNAMIC_SHAPING) &amp;&amp; !wps-&gt;wpc-&gt;config.block_samples) {\n            dynamic_noise_shaping (wps, buffer, TRUE);\n            sample_count = wps-&gt;wphdr.block_samples;\n            dynamic_shaping_done = TRUE;\n        }\n        else if (wps-&gt;wpc-&gt;block_boundary &amp;&amp; sample_count &gt;= (int32_t) wps-&gt;wpc-&gt;block_boundary * 2) {\n            int bc = sample_count / wps-&gt;wpc-&gt;block_boundary, chans = (flags &amp; MONO_DATA) ? 1 : 2;\n            int res = scan_redundancy (buffer, wps-&gt;wpc-&gt;block_boundary * chans), i;\n\n            for (i = 1; i &lt; bc; ++i)\n                if (res != scan_redundancy (buffer + (i * wps-&gt;wpc-&gt;block_boundary * chans),\n                    wps-&gt;wpc-&gt;block_boundary * chans)) {\n                        sample_count = wps-&gt;wphdr.block_samples = wps-&gt;wpc-&gt;block_boundary * i;\n                        break;\n                    }\n        }\n    }\n\n    // This code scans stereo data to check whether it can be stored as mono data\n    // (i.e., all L/R samples identical). Only available with MAX_STREAM_VERS.\n\n    if (!(flags &amp; MONO_FLAG) &amp;&amp; wps-&gt;wpc-&gt;stream_version == MAX_STREAM_VERS) {\n        int32_t lor = 0, diff = 0;\n        int32_t *sptr, *dptr, i;\n\n        for (sptr = buffer, i = 0; i &lt; (int32_t) sample_count; sptr += 2, i++) {\n            lor |= sptr [0] | sptr [1];\n            diff |= sptr [0] ^ sptr [1];\n\n            if (lor &amp;&amp; diff)\n                break;\n        }\n\n        if (i == sample_count &amp;&amp; lor &amp;&amp; !diff) {\n            flags &amp;= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps-&gt;wphdr.flags = flags |= FALSE_STEREO;\n            dptr = buffer;\n            sptr = buffer;\n\n            for (i = sample_count; i--; sptr++)\n                *dptr++ = *sptr++;\n\n            if (!wps-&gt;false_stereo) {\n                wps-&gt;false_stereo = 1;\n                wps-&gt;num_terms = 0;\n                init_words (wps);\n            }\n        }\n        else if (wps-&gt;false_stereo) {\n            wps-&gt;false_stereo = 0;\n            wps-&gt;num_terms = 0;\n            init_words (wps);\n        }\n    }\n\n    // This is where we handle any fixed shift which occurs when the integer size does not evenly fit\n    // in bytes (like 12-bit or 20-bit) and is the same for the entire file (not based on scanning)\n\n    if (flags &amp; SHIFT_MASK) {\n        int shift = (flags &amp; SHIFT_MASK) &gt;&gt; SHIFT_LSB;\n        int mag = (flags &amp; MAG_MASK) &gt;&gt; MAG_LSB;\n        uint32_t cnt = sample_count;\n        int32_t *ptr = buffer;\n\n        if (flags &amp; MONO_DATA)\n            while (cnt--)\n                *ptr++ &gt;&gt;= shift;\n        else\n            while (cnt--) {\n                *ptr++ &gt;&gt;= shift;\n                *ptr++ &gt;&gt;= shift;\n            }\n\n        if ((mag -= shift) &lt; 0)\n            flags &amp;= ~MAG_MASK;\n        else\n            flags -= (1 &lt;&lt; MAG_LSB) * shift;\n\n        wps-&gt;wphdr.flags = flags;\n    }\n\n    // The regular WavPack decorrelation and entropy encoding can handle up to 24-bit integer data. If\n    // we have float data or integers larger than 24-bit, then we have to potentially do extra processing.\n    // For lossy encoding, we can simply convert this data in-place to 24-bit data and encode and sent\n    // that, along with some metadata about how to restore the original format (even if the restoration\n    // is not exact). However, for lossless operation we must make a copy of the original data that will\n    // be used to create a &quot;extension stream&quot; that will allow verbatim restoration of the original data.\n    // In the hybrid mode that extension goes in the correction file, otherwise it goes in the mail file.\n\n    if ((flags &amp; FLOAT_DATA) || (flags &amp; MAG_MASK) &gt;&gt; MAG_LSB &gt;= 24) {      // if float data or &gt;24-bit integers...\n\n        // if lossless we have to copy the data to use later...\n\n        if ((!(flags &amp; HYBRID_FLAG) || wps-&gt;wpc-&gt;wvc_flag) &amp;&amp; !(wps-&gt;wpc-&gt;config.flags &amp; CONFIG_SKIP_WVX)) {\n            orig_data = malloc (sizeof (f32) * ((flags &amp; MONO_DATA) ? sample_count : sample_count * 2));\n            memcpy (orig_data, buffer, sizeof (f32) * ((flags &amp; MONO_DATA) ? sample_count : sample_count * 2));\n\n            if (flags &amp; FLOAT_DATA) {                                       // if lossless float data come here\n                wps-&gt;float_norm_exp = wps-&gt;wpc-&gt;config.float_norm_exp;\n\n                if (!scan_float_data (wps, (f32 *) buffer, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2)) {\n                    free (orig_data);\n                    orig_data = NULL;\n                }\n            }\n            else {                                                          // otherwise lossless &gt; 24-bit integers\n                if (!scan_int32_data (wps, buffer, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2)) {\n                    free (orig_data);\n                    orig_data = NULL;\n                }\n            }\n        }\n        else {                                                              // otherwise, we&#x27;re lossy, so no copy\n            if (flags &amp; FLOAT_DATA) {\n                wps-&gt;float_norm_exp = wps-&gt;wpc-&gt;config.float_norm_exp;\n\n                if (scan_float_data (wps, (f32 *) buffer, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2))\n                    wps-&gt;lossy_blocks = TRUE;\n            }\n            else if (scan_int32_data (wps, buffer, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2))\n                wps-&gt;lossy_blocks = TRUE;\n        }\n\n        // if there&#x27;s any chance of magnitude change, clear the noise-shaping error term\n        // and also reset the entropy encoder (which this does)\n\n        wps-&gt;dc.error [0] = wps-&gt;dc.error [1] = 0;\n        wps-&gt;num_terms = 0;\n    }\n    // if 24-bit integers or less we do a &quot;quick&quot; scan which just scans for redundancy and does NOT set the flag&#x27;s &quot;magnitude&quot; value\n    else {\n        scan_int32_quick (wps, buffer, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2);\n\n        if (wps-&gt;shift != wps-&gt;int32_zeros + wps-&gt;int32_ones + wps-&gt;int32_dups) {   // detect a change in any redundancy shifting here\n            wps-&gt;shift = wps-&gt;int32_zeros + wps-&gt;int32_ones + wps-&gt;int32_dups;\n            wps-&gt;dc.error [0] = wps-&gt;dc.error [1] = 0;                              // on a change, clear the noise-shaping error term and\n            wps-&gt;num_terms = 0;                                                     // also reset the entropy encoder (which this does)\n        }\n    }\n\n    if ((wps-&gt;wpc-&gt;config.flags &amp; CONFIG_DYNAMIC_SHAPING) &amp;&amp; !dynamic_shaping_done)      // calculate dynamic noise profile\n        dynamic_noise_shaping (wps, buffer, FALSE);\n\n    // In some cases we need to start the decorrelation and entropy encoding from scratch. This\n    // could be because we switched from stereo to mono encoding or because the magnitude of\n    // the data changed, or just because this is the first block.\n\n    if (!wps-&gt;num_passes &amp;&amp; !wps-&gt;num_terms) {\n        wps-&gt;num_passes = 1;\n\n        if (flags &amp; MONO_DATA)\n            execute_mono (wps, buffer, 1, 0);\n        else\n            execute_stereo (wps, buffer, 1, 0);\n\n        wps-&gt;num_passes = 0;\n    }\n\n    // actually pack the block here and return on an error (which pretty much can only be a block buffer overrun)\n\n    if (!pack_samples (wps, buffer)) {\n        wps-&gt;wphdr.flags = sflags;\n\n        if (orig_data)\n            free (orig_data);\n\n        return FALSE;\n    }\n    else\n        wps-&gt;wphdr.flags = sflags;\n\n    // potentially move any unused dynamic noise shaping profile data to use next time\n\n    if (wps-&gt;dc.shaping_data) {\n        if (wps-&gt;dc.shaping_samples != sample_count)\n            memmove (wps-&gt;dc.shaping_data, wps-&gt;dc.shaping_data + sample_count,\n                (wps-&gt;dc.shaping_samples - sample_count) * sizeof (*wps-&gt;dc.shaping_data));\n\n        wps-&gt;dc.shaping_samples -= sample_count;\n    }\n\n    // finally, if we&#x27;re doing lossless float data or lossless &gt;24-bit integers, this is where we take the\n    // original data that we saved earlier and create the &quot;extension&quot; stream containing the information\n    // required to refine the &quot;lossy&quot; 24-bit data into the lossless original\n\n    if (orig_data) {\n        uint32_t data_count;\n        unsigned char *cptr;\n\n        if (wps-&gt;wpc-&gt;wvc_flag)\n            cptr = wps-&gt;block2buff + ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize + 8;\n        else\n            cptr = wps-&gt;blockbuff + ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize + 8;\n\n        bs_open_write (&amp;wps-&gt;wvxbits, cptr + 8, wps-&gt;wpc-&gt;wvc_flag ? wps-&gt;block2end : wps-&gt;blockend);\n\n        if (flags &amp; FLOAT_DATA)\n            send_float_data (wps, (f32*) orig_data, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2);\n        else\n            send_int32_data (wps, orig_data, (flags &amp; MONO_DATA) ? sample_count : sample_count * 2);\n\n        data_count = bs_close_write (&amp;wps-&gt;wvxbits);\n        free (orig_data);\n\n        if (data_count) {\n            if (data_count != (uint32_t) -1) {\n                if ((wps-&gt;wpc-&gt;config.flags &amp; CONFIG_OPTIMIZE_32BIT) &amp;&amp; !(flags &amp; FLOAT_DATA))\n                    *cptr++ = ID_WVX_NEW_BITSTREAM | ID_LARGE;\n                else\n                    *cptr++ = ID_WVX_BITSTREAM | ID_LARGE;\n\n                *cptr++ = (data_count += 4) &gt;&gt; 1;\n                *cptr++ = data_count &gt;&gt; 9;\n                *cptr++ = data_count &gt;&gt; 17;\n                *cptr++ = wps-&gt;crc_x;\n                *cptr++ = wps-&gt;crc_x &gt;&gt; 8;\n                *cptr++ = wps-&gt;crc_x &gt;&gt; 16;\n                *cptr = wps-&gt;crc_x &gt;&gt; 24;\n\n                if (wps-&gt;wpc-&gt;wvc_flag)\n                    ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize += data_count + 4;\n                else\n                    ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize += data_count + 4;\n            }\n            else\n                return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n// Quickly scan a buffer of long integer data and determine whether any\n// redundancy in the LSBs can be used to reduce the data&#x27;s magnitude. If yes,\n// then the INT32_DATA flag is set and the int32 parameters are set. This\n// version is designed to terminate as soon as it figures out that no\n// redundancy is available so that it can be used for all files.\n\nstatic void scan_int32_quick (WavpackStream *wps, int32_t *values, int32_t num_values)\n{\n    uint32_t magdata = 0, ordata = 0, xordata = 0, anddata = ~0;\n    int total_shift = 0;\n    int32_t *dp, count;\n\n    wps-&gt;int32_sent_bits = wps-&gt;int32_zeros = wps-&gt;int32_ones = wps-&gt;int32_dups = 0;\n\n    for (dp = values, count = num_values; count--; dp++) {\n        magdata |= (*dp &lt; 0) ? ~*dp : *dp;\n        xordata |= *dp ^ -(*dp &amp; 1);\n        anddata &amp;= *dp;\n        ordata |= *dp;\n\n        if ((ordata &amp; 1) &amp;&amp; !(anddata &amp; 1) &amp;&amp; (xordata &amp; 2))\n            return;\n    }\n\n    wps-&gt;wphdr.flags &amp;= ~MAG_MASK;\n\n    while (magdata) {\n        wps-&gt;wphdr.flags += 1 &lt;&lt; MAG_LSB;\n        magdata &gt;&gt;= 1;\n    }\n\n    if (!(wps-&gt;wphdr.flags &amp; MAG_MASK))\n        return;\n\n    if (!(ordata &amp; 1))\n        while (!(ordata &amp; 1)) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_zeros++;\n            total_shift++;\n            ordata &gt;&gt;= 1;\n        }\n    else if (anddata &amp; 1)\n        while (anddata &amp; 1) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_ones++;\n            total_shift++;\n            anddata &gt;&gt;= 1;\n        }\n    else if (!(xordata &amp; 2))\n        while (!(xordata &amp; 2)) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_dups++;\n            total_shift++;\n            xordata &gt;&gt;= 1;\n        }\n\n    if (total_shift) {\n        wps-&gt;wphdr.flags |= INT32_DATA;\n\n        for (dp = values, count = num_values; count--; dp++)\n            *dp &gt;&gt;= total_shift;\n    }\n}\n\nstatic int scan_redundancy (int32_t *values, int32_t num_values)\n{\n    uint32_t ordata = 0, xordata = 0, anddata = ~0;\n    int redundant_bits = 0;\n    int32_t *dp, count;\n\n    for (dp = values, count = num_values; count--; dp++) {\n        xordata |= *dp ^ -(*dp &amp; 1);\n        anddata &amp;= *dp;\n        ordata |= *dp;\n\n        if ((ordata &amp; 1) &amp;&amp; !(anddata &amp; 1) &amp;&amp; (xordata &amp; 2))\n            return 0;\n    }\n\n    if (!ordata || anddata == ~0 || !xordata)\n        return 0;\n\n    if (!(ordata &amp; 1))\n        while (!(ordata &amp; 1)) {\n            redundant_bits++;\n            ordata &gt;&gt;= 1;\n        }\n    else if (anddata &amp; 1)\n        while (anddata &amp; 1) {\n            redundant_bits = (redundant_bits + 1) | 0x40;\n            anddata &gt;&gt;= 1;\n        }\n    else if (!(xordata &amp; 2))\n        while (!(xordata &amp; 2)) {\n            redundant_bits = (redundant_bits + 1) | 0x80;\n            redundant_bits++;\n            xordata &gt;&gt;= 1;\n        }\n\n    return redundant_bits;\n}\n\n// Scan a buffer of long integer data and determine whether any redundancy in\n// the LSBs can be used to reduce the data&#x27;s magnitude. If yes, then the\n// INT32_DATA flag is set and the int32 parameters are set. If bits must still\n// be transmitted literally to get down to 24 bits (which is all the integer\n// compression code can handle) then we return TRUE to indicate that a wvx\n// stream must be created in either lossless mode.\n\nstatic int scan_int32_data (WavpackStream *wps, int32_t *values, int32_t num_values)\n{\n    uint32_t magdata = 0, ordata = 0, xordata = 0, anddata = ~0;\n    uint32_t crc = 0xffffffff;\n    int total_shift = 0;\n    int32_t *dp, count;\n\n    wps-&gt;int32_sent_bits = wps-&gt;int32_zeros = wps-&gt;int32_ones = wps-&gt;int32_dups = 0;\n\n    for (dp = values, count = num_values; count--; dp++) {\n        crc = crc * 9 + (*dp &amp; 0xffff) * 3 + ((*dp &gt;&gt; 16) &amp; 0xffff);\n        magdata |= (*dp &lt; 0) ? ~*dp : *dp;\n        xordata |= *dp ^ -(*dp &amp; 1);\n        anddata &amp;= *dp;\n        ordata |= *dp;\n    }\n\n    wps-&gt;crc_x = crc;\n    wps-&gt;wphdr.flags &amp;= ~MAG_MASK;\n\n    while (magdata) {\n        wps-&gt;wphdr.flags += 1 &lt;&lt; MAG_LSB;\n        magdata &gt;&gt;= 1;\n    }\n\n    if (!((wps-&gt;wphdr.flags &amp; MAG_MASK) &gt;&gt; MAG_LSB)) {\n        wps-&gt;wphdr.flags &amp;= ~INT32_DATA;\n        return FALSE;\n    }\n\n    if (!(ordata &amp; 1))\n        while (!(ordata &amp; 1)) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_zeros++;\n            total_shift++;\n            ordata &gt;&gt;= 1;\n        }\n    else if (anddata &amp; 1)\n        while (anddata &amp; 1) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_ones++;\n            total_shift++;\n            anddata &gt;&gt;= 1;\n        }\n    else if (!(xordata &amp; 2))\n        while (!(xordata &amp; 2)) {\n            wps-&gt;wphdr.flags -= 1 &lt;&lt; MAG_LSB;\n            wps-&gt;int32_dups++;\n            total_shift++;\n            xordata &gt;&gt;= 1;\n        }\n\n    if (((wps-&gt;wphdr.flags &amp; MAG_MASK) &gt;&gt; MAG_LSB) &gt; 23) {\n        wps-&gt;int32_sent_bits = (unsigned char)(((wps-&gt;wphdr.flags &amp; MAG_MASK) &gt;&gt; MAG_LSB) - 23);\n        total_shift += wps-&gt;int32_sent_bits;\n        wps-&gt;wphdr.flags &amp;= ~MAG_MASK;\n        wps-&gt;wphdr.flags += 23 &lt;&lt; MAG_LSB;\n    }\n\n    if (total_shift) {\n        wps-&gt;wphdr.flags |= INT32_DATA;\n\n        for (dp = values, count = num_values; count--; dp++)\n            *dp &gt;&gt;= total_shift;\n    }\n\n    return wps-&gt;int32_sent_bits;\n}\n\n// For the specified buffer values and the int32 parameters stored in &quot;wps&quot;,\n// send the literal bits required to the &quot;wvxbits&quot; bitstream.\n\nstatic void send_int32_data (WavpackStream *wps, int32_t *values, int32_t num_values)\n{\n    int sent_bits = wps-&gt;int32_sent_bits, pre_shift;\n    int32_t mask = (1 &lt;&lt; sent_bits) - 1;\n\n    pre_shift = wps-&gt;int32_zeros + wps-&gt;int32_ones + wps-&gt;int32_dups;\n\n    if (sent_bits) {\n        int32_t count, *dp;\n        int max_width = 0;\n\n        for (dp = values, count = num_values; count--; dp++)\n            *dp &gt;&gt;= pre_shift;\n\n        if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_OPTIMIZE_32BIT) {\n            for (dp = values, count = num_values; count--; dp++)\n                if (*dp) {\n                    int32_t value = *dp, pvalue = value &lt; 0 ? ~value : value;\n                    int width = count_bits (pvalue);\n\n                    while (!(value &amp; 1)) {\n                        value &gt;&gt;= 1;\n                        width--;\n                    }\n\n                    if (width &gt; max_width &amp;&amp; (max_width = width) &gt;= sent_bits + 23) {\n                        max_width = 0;\n                        break;\n                    }\n                }\n\n            putbits (max_width, 5, &amp;wps-&gt;wvxbits);\n        }\n\n        if (max_width)\n            for (dp = values, count = num_values; count--; dp++) {\n                int32_t pvalue = *dp &lt; 0 ? ~*dp : *dp;\n                int width = count_bits (pvalue);\n                int bits_to_send = sent_bits;\n\n                if (width &lt;= max_width || (bits_to_send -= width - max_width) &gt; 0) {\n                    *dp = (*dp &gt;&gt; (sent_bits - bits_to_send)) &amp; ((1U &lt;&lt; bits_to_send) - 1);\n                    putbits (*dp, bits_to_send, &amp;wps-&gt;wvxbits);\n                }\n            }\n        else\n            for (dp = values, count = num_values; count--; dp++) {\n                int32_t value = *dp &amp; mask;\n                putbits (value, sent_bits, &amp;wps-&gt;wvxbits);\n            }\n    }\n}\n\n// Send any pending metadata (generally RIFF headers, MD5 sums, etc.)\n//\n// Note that this can ONLY be called with stream index 0 which is why\n// it&#x27;s safe to cast away the const from the WavpackContext pointer.\n\nvoid send_pending_metadata (WavpackStream *wps)\n{\n    WavpackContext *wpc = (WavpackContext *) wps-&gt;wpc;  // removes const!\n    WavpackMetadata *wpmdp = wpc-&gt;metadata;\n\n    while (wpc-&gt;metacount) {\n        copy_metadata (wpmdp, wps-&gt;blockbuff, wps-&gt;blockend);\n        wpc-&gt;metabytes -= wpmdp-&gt;byte_length;\n        free_metadata (wpmdp++);\n        wpc-&gt;metacount--;\n    }\n\n    free (wpc-&gt;metadata);\n    wpc-&gt;metadata = NULL;\n}\n\nvoid send_general_metadata (WavpackStream *wps)\n{\n    uint32_t flags = wps-&gt;wphdr.flags;\n    WavpackMetadata wpmd;\n\n    if ((flags &amp; SRATE_MASK) == SRATE_MASK &amp;&amp; wps-&gt;wpc-&gt;config.sample_rate != 44100) {\n        write_sample_rate (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n    }\n\n    if ((flags &amp; INITIAL_BLOCK) &amp;&amp;\n        (wps-&gt;wpc-&gt;config.num_channels &gt; 2 ||\n        wps-&gt;wpc-&gt;config.channel_mask != 0x5 - wps-&gt;wpc-&gt;config.num_channels)) {\n            write_channel_info (wps, &amp;wpmd);\n            copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n            free_metadata (&amp;wpmd);\n\n            if (wps-&gt;wpc-&gt;channel_identities) {\n                write_channel_identities_info (wps, &amp;wpmd);\n                copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n                free_metadata (&amp;wpmd);\n            }\n    }\n\n    if ((flags &amp; INITIAL_BLOCK) &amp;&amp; !wps-&gt;sample_index) {\n        write_config_info (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n    }\n\n    if (flags &amp; INITIAL_BLOCK) {\n        write_new_config_info (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n    }\n}\n\n// Pack an entire block of samples (either mono or stereo) into a completed\n// WavPack block. It is assumed that there is sufficient space for the\n// completed block at &quot;wps-&gt;blockbuff&quot; and that &quot;wps-&gt;blockend&quot; points to the\n// end of the available space. A return value of FALSE indicates an error.\n// Any unsent metadata is transmitted first, then required metadata for this\n// block is sent, and finally the compressed integer data is sent. If a &quot;wpx&quot;\n// stream is required for floating point data or large integer data, then this\n// must be handled outside this function. To find out how much data was written\n// the caller must look at the ckSize field of the written WavpackHeader, NOT\n// the one in the WavpackStream.\n\n#ifdef OPT_ASM_X86\n    #define DECORR_STEREO_PASS(a,b,c) do {              \\\n        if (pack_cpu_has_feature_x86 (CPU_FEATURE_MMX)) \\\n            pack_decorr_stereo_pass_x86 (a, b, c);      \\\n        else decorr_stereo_pass (a, b, c); } while (0)\n    #define DECORR_MONO_BUFFER pack_decorr_mono_buffer_x86\n    #define SCAN_MAX_MAGNITUDE(a,b)                     \\\n        (pack_cpu_has_feature_x86 (CPU_FEATURE_MMX) ?   \\\n            scan_max_magnitude_x86 (a, b) :             \\\n            scan_max_magnitude (a, b))\n#elif defined(OPT_ASM_X64) &amp;&amp; (defined (_WIN64) || defined(__CYGWIN__) || defined(__MINGW64__) || defined(__midipix__))\n    #define DECORR_STEREO_PASS pack_decorr_stereo_pass_x64win\n    #define DECORR_MONO_BUFFER pack_decorr_mono_buffer_x64win\n    #define SCAN_MAX_MAGNITUDE scan_max_magnitude_x64win\n#elif defined(OPT_ASM_X64)\n    #define DECORR_STEREO_PASS pack_decorr_stereo_pass_x64\n    #define DECORR_MONO_BUFFER pack_decorr_mono_buffer_x64\n    #define SCAN_MAX_MAGNITUDE scan_max_magnitude_x64\n#else\n    #define DECORR_STEREO_PASS decorr_stereo_pass\n    #define DECORR_MONO_BUFFER decorr_mono_buffer\n    #define SCAN_MAX_MAGNITUDE scan_max_magnitude\n#endif\n\nuint32_t ASMCALL DECORR_MONO_BUFFER (int32_t *buffer, struct decorr_pass *decorr_passes, int32_t num_terms, int32_t sample_count);\n\n#ifdef OPT_ASM_X86\nvoid decorr_stereo_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count);\nvoid ASMCALL pack_decorr_stereo_pass_x86 (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count);\nuint32_t scan_max_magnitude (int32_t *values, int32_t num_values);\nuint32_t ASMCALL scan_max_magnitude_x86 (int32_t *values, int32_t num_values);\n#else\nvoid DECORR_STEREO_PASS (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count);\nuint32_t SCAN_MAX_MAGNITUDE (int32_t *values, int32_t num_values);\n#endif\n\n// This macro controls the &quot;repack&quot; function where a block of samples will be repacked with\n// fewer terms if a single residual exceeds the specified magnitude threshold.\n\n#define REPACK_SAFE_NUM_TERMS 5                 // 5 terms is always okay (and we truncate to this)\n\nstatic int pack_samples (WavpackStream *wps, int32_t *buffer)\n{\n    WavpackStream saved_stream;\n    uint32_t flags = wps-&gt;wphdr.flags, repack_possible, data_count, crc, crc2, i;\n    uint32_t sample_count = wps-&gt;wphdr.block_samples, repack_mask;\n    int32_t *bptr, *saved_buffer = NULL;\n    struct decorr_pass *dpp;\n    WavpackMetadata wpmd;\n\n    crc = crc2 = 0xffffffff;\n\n    if (!(flags &amp; HYBRID_FLAG) &amp;&amp; (flags &amp; MONO_DATA)) {\n        int32_t *eptr = buffer + sample_count;\n\n        for (bptr = buffer; bptr &lt; eptr;)\n            crc += (crc &lt;&lt; 1) + *bptr++;\n\n        if (wps-&gt;num_passes)\n            execute_mono (wps, buffer, !wps-&gt;num_terms, 1);\n    }\n    else if (!(flags &amp; HYBRID_FLAG) &amp;&amp; !(flags &amp; MONO_DATA)) {\n        int32_t *eptr = buffer + (sample_count * 2);\n\n        for (bptr = buffer; bptr &lt; eptr; bptr += 2)\n            crc += (crc &lt;&lt; 3) + ((uint32_t)bptr [0] &lt;&lt; 1) + bptr [0] + bptr [1];\n\n        if (wps-&gt;num_passes) {\n            execute_stereo (wps, buffer, !wps-&gt;num_terms, 1);\n            flags = wps-&gt;wphdr.flags;\n        }\n    }\n    else if ((flags &amp; HYBRID_FLAG) &amp;&amp; (flags &amp; MONO_DATA)) {\n        if (wps-&gt;num_passes)\n            execute_mono (wps, buffer, !wps-&gt;num_terms, 0);\n    }\n    else if ((flags &amp; HYBRID_FLAG) &amp;&amp; !(flags &amp; MONO_DATA)) {\n        if (wps-&gt;num_passes) {\n            execute_stereo (wps, buffer, !wps-&gt;num_terms, 0);\n            flags = wps-&gt;wphdr.flags;\n        }\n    }\n\n    wps-&gt;wphdr.ckSize = sizeof (WavpackHeader) - 8;\n    memcpy (wps-&gt;blockbuff, &amp;wps-&gt;wphdr, sizeof (WavpackHeader));\n\n    if (!wps-&gt;stream_index &amp;&amp; wps-&gt;wpc-&gt;metacount)\n        send_pending_metadata (wps);\n\n    if (!sample_count)\n        return TRUE;\n\n    memcpy (&amp;wps-&gt;wphdr, wps-&gt;blockbuff, sizeof (WavpackHeader));\n    repack_possible = !wps-&gt;num_passes &amp;&amp; wps-&gt;num_terms &gt; REPACK_SAFE_NUM_TERMS;\n    repack_mask = (flags &amp; MAG_MASK) &gt;&gt; MAG_LSB &gt;= 16 ? 0xF0000000 : 0xFFF00000;\n    saved_stream = *wps;\n\n    if (repack_possible &amp;&amp; !(flags &amp; HYBRID_FLAG)) {\n        saved_buffer = malloc (sample_count * sizeof (int32_t) * (flags &amp; MONO_DATA ? 1 : 2));\n        memcpy (saved_buffer, buffer, sample_count * sizeof (int32_t) * (flags &amp; MONO_DATA ? 1 : 2));\n    }\n\n    // This code is written as a loop, but in the overwhelming majority of cases it executes only once.\n    // If one of the higher modes is being used and a residual exceeds a certain threshold, then the\n    // block will be repacked using fewer decorrelation terms. Note that this has only been triggered\n    // by pathological audio samples designed to trigger it...in practice this might never happen. Note\n    // that this only applies to the &quot;high&quot; and &quot;very high&quot; modes and only when packing directly\n    // (i.e. without the &quot;extra&quot; modes that will have already checked magnitude).\n\n    do {\n        short *shaping_array = wps-&gt;dc.shaping_array;\n        int tcount, lossy = FALSE, m = 0;\n        double noise_acc = 0.0, noise;\n        uint32_t max_magnitude = 0;\n\n        write_decorr_terms (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n\n        write_decorr_weights (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n\n        write_decorr_samples (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n\n        write_entropy_vars (wps, &amp;wpmd);\n        copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n        free_metadata (&amp;wpmd);\n\n        if (flags &amp; HYBRID_FLAG) {\n            write_hybrid_profile (wps, &amp;wpmd);\n            copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n            free_metadata (&amp;wpmd);\n        }\n\n        if (flags &amp; FLOAT_DATA) {\n            write_float_info (wps, &amp;wpmd);\n            copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n            free_metadata (&amp;wpmd);\n        }\n\n        if (flags &amp; INT32_DATA) {\n            write_int32_info (wps, &amp;wpmd);\n            copy_metadata (&amp;wpmd, wps-&gt;blockbuff, wps-&gt;blockend);\n            free_metadata (&amp;wpmd);\n        }\n\n        send_general_metadata (wps);\n        bs_open_write (&amp;wps-&gt;wvbits, wps-&gt;blockbuff + ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize + 12, wps-&gt;blockend);\n\n        if (wps-&gt;wpc-&gt;wvc_flag) {\n            wps-&gt;wphdr.ckSize = sizeof (WavpackHeader) - 8;\n            memcpy (wps-&gt;block2buff, &amp;wps-&gt;wphdr, sizeof (WavpackHeader));\n\n            if (flags &amp; HYBRID_SHAPE) {\n                write_shaping_info (wps, &amp;wpmd);\n                copy_metadata (&amp;wpmd, wps-&gt;block2buff, wps-&gt;block2end);\n                free_metadata (&amp;wpmd);\n            }\n\n            bs_open_write (&amp;wps-&gt;wvcbits, wps-&gt;block2buff + ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize + 12, wps-&gt;block2end);\n        }\n\n        /////////////////////// handle lossless mono mode /////////////////////////\n\n        if (!(flags &amp; HYBRID_FLAG) &amp;&amp; (flags &amp; MONO_DATA)) {\n            if (!wps-&gt;num_passes) {\n                max_magnitude = DECORR_MONO_BUFFER (buffer, wps-&gt;decorr_passes, wps-&gt;num_terms, sample_count);\n                m = sample_count &amp; (MAX_TERM - 1);\n            }\n\n            send_words_lossless (wps, buffer, sample_count);\n        }\n\n        //////////////////// handle the lossless stereo mode //////////////////////\n\n        else if (!(flags &amp; HYBRID_FLAG) &amp;&amp; !(flags &amp; MONO_DATA)) {\n            if (!wps-&gt;num_passes) {\n                if (flags &amp; JOINT_STEREO) {\n                    int32_t *eptr = buffer + (sample_count * 2);\n\n                    for (bptr = buffer; bptr &lt; eptr; bptr += 2)\n                        bptr [1] += ((bptr [0] -= bptr [1]) &gt;&gt; 1);\n                }\n\n                for (tcount = wps-&gt;num_terms, dpp = wps-&gt;decorr_passes; tcount-- ; dpp++)\n                    DECORR_STEREO_PASS (dpp, buffer, sample_count);\n\n                m = sample_count &amp; (MAX_TERM - 1);\n\n                if (repack_possible)\n                    max_magnitude = SCAN_MAX_MAGNITUDE (buffer, sample_count * 2);\n            }\n\n            send_words_lossless (wps, buffer, sample_count);\n        }\n\n        /////////////////// handle the lossy/hybrid mono mode /////////////////////\n\n        else if ((flags &amp; HYBRID_FLAG) &amp;&amp; (flags &amp; MONO_DATA))\n            for (bptr = buffer, i = 0; i &lt; sample_count; ++i) {\n                int32_t code, temp;\n                int shaping_weight;\n\n                crc2 += (crc2 &lt;&lt; 1) + (code = *bptr++);\n\n                if (flags &amp; HYBRID_SHAPE) {\n                    if (shaping_array)\n                        shaping_weight = *shaping_array++;\n                    else\n                        shaping_weight = (wps-&gt;dc.shaping_acc [0] += wps-&gt;dc.shaping_delta [0]) &gt;&gt; 16;\n\n                    temp = -apply_weight (shaping_weight, wps-&gt;dc.error [0]);\n\n                    if ((flags &amp; NEW_SHAPING) &amp;&amp; shaping_weight &lt; 0 &amp;&amp; temp) {\n                        if (temp == wps-&gt;dc.error [0])\n                            temp = (temp &lt; 0) ? temp + 1 : temp - 1;\n\n                        wps-&gt;dc.error [0] = -code;\n                        code += temp;\n                    }\n                    else\n                        wps-&gt;dc.error [0] = -(code += temp);\n                }\n\n                for (tcount = wps-&gt;num_terms, dpp = wps-&gt;decorr_passes; tcount-- ; dpp++)\n                    if (dpp-&gt;term &gt; MAX_TERM) {\n                        if (dpp-&gt;term &amp; 1)\n                            dpp-&gt;samples_A [2] = 2 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1];\n                        else\n                            dpp-&gt;samples_A [2] = (3 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1]) &gt;&gt; 1;\n\n                        code -= (dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [2]));\n                    }\n                    else\n                        code -= (dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [m]));\n\n                max_magnitude |= (code &lt; 0 ? ~code : code);\n                code = send_word (wps, code, 0);\n\n                while (--dpp &gt;= wps-&gt;decorr_passes) {\n                    if (dpp-&gt;term &gt; MAX_TERM) {\n                        update_weight (dpp-&gt;weight_A, dpp-&gt;delta, dpp-&gt;samples_A [2], code);\n                        dpp-&gt;samples_A [1] = dpp-&gt;samples_A [0];\n                        dpp-&gt;samples_A [0] = (code += dpp-&gt;aweight_A);\n                    }\n                    else {\n                        int32_t sam = dpp-&gt;samples_A [m];\n\n                        update_weight (dpp-&gt;weight_A, dpp-&gt;delta, sam, code);\n                        dpp-&gt;samples_A [(m + dpp-&gt;term) &amp; (MAX_TERM - 1)] = (code += dpp-&gt;aweight_A);\n                    }\n                }\n\n                wps-&gt;dc.error [0] += code;\n                m = (m + 1) &amp; (MAX_TERM - 1);\n\n                if ((crc += (crc &lt;&lt; 1) + code) != crc2)\n                    lossy = TRUE;\n\n                if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_CALC_NOISE) {\n                    noise = code - bptr [-1];\n\n                    noise_acc += noise *= noise;\n                    wps-&gt;dc.noise_ave = (wps-&gt;dc.noise_ave * 0.99) + (noise * 0.01);\n\n                    if (wps-&gt;dc.noise_ave &gt; wps-&gt;dc.noise_max)\n                        wps-&gt;dc.noise_max = wps-&gt;dc.noise_ave;\n                }\n            }\n\n        /////////////////// handle the lossy/hybrid stereo mode ///////////////////\n\n        else if ((flags &amp; HYBRID_FLAG) &amp;&amp; !(flags &amp; MONO_DATA))\n            for (bptr = buffer, i = 0; i &lt; sample_count; ++i) {\n                int32_t left, right, temp;\n                int shaping_weight;\n\n                left = *bptr++;\n                crc2 += (crc2 &lt;&lt; 3) + ((uint32_t)left &lt;&lt; 1) + left + (right = *bptr++);\n\n                if (flags &amp; HYBRID_SHAPE) {\n                    if (shaping_array)\n                        shaping_weight = *shaping_array++;\n                    else\n                        shaping_weight = (wps-&gt;dc.shaping_acc [0] += wps-&gt;dc.shaping_delta [0]) &gt;&gt; 16;\n\n                    temp = -apply_weight (shaping_weight, wps-&gt;dc.error [0]);\n\n                    if ((flags &amp; NEW_SHAPING) &amp;&amp; shaping_weight &lt; 0 &amp;&amp; temp) {\n                        if (temp == wps-&gt;dc.error [0])\n                            temp = (temp &lt; 0) ? temp + 1 : temp - 1;\n\n                        wps-&gt;dc.error [0] = -left;\n                        left += temp;\n                    }\n                    else\n                        wps-&gt;dc.error [0] = -(left += temp);\n\n                    if (!shaping_array)\n                        shaping_weight = (wps-&gt;dc.shaping_acc [1] += wps-&gt;dc.shaping_delta [1]) &gt;&gt; 16;\n\n                    temp = -apply_weight (shaping_weight, wps-&gt;dc.error [1]);\n\n                    if ((flags &amp; NEW_SHAPING) &amp;&amp; shaping_weight &lt; 0 &amp;&amp; temp) {\n                        if (temp == wps-&gt;dc.error [1])\n                            temp = (temp &lt; 0) ? temp + 1 : temp - 1;\n\n                        wps-&gt;dc.error [1] = -right;\n                        right += temp;\n                    }\n                    else\n                        wps-&gt;dc.error [1] = -(right += temp);\n                }\n\n                if (flags &amp; JOINT_STEREO)\n                    right += ((left -= right) &gt;&gt; 1);\n\n                for (tcount = wps-&gt;num_terms, dpp = wps-&gt;decorr_passes; tcount-- ; dpp++)\n                    if (dpp-&gt;term &gt; MAX_TERM) {\n                        if (dpp-&gt;term &amp; 1) {\n                            dpp-&gt;samples_A [2] = 2 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1];\n                            dpp-&gt;samples_B [2] = 2 * dpp-&gt;samples_B [0] - dpp-&gt;samples_B [1];\n                        }\n                        else {\n                            dpp-&gt;samples_A [2] = (3 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1]) &gt;&gt; 1;\n                            dpp-&gt;samples_B [2] = (3 * dpp-&gt;samples_B [0] - dpp-&gt;samples_B [1]) &gt;&gt; 1;\n                        }\n\n                        left -= (dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [2]));\n                        right -= (dpp-&gt;aweight_B = apply_weight (dpp-&gt;weight_B, dpp-&gt;samples_B [2]));\n                    }\n                    else if (dpp-&gt;term &gt; 0) {\n                        left -= (dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [m]));\n                        right -= (dpp-&gt;aweight_B = apply_weight (dpp-&gt;weight_B, dpp-&gt;samples_B [m]));\n                    }\n                    else {\n                        if (dpp-&gt;term == -1)\n                            dpp-&gt;samples_B [0] = left;\n                        else if (dpp-&gt;term == -2)\n                            dpp-&gt;samples_A [0] = right;\n\n                        left -= (dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [0]));\n                        right -= (dpp-&gt;aweight_B = apply_weight (dpp-&gt;weight_B, dpp-&gt;samples_B [0]));\n                    }\n\n                max_magnitude |= (left &lt; 0 ? ~left : left) | (right &lt; 0 ? ~right : right);\n                left = send_word (wps, left, 0);\n                right = send_word (wps, right, 1);\n\n                while (--dpp &gt;= wps-&gt;decorr_passes)\n                    if (dpp-&gt;term &gt; MAX_TERM) {\n                        update_weight (dpp-&gt;weight_A, dpp-&gt;delta, dpp-&gt;samples_A [2], left);\n                        update_weight (dpp-&gt;weight_B, dpp-&gt;delta, dpp-&gt;samples_B [2], right);\n\n                        dpp-&gt;samples_A [1] = dpp-&gt;samples_A [0];\n                        dpp-&gt;samples_B [1] = dpp-&gt;samples_B [0];\n\n                        dpp-&gt;samples_A [0] = (left += dpp-&gt;aweight_A);\n                        dpp-&gt;samples_B [0] = (right += dpp-&gt;aweight_B);\n                    }\n                    else if (dpp-&gt;term &gt; 0) {\n                        int k = (m + dpp-&gt;term) &amp; (MAX_TERM - 1);\n\n                        update_weight (dpp-&gt;weight_A, dpp-&gt;delta, dpp-&gt;samples_A [m], left);\n                        dpp-&gt;samples_A [k] = (left += dpp-&gt;aweight_A);\n\n                        update_weight (dpp-&gt;weight_B, dpp-&gt;delta, dpp-&gt;samples_B [m], right);\n                        dpp-&gt;samples_B [k] = (right += dpp-&gt;aweight_B);\n                    }\n                    else {\n                        if (dpp-&gt;term == -1) {\n                            dpp-&gt;samples_B [0] = left + dpp-&gt;aweight_A;\n                            dpp-&gt;aweight_B = apply_weight (dpp-&gt;weight_B, dpp-&gt;samples_B [0]);\n                        }\n                        else if (dpp-&gt;term == -2) {\n                            dpp-&gt;samples_A [0] = right + dpp-&gt;aweight_B;\n                            dpp-&gt;aweight_A = apply_weight (dpp-&gt;weight_A, dpp-&gt;samples_A [0]);\n                        }\n\n                        update_weight_clip (dpp-&gt;weight_A, dpp-&gt;delta, dpp-&gt;samples_A [0], left);\n                        update_weight_clip (dpp-&gt;weight_B, dpp-&gt;delta, dpp-&gt;samples_B [0], right);\n                        dpp-&gt;samples_B [0] = (left += dpp-&gt;aweight_A);\n                        dpp-&gt;samples_A [0] = (right += dpp-&gt;aweight_B);\n                    }\n\n                if (flags &amp; JOINT_STEREO)\n                    left += (right -= (left &gt;&gt; 1));\n\n                wps-&gt;dc.error [0] += left;\n                wps-&gt;dc.error [1] += right;\n                m = (m + 1) &amp; (MAX_TERM - 1);\n\n                if ((crc += (crc &lt;&lt; 3) + ((uint32_t)left &lt;&lt; 1) + left + right) != crc2)\n                    lossy = TRUE;\n\n                if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_CALC_NOISE) {\n                    noise = (double)(left - bptr [-2]) * (left - bptr [-2]);\n                    noise += (double)(right - bptr [-1]) * (right - bptr [-1]);\n\n                    noise_acc += noise /= 2.0;\n                    wps-&gt;dc.noise_ave = (wps-&gt;dc.noise_ave * 0.99) + (noise * 0.01);\n\n                    if (wps-&gt;dc.noise_ave &gt; wps-&gt;dc.noise_max)\n                        wps-&gt;dc.noise_max = wps-&gt;dc.noise_ave;\n                }\n            }\n\n        if (m)\n            for (tcount = wps-&gt;num_terms, dpp = wps-&gt;decorr_passes; tcount--; dpp++)\n                if (dpp-&gt;term &gt; 0 &amp;&amp; dpp-&gt;term &lt;= MAX_TERM) {\n                    int32_t temp_A [MAX_TERM], temp_B [MAX_TERM];\n                    int k;\n\n                    memcpy (temp_A, dpp-&gt;samples_A, sizeof (dpp-&gt;samples_A));\n                    memcpy (temp_B, dpp-&gt;samples_B, sizeof (dpp-&gt;samples_B));\n\n                    for (k = 0; k &lt; MAX_TERM; k++) {\n                        dpp-&gt;samples_A [k] = temp_A [m];\n                        dpp-&gt;samples_B [k] = temp_B [m];\n                        m = (m + 1) &amp; (MAX_TERM - 1);\n                    }\n                }\n\n        if (wps-&gt;wpc-&gt;config.flags &amp; CONFIG_CALC_NOISE)\n            wps-&gt;dc.noise_sum += noise_acc;\n\n        flush_word (wps);\n        data_count = bs_close_write (&amp;wps-&gt;wvbits);\n\n        if (data_count) {\n            if (data_count != (uint32_t) -1) {\n                unsigned char *cptr = wps-&gt;blockbuff + ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize + 8;\n\n                *cptr++ = ID_WV_BITSTREAM | ID_LARGE;\n                *cptr++ = data_count &gt;&gt; 1;\n                *cptr++ = data_count &gt;&gt; 9;\n                *cptr++ = data_count &gt;&gt; 17;\n                ((WavpackHeader *) wps-&gt;blockbuff)-&gt;ckSize += data_count + 4;\n            }\n            else\n                return FALSE;\n        }\n\n        ((WavpackHeader *) wps-&gt;blockbuff)-&gt;crc = crc;\n\n        if (wps-&gt;wpc-&gt;wvc_flag) {\n            data_count = bs_close_write (&amp;wps-&gt;wvcbits);\n\n            if (data_count &amp;&amp; lossy) {\n                if (data_count != (uint32_t) -1) {\n                    unsigned char *cptr = wps-&gt;block2buff + ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize + 8;\n\n                    *cptr++ = ID_WVC_BITSTREAM | ID_LARGE;\n                    *cptr++ = data_count &gt;&gt; 1;\n                    *cptr++ = data_count &gt;&gt; 9;\n                    *cptr++ = data_count &gt;&gt; 17;\n                    ((WavpackHeader *) wps-&gt;block2buff)-&gt;ckSize += data_count + 4;\n                }\n                else\n                    return FALSE;\n            }\n\n            ((WavpackHeader *) wps-&gt;block2buff)-&gt;crc = crc2;\n        }\n        else if (lossy)\n            wps-&gt;lossy_blocks = TRUE;\n\n        // we&#x27;re done with the entire block, so now we check if our threshold for a &quot;repack&quot; was hit\n\n        if (repack_possible &amp;&amp; wps-&gt;num_terms &gt; REPACK_SAFE_NUM_TERMS &amp;&amp; (max_magnitude &amp; repack_mask)) {\n            *wps = saved_stream;\n            wps-&gt;num_terms = REPACK_SAFE_NUM_TERMS;\n            memcpy (wps-&gt;blockbuff, &amp;wps-&gt;wphdr, sizeof (WavpackHeader));\n\n            if (saved_buffer)\n                memcpy (buffer, saved_buffer, sample_count * sizeof (int32_t) * (flags &amp; MONO_DATA ? 1 : 2));\n\n            if (flags &amp; HYBRID_FLAG)\n                crc = crc2 = 0xffffffff;\n        }\n        else {\n            // if we actually did repack the block with fewer terms, we detect that here\n            // and clean up so that we return to the original term count...otherwise we just\n            // free the saved_buffer (if allocated) and break out of the loop\n            if (wps-&gt;num_terms != saved_stream.num_terms) {\n                int ti;\n\n                for (ti = wps-&gt;num_terms; ti &lt; saved_stream.num_terms; ++ti) {\n                    wps-&gt;decorr_passes [ti].weight_A = wps-&gt;decorr_passes [ti].weight_B = 0;\n                    CLEARA (wps-&gt;decorr_passes [ti].samples_A);\n                    CLEARA (wps-&gt;decorr_passes [ti].samples_B);\n                }\n\n                wps-&gt;num_terms = saved_stream.num_terms;\n            }\n\n            if (saved_buffer)\n                free (saved_buffer);\n\n            break;\n        }\n\n    } while (1);\n\n    return TRUE;\n}\n\n#if !defined(OPT_ASM_X64)\n\n// This is the &quot;C&quot; version of the stereo decorrelation pass function. There\n// are assembly optimized versions of this that can be used if available.\n// It performs a single pass of stereo decorrelation, in place, as specified\n// by the decorr_pass structure. Note that this function does NOT return the\n// dpp-&gt;samples_X[] values in the &quot;normalized&quot; positions for terms 1-8, so if\n// the number of samples is not a multiple of MAX_TERM, these must be moved if\n// they are to be used somewhere else.\n\nvoid decorr_stereo_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count)\n{\n    int32_t *bptr, *eptr = buffer + (sample_count * 2);\n    int m, k;\n\n    switch (dpp-&gt;term) {\n        case 17:\n            for (bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam, tmp;\n\n                sam = 2 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1];\n                dpp-&gt;samples_A [1] = dpp-&gt;samples_A [0];\n                bptr [0] = tmp = (dpp-&gt;samples_A [0] = bptr [0]) - apply_weight (dpp-&gt;weight_A, sam);\n                update_weight (dpp-&gt;weight_A, dpp-&gt;delta, sam, tmp);\n\n                sam = 2 * dpp-&gt;samples_B [0] - dpp-&gt;samples_B [1];\n                dpp-&gt;samples_B [1] = dpp-&gt;samples_B [0];\n                bptr [1] = tmp = (dpp-&gt;samples_B [0] = bptr [1]) - apply_weight (dpp-&gt;weight_B, sam);\n                update_weight (dpp-&gt;weight_B, dpp-&gt;delta, sam, tmp);\n            }\n\n            break;\n\n        case 18:\n            for (bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam, tmp;\n\n                sam = dpp-&gt;samples_A [0] + ((dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1]) &gt;&gt; 1);\n                dpp-&gt;samples_A [1] = dpp-&gt;samples_A [0];\n                bptr [0] = tmp = (dpp-&gt;samples_A [0] = bptr [0]) - apply_weight (dpp-&gt;weight_A, sam);\n                update_weight (dpp-&gt;weight_A, dpp-&gt;delta, sam, tmp);\n\n                sam = dpp-&gt;samples_B [0] + ((dpp-&gt;samples_B [0] - dpp-&gt;samples_B [1]) &gt;&gt; 1);\n                dpp-&gt;samples_B [1] = dpp-&gt;samples_B [0];\n                bptr [1] = tmp = (dpp-&gt;samples_B [0] = bptr [1]) - apply_weight (dpp-&gt;weight_B, sam);\n                update_weight (dpp-&gt;weight_B, dpp-&gt;delta, sam, tmp);\n            }\n\n            break;\n\n        default:\n            for (m = 0, k = dpp-&gt;term &amp; (MAX_TERM - 1), bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam, tmp;\n\n                sam = dpp-&gt;samples_A [m];\n                bptr [0] = tmp = (dpp-&gt;samples_A [k] = bptr [0]) - apply_weight (dpp-&gt;weight_A, sam);\n                update_weight (dpp-&gt;weight_A, dpp-&gt;delta, sam, tmp);\n\n                sam = dpp-&gt;samples_B [m];\n                bptr [1] = tmp = (dpp-&gt;samples_B [k] = bptr [1]) - apply_weight (dpp-&gt;weight_B, sam);\n                update_weight (dpp-&gt;weight_B, dpp-&gt;delta, sam, tmp);\n\n                m = (m + 1) &amp; (MAX_TERM - 1);\n                k = (k + 1) &amp; (MAX_TERM - 1);\n            }\n\n            break;\n\n        case -1:\n            for (bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam_A, sam_B, tmp;\n\n                sam_A = dpp-&gt;samples_A [0];\n                bptr [0] = tmp = (sam_B = bptr [0]) - apply_weight (dpp-&gt;weight_A, sam_A);\n                update_weight_clip (dpp-&gt;weight_A, dpp-&gt;delta, sam_A, tmp);\n\n                bptr [1] = tmp = (dpp-&gt;samples_A [0] = bptr [1]) - apply_weight (dpp-&gt;weight_B, sam_B);\n                update_weight_clip (dpp-&gt;weight_B, dpp-&gt;delta, sam_B, tmp);\n            }\n\n            break;\n\n        case -2:\n            for (bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam_A, sam_B, tmp;\n\n                sam_B = dpp-&gt;samples_B [0];\n                bptr [1] = tmp = (sam_A = bptr [1]) - apply_weight (dpp-&gt;weight_B, sam_B);\n                update_weight_clip (dpp-&gt;weight_B, dpp-&gt;delta, sam_B, tmp);\n\n                bptr [0] = tmp = (dpp-&gt;samples_B [0] = bptr [0]) - apply_weight (dpp-&gt;weight_A, sam_A);\n                update_weight_clip (dpp-&gt;weight_A, dpp-&gt;delta, sam_A, tmp);\n            }\n\n            break;\n\n        case -3:\n            for (bptr = buffer; bptr &lt; eptr; bptr += 2) {\n                int32_t sam_A, sam_B, tmp;\n\n                sam_A = dpp-&gt;samples_A [0];\n                sam_B = dpp-&gt;samples_B [0];\n\n                dpp-&gt;samples_A [0] = tmp = bptr [1];\n                bptr [1] = tmp -= apply_weight (dpp-&gt;weight_B, sam_B);\n                update_weight_clip (dpp-&gt;weight_B, dpp-&gt;delta, sam_B, tmp);\n\n                dpp-&gt;samples_B [0] = tmp = bptr [0];\n                bptr [0] = tmp -= apply_weight (dpp-&gt;weight_A, sam_A);\n                update_weight_clip (dpp-&gt;weight_A, dpp-&gt;delta, sam_A, tmp);\n            }\n\n            break;\n    }\n}\n\n// This is the &quot;C&quot; version of the magnitude scanning function. There are\n// assembly optimized versions of this that can be used if available. This\n// function scans a buffer of signed 32-bit ints and returns the magnitude\n// of the largest sample, with a power-of-two resolution. It might be more\n// useful to return the actual maximum absolute value (and this function\n// could do that without breaking anything), but that implementation would\n// likely be slower. Instead, this simply returns the &quot;or&quot; of all the\n// values &quot;xor&quot;d with their own sign.\n\nuint32_t scan_max_magnitude (int32_t *values, int32_t num_values)\n{\n    uint32_t magnitude = 0;\n\n    while (num_values--)\n        magnitude |= (*values &lt; 0) ? ~*values++ : *values++;\n\n    return magnitude;\n}\n\n#endif\n\n#if !defined(OPT_ASM_X86) &amp;&amp; !defined(OPT_ASM_X64)\n\n// This is the &quot;C&quot; version of the mono decorrelation pass function. There\n// are assembly optimized versions of this that are be used if available.\n// It decorrelates a buffer of mono samples, in place, as specified by the array\n// of decorr_pass structures. Note that this function does NOT return the\n// dpp-&gt;samples_X[] values in the &quot;normalized&quot; positions for terms 1-8, so if\n// the number of samples is not a multiple of MAX_TERM, these must be moved if\n// they are to be used somewhere else. The magnitude of the output samples is\n// accumulated and returned (see scan_max_magnitude() for more details).\n\nuint32_t decorr_mono_buffer (int32_t *buffer, struct decorr_pass *decorr_passes, int32_t num_terms, int32_t sample_count)\n{\n    uint32_t max_magnitude = 0;\n    struct decorr_pass *dpp;\n    int tcount, i;\n\n    for (i = 0; i &lt; sample_count; ++i) {\n        int32_t code = *buffer;\n\n        for (tcount = num_terms, dpp = decorr_passes; tcount--; dpp++) {\n            int32_t sam;\n\n            if (dpp-&gt;term &gt; MAX_TERM) {\n                if (dpp-&gt;term &amp; 1)\n                    sam = 2 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1];\n                else\n                    sam = (3 * dpp-&gt;samples_A [0] - dpp-&gt;samples_A [1]) &gt;&gt; 1;\n\n                dpp-&gt;samples_A [1] = dpp-&gt;samples_A [0];\n                dpp-&gt;samples_A [0] = code;\n            }\n            else {\n                sam = dpp-&gt;samples_A [i &amp; (MAX_TERM - 1)];\n                dpp-&gt;samples_A [(i + dpp-&gt;term) &amp; (MAX_TERM - 1)] = code;\n            }\n\n            code -= apply_weight (dpp-&gt;weight_A, sam);\n            update_weight (dpp-&gt;weight_A, dpp-&gt;delta, sam, code);\n        }\n\n        *buffer++ = code;\n        max_magnitude |= (code &lt; 0) ? ~code : code;\n    }\n\n    return max_magnitude;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n// This function returns the accumulated RMS noise as a double if the       //\n// CALC_NOISE bit was set in the WavPack header. The peak noise can also be //\n// returned if desired. See wavpack.c for the calculations required to      //\n// convert this into decibels of noise below full scale.                    //\n//////////////////////////////////////////////////////////////////////////////\n\ndouble WavpackGetEncodedNoise (WavpackContext *wpc, double *peak)\n{\n    WavpackStream *wps = wpc-&gt;streams [0];\n\n    if (peak)\n        *peak = wps-&gt;dc.noise_max;\n\n    return wps-&gt;dc.noise_sum;\n}\n\n// Open the specified BitStream using the specified buffer pointers. It is\n// assumed that enough buffer space has been allocated for all data that will\n// be written, otherwise an error will be generated.\n\nstatic void bs_write (Bitstream *bs);\n\nstatic void bs_open_write (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs-&gt;error = bs-&gt;sr = bs-&gt;bc = 0;\n    bs-&gt;ptr = bs-&gt;buf = buffer_start;\n    bs-&gt;end = buffer_end;\n    bs-&gt;wrap = bs_write;\n}\n\n// This function is only called from the putbit() and putbits() macros when\n// the buffer is full, which is now flagged as an error.\n\nstatic void bs_write (Bitstream *bs)\n{\n    bs-&gt;ptr = bs-&gt;buf;\n    bs-&gt;error = 1;\n}\n\n// This function forces a flushing write of the specified BitStream, and\n// returns the total number of bytes written into the buffer.\n\nstatic uint32_t bs_close_write (Bitstream *bs)\n{\n    uint32_t bytes_written;\n\n    if (bs-&gt;error)\n        return (uint32_t) -1;\n\n    while (1) {\n        while (bs-&gt;bc)\n            putbit_1 (bs);\n\n        bytes_written = (uint32_t)(bs-&gt;ptr - bs-&gt;buf) * sizeof (*(bs-&gt;ptr));\n\n        if (bytes_written &amp; 1) {\n            putbit_1 (bs);\n        }\n        else\n            break;\n    };\n\n    CLEAR (*bs);\n    return bytes_written;\n}\n"}, "/project/WavPack/src/tag_utils.c": {"id": "/project/WavPack/src/tag_utils.c", "filePath": "/project/WavPack/src/tag_utils.c", "content": "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// tag_utils.c\n\n// This module provides the high-level API for creating, reading and editing\n// APEv2 tags on WavPack files. Read-only support is also provided for ID3v1\n// tags, but their use is not recommended.\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &quot;wavpack_local.h&quot;\n\n#ifndef __WATCOMC__\n#ifdef _WIN32\n#define stricmp(x,y) _stricmp(x,y)\n#else\n#define stricmp strcasecmp\n#endif\n#endif\n\nstatic int get_ape_tag_item (M_Tag *m_tag, const char *item, char *value, int size, int type);\nstatic int get_id3_tag_item (M_Tag *m_tag, const char *item, char *value, int size);\nstatic int get_ape_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size, int type);\nstatic int get_id3_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size);\nstatic int append_ape_tag_item (WavpackContext *wpc, const char *item, const char *value, int vsize, int type);\nstatic int write_tag_blockout (WavpackContext *wpc);\nstatic int write_tag_reader (WavpackContext *wpc);\nstatic void tagcpy (char *dest, char *src, int tag_size);\nstatic int tagdata (char *src, int tag_size);\n\n//////////////////// Global functions part of external API /////////////////////////\n\n// Count and return the total number of tag items in the specified file.\n\nint WavpackGetNumTagItems (WavpackContext *wpc)\n{\n    int i = 0;\n\n    while (WavpackGetTagItemIndexed (wpc, i, NULL, 0))\n        ++i;\n\n    return i;\n}\n\n// Count and return the total number of binary tag items in the specified file. This applies\n// only to APEv2 tags and was implemented as a separate function to avoid breaking the old API.\n\nint WavpackGetNumBinaryTagItems (WavpackContext *wpc)\n{\n    int i = 0;\n\n    while (WavpackGetBinaryTagItemIndexed (wpc, i, NULL, 0))\n        ++i;\n\n    return i;\n}\n\n// Attempt to get the specified item from the specified file&#x27;s ID3v1 or APEv2\n// tag. The &quot;size&quot; parameter specifies the amount of space available at &quot;value&quot;,\n// if the desired item will not fit in this space then ellipses (...) will\n// be appended and the string terminated. Only text data are supported. The\n// actual length of the string is returned (or 0 if no matching value found).\n// Note that with APEv2 tags the length might not be the same as the number of\n// characters because UTF-8 encoding is used. Also, APEv2 tags can have multiple\n// (NULL separated) strings for a single value (this is why the length is\n// returned). If this function is called with a NULL &quot;value&quot; pointer (or a\n// zero &quot;length&quot;) then only the actual length of the value data is returned\n// (not counting the terminating NULL). This can be used to determine the\n// actual memory to be allocated beforehand.\n\nint WavpackGetTagItem (WavpackContext *wpc, const char *item, char *value, int size)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n\n    if (value &amp;&amp; size)\n        *value = 0;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;)\n        return get_ape_tag_item (m_tag, item, value, size, APE_TAG_TYPE_TEXT);\n    else if (m_tag-&gt;id3_tag.tag_id [0] == &#x27;T&#x27;)\n        return get_id3_tag_item (m_tag, item, value, size);\n    else\n        return 0;\n}\n\n// Attempt to get the specified binary item from the specified file&#x27;s APEv2\n// tag. The &quot;size&quot; parameter specifies the amount of space available at &quot;value&quot;.\n// If the desired item will not fit in this space then nothing will be copied\n// and 0 will be returned, otherwise the actual size will be returned. If this\n// function is called with a NULL &quot;value&quot; pointer (or a zero &quot;length&quot;) then only\n// the actual length of the value data is returned and can be used to determine\n// the actual memory to be allocated beforehand.\n\nint WavpackGetBinaryTagItem (WavpackContext *wpc, const char *item, char *value, int size)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n\n    if (value &amp;&amp; size)\n        *value = 0;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;)\n        return get_ape_tag_item (m_tag, item, value, size, APE_TAG_TYPE_BINARY);\n    else\n        return 0;\n}\n\n// This function looks up the tag item name by index and is used when the\n// application wants to access all the items in the file&#x27;s ID3v1 or APEv2 tag.\n// Note that this function accesses only the item&#x27;s name; WavpackGetTagItem()\n// still must be called to get the actual value. The &quot;size&quot; parameter specifies\n// the amount of space available at &quot;item&quot;, if the desired item will not fit in\n// this space then ellipses (...) will be appended and the string terminated.\n// The actual length of the string is returned (or 0 if no item exists for\n// index). If this function is called with a NULL &quot;value&quot; pointer (or a\n// zero &quot;length&quot;) then only the actual length of the item name is returned\n// (not counting the terminating NULL). This can be used to determine the\n// actual memory to be allocated beforehand. For binary tag values use the\n// otherwise identical WavpackGetBinaryTagItemIndexed ();\n\nint WavpackGetTagItemIndexed (WavpackContext *wpc, int index, char *item, int size)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n\n    if (item &amp;&amp; size)\n        *item = 0;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;)\n        return get_ape_tag_item_indexed (m_tag, index, item, size, APE_TAG_TYPE_TEXT);\n    else if (m_tag-&gt;id3_tag.tag_id [0] == &#x27;T&#x27;)\n        return get_id3_tag_item_indexed (m_tag, index, item, size);\n    else\n        return 0;\n}\n\nint WavpackGetBinaryTagItemIndexed (WavpackContext *wpc, int index, char *item, int size)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n\n    if (item &amp;&amp; size)\n        *item = 0;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;)\n        return get_ape_tag_item_indexed (m_tag, index, item, size, APE_TAG_TYPE_BINARY);\n    else\n        return 0;\n}\n\n// These two functions are used to append APEv2 tags to WavPack files; one is\n// for text values (UTF-8 encoded) and the other is for binary values. If no tag\n// has been started, then an empty one will be allocated first. When finished,\n// use WavpackWriteTag() to write the completed tag to the file. The purpose of\n// the passed size parameter is obvious for binary values, but might not be for\n// text values. Keep in mind that APEv2 text values can have multiple values\n// that are NULL separated, so the size is required to know the extent of the\n// value (although the final terminating NULL is not included in the passed\n// size). If the specified item already exists, it will be replaced with the\n// new value. ID3v1 tags are not supported.\n\nint WavpackAppendTagItem (WavpackContext *wpc, const char *item, const char *value, int vsize)\n{\n    while (WavpackDeleteTagItem (wpc, item));\n    return append_ape_tag_item (wpc, item, value, vsize, APE_TAG_TYPE_TEXT);\n}\n\nint WavpackAppendBinaryTagItem (WavpackContext *wpc, const char *item, const char *value, int vsize)\n{\n    while (WavpackDeleteTagItem (wpc, item));\n    return append_ape_tag_item (wpc, item, value, vsize, APE_TAG_TYPE_BINARY);\n}\n\n// Delete the specified tag item from the APEv2 tag on the specified WavPack file\n// (fields cannot be deleted from ID3v1 tags). A return value of TRUE indicates\n// that the item was found and successfully deleted.\n\nint WavpackDeleteTagItem (WavpackContext *wpc, const char *item)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;) {\n        unsigned char *p = m_tag-&gt;ape_tag_data;\n        unsigned char *q = p + m_tag-&gt;ape_tag_hdr.length - sizeof (APE_Tag_Hdr);\n        int i;\n\n        for (i = 0; i &lt; m_tag-&gt;ape_tag_hdr.item_count &amp;&amp; q - p &gt; 8; ++i) {\n            int vsize, isize;\n\n            vsize = p[0] + (p[1] &lt;&lt; 8) + (p[2] &lt;&lt; 16) + ((uint32_t) p[3] &lt;&lt; 24); p += 8;   // skip flags because we don&#x27;t need them\n            for (isize = 0; p + isize &lt; q &amp;&amp; p[isize]; ++isize);\n\n            if (vsize &lt; 0 || vsize &gt; m_tag-&gt;ape_tag_hdr.length || p + isize + vsize + 1 &gt; q)\n                break;\n\n            if (isize &amp;&amp; vsize &amp;&amp; !stricmp (item, (char *) p)) {\n                unsigned char *d = p - 8;\n\n                p += isize + vsize + 1;\n\n                while (p &lt; q)\n                    *d++ = *p++;\n\n                m_tag-&gt;ape_tag_hdr.length = (int32_t)(d - m_tag-&gt;ape_tag_data) + sizeof (APE_Tag_Hdr);\n                m_tag-&gt;ape_tag_hdr.item_count--;\n                return 1;\n            }\n            else\n                p += isize + vsize + 1;\n        }\n    }\n\n    return 0;\n}\n\n// Once a APEv2 tag has been created with WavpackAppendTag(), this function is\n// used to write the completed tag to the end of the WavPack file. Note that\n// this function uses the same &quot;blockout&quot; function that is used to write\n// regular WavPack blocks, although that&#x27;s where the similarity ends. It is also\n// used to write tags that have been edited on existing files.\n\nint WavpackWriteTag (WavpackContext *wpc)\n{\n    if (wpc-&gt;blockout)      // this is the case for creating fresh WavPack files\n        return write_tag_blockout (wpc);\n    else                    // otherwise we are editing existing tags (OPEN_EDIT_TAGS)\n        return write_tag_reader (wpc);\n}\n\n////////////////////////// local static functions /////////////////////////////\n\nstatic int get_ape_tag_item (M_Tag *m_tag, const char *item, char *value, int size, int type)\n{\n    unsigned char *p = m_tag-&gt;ape_tag_data;\n    unsigned char *q = p + m_tag-&gt;ape_tag_hdr.length - sizeof (APE_Tag_Hdr);\n    int i;\n\n    for (i = 0; i &lt; m_tag-&gt;ape_tag_hdr.item_count &amp;&amp; q - p &gt; 8; ++i) {\n        int vsize, flags, isize;\n\n        vsize = p[0] + (p[1] &lt;&lt; 8) + (p[2] &lt;&lt; 16) + ((uint32_t) p[3] &lt;&lt; 24); p += 4;\n        flags = p[0] + (p[1] &lt;&lt; 8) + (p[2] &lt;&lt; 16) + ((uint32_t) p[3] &lt;&lt; 24); p += 4;\n        for (isize = 0; p + isize &lt; q &amp;&amp; p[isize]; ++isize);\n\n        if (vsize &lt; 0 || vsize &gt; m_tag-&gt;ape_tag_hdr.length || p + isize + vsize + 1 &gt; q)\n            break;\n\n        if (isize &amp;&amp; vsize &amp;&amp; !stricmp (item, (char *) p) &amp;&amp; ((flags &amp; 6) &gt;&gt; 1) == type) {\n\n            if (!value || !size)\n                return vsize;\n\n            if (type == APE_TAG_TYPE_BINARY) {\n                if (vsize &lt;= size) {\n                    memcpy (value, p + isize + 1, vsize);\n                    return vsize;\n                }\n                else\n                    return 0;\n            }\n            else if (vsize &lt; size) {\n                memcpy (value, p + isize + 1, vsize);\n                value [vsize] = 0;\n                return vsize;\n            }\n            else if (size &gt;= 4) {\n                memcpy (value, p + isize + 1, size - 1);\n                value [size - 4] = value [size - 3] = value [size - 2] = &#x27;.&#x27;;\n                value [size - 1] = 0;\n                return size - 1;\n            }\n            else\n                return 0;\n        }\n        else\n            p += isize + vsize + 1;\n    }\n\n    return 0;\n}\n\nstatic int get_id3_tag_item (M_Tag *m_tag, const char *item, char *value, int size)\n{\n    char lvalue [64];\n    int len;\n\n    lvalue [0] = 0;\n\n    if (!stricmp (item, &quot;title&quot;))\n        tagcpy (lvalue, m_tag-&gt;id3_tag.title, sizeof (m_tag-&gt;id3_tag.title));\n    else if (!stricmp (item, &quot;artist&quot;))\n        tagcpy (lvalue, m_tag-&gt;id3_tag.artist, sizeof (m_tag-&gt;id3_tag.artist));\n    else if (!stricmp (item, &quot;album&quot;))\n        tagcpy (lvalue, m_tag-&gt;id3_tag.album, sizeof (m_tag-&gt;id3_tag.album));\n    else if (!stricmp (item, &quot;year&quot;))\n        tagcpy (lvalue, m_tag-&gt;id3_tag.year, sizeof (m_tag-&gt;id3_tag.year));\n    else if (!stricmp (item, &quot;comment&quot;))\n        tagcpy (lvalue, m_tag-&gt;id3_tag.comment, sizeof (m_tag-&gt;id3_tag.comment));\n    else if (!stricmp (item, &quot;track&quot;) &amp;&amp; m_tag-&gt;id3_tag.comment [29] &amp;&amp; !m_tag-&gt;id3_tag.comment [28])\n        sprintf (lvalue, &quot;%d&quot;, m_tag-&gt;id3_tag.comment [29]);\n    else\n        return 0;\n\n    len = (int) strlen (lvalue);\n\n    if (!value || !size)\n        return len;\n\n    if (len &lt; size) {\n        strcpy (value, lvalue);\n        return len;\n    }\n    else if (size &gt;= 4) {\n        strncpy (value, lvalue, size - 1);\n        value [size - 4] = value [size - 3] = value [size - 2] = &#x27;.&#x27;;\n        value [size - 1] = 0;\n        return size - 1;\n    }\n    else\n        return 0;\n}\n\nstatic int get_ape_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size, int type)\n{\n    unsigned char *p = m_tag-&gt;ape_tag_data;\n    unsigned char *q = p + m_tag-&gt;ape_tag_hdr.length - sizeof (APE_Tag_Hdr);\n    int i;\n\n    for (i = 0; i &lt; m_tag-&gt;ape_tag_hdr.item_count &amp;&amp; index &gt;= 0 &amp;&amp; q - p &gt; 8; ++i) {\n        int vsize, flags, isize;\n\n        vsize = p[0] + (p[1] &lt;&lt; 8) + (p[2] &lt;&lt; 16) + ((uint32_t) p[3] &lt;&lt; 24); p += 4;\n        flags = p[0] + (p[1] &lt;&lt; 8) + (p[2] &lt;&lt; 16) + ((uint32_t) p[3] &lt;&lt; 24); p += 4;\n        for (isize = 0; p + isize &lt; q &amp;&amp; p[isize]; ++isize);\n\n        if (vsize &lt; 0 || vsize &gt; m_tag-&gt;ape_tag_hdr.length || p + isize + vsize + 1 &gt; q)\n            break;\n\n        if (isize &amp;&amp; vsize &amp;&amp; ((flags &amp; 6) &gt;&gt; 1) == type &amp;&amp; !index--) {\n\n            if (!item || !size)\n                return isize;\n\n            if (isize &lt; size) {\n                memcpy (item, p, isize);\n                item [isize] = 0;\n                return isize;\n            }\n            else if (size &gt;= 4) {\n                memcpy (item, p, size - 1);\n                item [size - 4] = item [size - 3] = item [size - 2] = &#x27;.&#x27;;\n                item [size - 1] = 0;\n                return size - 1;\n            }\n            else\n                return 0;\n        }\n        else\n            p += isize + vsize + 1;\n    }\n\n    return 0;\n}\n\nstatic int get_id3_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size)\n{\n    char lvalue [16];\n    int len;\n\n    lvalue [0] = 0;\n\n    if (tagdata (m_tag-&gt;id3_tag.title, sizeof (m_tag-&gt;id3_tag.title)) &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Title&quot;);\n    else if (tagdata (m_tag-&gt;id3_tag.artist, sizeof (m_tag-&gt;id3_tag.artist)) &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Artist&quot;);\n    else if (tagdata (m_tag-&gt;id3_tag.album, sizeof (m_tag-&gt;id3_tag.album)) &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Album&quot;);\n    else if (tagdata (m_tag-&gt;id3_tag.year, sizeof (m_tag-&gt;id3_tag.year)) &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Year&quot;);\n    else if (tagdata (m_tag-&gt;id3_tag.comment, sizeof (m_tag-&gt;id3_tag.comment)) &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Comment&quot;);\n    else if (m_tag-&gt;id3_tag.comment [29] &amp;&amp; !m_tag-&gt;id3_tag.comment [28] &amp;&amp; !index--)\n        strcpy (lvalue, &quot;Track&quot;);\n    else\n        return 0;\n\n    len = (int) strlen (lvalue);\n\n    if (!item || !size)\n        return len;\n\n    if (len &lt; size) {\n        strcpy (item, lvalue);\n        return len;\n    }\n    else if (size &gt;= 4) {\n        strncpy (item, lvalue, size - 1);\n        item [size - 4] = item [size - 3] = item [size - 2] = &#x27;.&#x27;;\n        item [size - 1] = 0;\n        return size - 1;\n    }\n    else\n        return 0;\n}\n\nstatic int append_ape_tag_item (WavpackContext *wpc, const char *item, const char *value, int vsize, int type)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n    int isize = (int) strlen (item);\n\n    if (!m_tag-&gt;ape_tag_hdr.ID [0]) {\n        memcpy (m_tag-&gt;ape_tag_hdr.ID, &quot;APETAGEX&quot;, sizeof (m_tag-&gt;ape_tag_hdr.ID));\n        m_tag-&gt;ape_tag_hdr.version = 2000;\n        m_tag-&gt;ape_tag_hdr.length = sizeof (m_tag-&gt;ape_tag_hdr);\n        m_tag-&gt;ape_tag_hdr.item_count = 0;\n        m_tag-&gt;ape_tag_hdr.flags = APE_TAG_CONTAINS_HEADER;  // we will include header on tags we originate\n    }\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27;) {\n        int new_item_len = vsize + isize + 9, flags = type &lt;&lt; 1;\n        unsigned char *p;\n\n        if (m_tag-&gt;ape_tag_hdr.length + new_item_len &gt; APE_TAG_MAX_LENGTH) {\n            strcpy (wpc-&gt;error_message, &quot;APEv2 tag exceeds maximum allowed length!&quot;);\n            return FALSE;\n        }\n\n        m_tag-&gt;ape_tag_hdr.item_count++;\n        m_tag-&gt;ape_tag_hdr.length += new_item_len;\n        p = m_tag-&gt;ape_tag_data = (unsigned char*)realloc (m_tag-&gt;ape_tag_data, m_tag-&gt;ape_tag_hdr.length);\n        p += m_tag-&gt;ape_tag_hdr.length - sizeof (APE_Tag_Hdr) - new_item_len;\n\n        *p++ = (unsigned char) vsize;\n        *p++ = (unsigned char) (vsize &gt;&gt; 8);\n        *p++ = (unsigned char) (vsize &gt;&gt; 16);\n        *p++ = (unsigned char) (vsize &gt;&gt; 24);\n\n        *p++ = (unsigned char) flags;\n        *p++ = (unsigned char) (flags &gt;&gt; 8);\n        *p++ = (unsigned char) (flags &gt;&gt; 16);\n        *p++ = (unsigned char) (flags &gt;&gt; 24);\n\n        strcpy ((char *) p, item);\n        p += isize + 1;\n        memcpy (p, value, vsize);\n\n        return TRUE;\n    }\n    else\n        return FALSE;\n}\n\n// Append the stored APEv2 tag to the file being created using the &quot;blockout&quot; function callback.\n\nstatic int write_tag_blockout (WavpackContext *wpc)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n    int result = TRUE;\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27; &amp;&amp; m_tag-&gt;ape_tag_hdr.item_count) {\n\n        // only write header if it&#x27;s specified in the flags\n\n        if (m_tag-&gt;ape_tag_hdr.flags &amp; APE_TAG_CONTAINS_HEADER) {\n            m_tag-&gt;ape_tag_hdr.flags |= APE_TAG_THIS_IS_HEADER;\n            WavpackNativeToLittleEndian (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n            result = wpc-&gt;blockout (wpc-&gt;wv_out, &amp;m_tag-&gt;ape_tag_hdr, sizeof (m_tag-&gt;ape_tag_hdr));\n            WavpackLittleEndianToNative (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n        }\n\n        if (m_tag-&gt;ape_tag_hdr.length &gt; sizeof (m_tag-&gt;ape_tag_hdr))\n            result = wpc-&gt;blockout (wpc-&gt;wv_out, m_tag-&gt;ape_tag_data, m_tag-&gt;ape_tag_hdr.length - sizeof (m_tag-&gt;ape_tag_hdr));\n\n        m_tag-&gt;ape_tag_hdr.flags &amp;= ~APE_TAG_THIS_IS_HEADER;    // this is NOT header\n        WavpackNativeToLittleEndian (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n        result = wpc-&gt;blockout (wpc-&gt;wv_out, &amp;m_tag-&gt;ape_tag_hdr, sizeof (m_tag-&gt;ape_tag_hdr));\n        WavpackLittleEndianToNative (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n    }\n\n    if (!result)\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t write WavPack data, disk probably full!&quot;);\n\n    return result;\n}\n\n// Write the [potentially] edited tag to the existing WavPack file using the reader callback functions.\n\nstatic int write_tag_reader (WavpackContext *wpc)\n{\n    M_Tag *m_tag = &amp;wpc-&gt;m_tag;\n    int32_t tag_size = 0;\n    int result;\n\n    // before we write an edited (or new) tag into an existing file, make sure it&#x27;s safe and possible\n\n    if (m_tag-&gt;tag_begins_file) {\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t edit tags located at the beginning of files!&quot;);\n        return FALSE;\n    }\n\n    if (!wpc-&gt;reader-&gt;can_seek (wpc-&gt;wv_in)) {\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t edit tags on pipes or unseekable files!&quot;);\n        return FALSE;\n    }\n\n    if (!(wpc-&gt;open_flags &amp; OPEN_EDIT_TAGS)) {\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t edit tags without OPEN_EDIT_TAGS flag!&quot;);\n        return FALSE;\n    }\n\n    if (m_tag-&gt;ape_tag_hdr.ID [0] == &#x27;A&#x27; &amp;&amp; m_tag-&gt;ape_tag_hdr.item_count &amp;&amp;\n        m_tag-&gt;ape_tag_hdr.length &gt; sizeof (m_tag-&gt;ape_tag_hdr))\n            tag_size = m_tag-&gt;ape_tag_hdr.length;\n\n    // only write header if it&#x27;s specified in the flags\n\n    if (tag_size &amp;&amp; (m_tag-&gt;ape_tag_hdr.flags &amp; APE_TAG_CONTAINS_HEADER))\n        tag_size += sizeof (m_tag-&gt;ape_tag_hdr);\n\n    result = !wpc-&gt;reader-&gt;set_pos_rel (wpc-&gt;wv_in, m_tag-&gt;tag_file_pos, SEEK_END);\n\n    if (result &amp;&amp; tag_size &lt; -m_tag-&gt;tag_file_pos &amp;&amp; !wpc-&gt;reader-&gt;truncate_here) {\n        int nullcnt = (int) (-m_tag-&gt;tag_file_pos - tag_size);\n        char zero = 0;\n\n        while (nullcnt--)\n            wpc-&gt;reader-&gt;write_bytes (wpc-&gt;wv_in, &amp;zero, 1);\n    }\n\n    if (result &amp;&amp; tag_size) {\n        if (m_tag-&gt;ape_tag_hdr.flags &amp; APE_TAG_CONTAINS_HEADER) {\n            m_tag-&gt;ape_tag_hdr.flags |= APE_TAG_THIS_IS_HEADER;\n            WavpackNativeToLittleEndian (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n            result = (wpc-&gt;reader-&gt;write_bytes (wpc-&gt;wv_in, &amp;m_tag-&gt;ape_tag_hdr, sizeof (m_tag-&gt;ape_tag_hdr)) == sizeof (m_tag-&gt;ape_tag_hdr));\n            WavpackLittleEndianToNative (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n        }\n\n        result = (wpc-&gt;reader-&gt;write_bytes (wpc-&gt;wv_in, m_tag-&gt;ape_tag_data, m_tag-&gt;ape_tag_hdr.length - sizeof (m_tag-&gt;ape_tag_hdr)) == sizeof (m_tag-&gt;ape_tag_hdr));\n        m_tag-&gt;ape_tag_hdr.flags &amp;= ~APE_TAG_THIS_IS_HEADER;    // this is NOT header\n        WavpackNativeToLittleEndian (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n        result = (wpc-&gt;reader-&gt;write_bytes (wpc-&gt;wv_in, &amp;m_tag-&gt;ape_tag_hdr, sizeof (m_tag-&gt;ape_tag_hdr)) == sizeof (m_tag-&gt;ape_tag_hdr));\n        WavpackLittleEndianToNative (&amp;m_tag-&gt;ape_tag_hdr, APE_Tag_Hdr_Format);\n    }\n\n    if (result &amp;&amp; tag_size &lt; -m_tag-&gt;tag_file_pos &amp;&amp; wpc-&gt;reader-&gt;truncate_here)\n        result = !wpc-&gt;reader-&gt;truncate_here (wpc-&gt;wv_in);\n\n    if (!result)\n        strcpy (wpc-&gt;error_message, &quot;can&#x27;t write WavPack data, disk probably full!&quot;);\n\n    return result;\n}\n\n// Copy the specified ID3v1 tag value (with specified field size) from the\n// source pointer to the destination, eliminating leading spaces and trailing\n// spaces and nulls.\n\nstatic void tagcpy (char *dest, char *src, int tag_size)\n{\n    char *s1 = src, *s2 = src + tag_size - 1;\n\n    if (*s2 &amp;&amp; !s2 [-1])\n        s2--;\n\n    while (s1 &lt;= s2)\n        if (*s1 == &#x27; &#x27;)\n            ++s1;\n        else if (!*s2 || *s2 == &#x27; &#x27;)\n            --s2;\n        else\n            break;\n\n    while (*s1 &amp;&amp; s1 &lt;= s2)\n        *dest++ = *s1++;\n\n    *dest = 0;\n}\n\nstatic int tagdata (char *src, int tag_size)\n{\n    char *s1 = src, *s2 = src + tag_size - 1;\n\n    if (*s2 &amp;&amp; !s2 [-1])\n        s2--;\n\n    while (s1 &lt;= s2)\n        if (*s1 == &#x27; &#x27;)\n            ++s1;\n        else if (!*s2 || *s2 == &#x27; &#x27;)\n            --s2;\n        else\n            break;\n\n    return (*s1 &amp;&amp; s1 &lt;= s2);\n}\n"}}, "reports": [{"fileId": "/project/WavPack/src/pack_utils.c", "reportHash": "8e4373a2507ae027c8b19f6b34db0d85", "checker": {"name": "unix.cstring.NullArg", "url": null}, "analyzerName": "clangsa", "line": 71, "column": 9, "message": "Null pointer passed as 1st argument to string copy function", "events": [{"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2874, "column": 27}, {"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2877, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 9}, {"message": "Assuming 'import_id3' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 57}, {"message": "Assuming 'worker_threads' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2904, "column": 9}, {"message": "Calling 'WavpackOpenFileInput'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2909, "column": 14}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/src/open_filename.c", "line": 274, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/open_filename.c", "line": 276, "column": 24}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 285, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 294, "column": 14}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 299, "column": 32}, {"message": "Returning pointer, which participates in a condition later", "fileId": "/project/WavPack/src/open_filename.c", "line": 310, "column": 5}, {"message": "Returning from 'WavpackOpenFileInput'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2909, "column": 14}, {"message": "Assuming 'infile' is non-null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2911, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2918, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2926, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 9}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2974, "column": 25}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3014, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3017, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3034, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3045, "column": 21}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3081, "column": 9}, {"message": "Calling 'WavpackGetFileExtension'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3092, "column": 41}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/src/open_utils.c", "line": 289, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_utils.c", "line": 291, "column": 16}, {"message": "Returning pointer, which participates in a condition later", "fileId": "/project/WavPack/src/open_utils.c", "line": 294, "column": 9}, {"message": "Returning from 'WavpackGetFileExtension'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3092, "column": 41}, {"message": "Calling 'WavpackSetFileInformation'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3092, "column": 5}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 67, "column": 1}, {"message": "Null pointer passed as 1st argument to string copy function", "fileId": "/project/WavPack/src/pack_utils.c", "line": 71, "column": 9}], "macros": [{"message": "memset (&wv_file ,0,sizeof (wv_file ));", "name": "CLEAR (wv_file)", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2934, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/src/pack.c", "reportHash": "f910e31fe12bd32cc7c042b086f3f981", "checker": {"name": "optin.portability.UnixAPI", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#optin-portability-unixapi"}, "analyzerName": "clangsa", "line": 568, "column": 25, "message": "Call to 'malloc' has an allocation size of 0 bytes", "events": [{"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1647, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1675, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1684, "column": 14}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1690, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1746, "column": 9}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1781, "column": 25}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1825, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1828, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1845, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1860, "column": 21}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1902, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 71}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1938, "column": 21}, {"message": "Assuming 'debug_logging_mode' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1942, "column": 13}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1945, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1946, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1949, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1952, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2004, "column": 9}, {"message": "Assuming 'num_channels_order' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2019, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2019, "column": 32}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2060, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2074, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2077, "column": 82}, {"message": "Assuming 'verify_mode' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2077, "column": 125}, {"message": "Assuming 'result' is not equal to WAVPACK_WARNINGS", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2079, "column": 9}, {"message": "Assuming 'result' is equal to WAVPACK_NO_ERROR", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2089, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2097, "column": 39}, {"message": "Calling 'WavpackFlushSamples'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2181, "column": 40}, {"message": "Entered call from 'pack_file'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 805, "column": 1}, {"message": "Entering loop body", "fileId": "/project/WavPack/src/pack_utils.c", "line": 807, "column": 12}, {"message": "Assuming field 'acc_samples' is <= field 'block_samples'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 810, "column": 13}, {"message": "Calling 'pack_streams'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 815, "column": 14}, {"message": "Entered call from 'WavpackFlushSamples'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1103, "column": 1}, {"message": "Assuming 'i' is < field 'num_streams'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1110, "column": 17}, {"message": "Entering loop body", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1110, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1111, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1122, "column": 10}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1122, "column": 52}, {"message": "Entering loop body", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1130, "column": 28}, {"message": "Assuming field 'wvc_flag' is 0", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1140, "column": 27}, {"message": "Assuming field 'discontinuous' is 0", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1211, "column": 17}, {"message": "Calling 'pack_stream_block'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1214, "column": 22}, {"message": "Entered call from 'pack_streams'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1019, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1024, "column": 9}, {"message": "Calling 'pack_block'", "fileId": "/project/WavPack/src/pack_utils.c", "line": 1028, "column": 18}, {"message": "Entered call from 'pack_stream_block'", "fileId": "/project/WavPack/src/pack.c", "line": 460, "column": 1}, {"message": "Assuming field 'stream_index' is 0", "fileId": "/project/WavPack/src/pack.c", "line": 473, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 473, "column": 31}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 473, "column": 56}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 474, "column": 14}, {"message": "Assuming field 'block_samples' is 0", "fileId": "/project/WavPack/src/pack.c", "line": 474, "column": 66}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/pack.c", "line": 495, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 532, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/pack.c", "line": 538, "column": 13}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/src/pack.c", "line": 542, "column": 20}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 547, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 563, "column": 10}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 567, "column": 14}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/pack.c", "line": 567, "column": 63}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/pack.c", "line": 568, "column": 50}, {"message": "Call to 'malloc' has an allocation size of 0 bytes", "fileId": "/project/WavPack/src/pack.c", "line": 568, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "301d8872bc5acdc9c77ac79a4cbfb61a", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 2024, "column": 17, "message": "Potential leak of memory pointed to by 'new_channel_order'", "events": [{"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1647, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1675, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1684, "column": 14}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1690, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1746, "column": 9}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1781, "column": 25}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1825, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1828, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1845, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1860, "column": 21}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1902, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 71}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1938, "column": 21}, {"message": "Assuming 'debug_logging_mode' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1942, "column": 13}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1945, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1946, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1949, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1952, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2004, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2007, "column": 13}, {"message": "Memory is allocated", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2008, "column": 33}, {"message": "Assuming 'i' is >= field 'num_channels'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2010, "column": 25}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2010, "column": 25}, {"message": "Assuming 'num_channels_order' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2019, "column": 9}, {"message": "Assuming 'num_channels_order' is > field 'num_channels'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2022, "column": 13}, {"message": "Potential leak of memory pointed to by 'new_channel_order'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2024, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "301d8872bc5acdc9c77ac79a4cbfb61a", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 2061, "column": 13, "message": "Potential leak of memory pointed to by 'new_channel_order'", "events": [{"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1647, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1675, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1684, "column": 14}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1690, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1746, "column": 9}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1781, "column": 25}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1825, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1828, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1845, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1860, "column": 21}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1902, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1925, "column": 71}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1938, "column": 21}, {"message": "Assuming 'debug_logging_mode' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1942, "column": 13}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1945, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1946, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1949, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 1952, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2004, "column": 9}, {"message": "Assuming 'num_channels_order' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2019, "column": 9}, {"message": "Assuming 'num_channels_order' is <= field 'num_channels'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2022, "column": 13}, {"message": "Assuming 'num_channels_order' is >= field 'num_channels'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2023, "column": 14}, {"message": "Memory is allocated", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2035, "column": 33}, {"message": "Assuming 'i' is >= field 'num_channels'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2037, "column": 25}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2037, "column": 25}, {"message": "Assuming 'i' is >= 'num_channels_order'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2042, "column": 25}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2042, "column": 25}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2060, "column": 13}, {"message": "Potential leak of memory pointed to by 'new_channel_order'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2061, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "94543e0aa3a0f2d9b6cbb4f5e390218b", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 3075, "column": 9, "message": "Potential leak of memory pointed to by 'out2filename_temp'", "events": [{"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2874, "column": 27}, {"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2877, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 9}, {"message": "Assuming 'import_id3' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 57}, {"message": "Assuming 'worker_threads' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2904, "column": 9}, {"message": "Assuming 'infile' is non-null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2911, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2918, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2926, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 32}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2974, "column": 25}, {"message": "Memory is allocated", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3012, "column": 33}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3014, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3017, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3034, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3045, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3074, "column": 14}, {"message": "Potential leak of memory pointed to by 'out2filename_temp'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3075, "column": 9}], "macros": [{"message": "memset (&wv_file ,0,sizeof (wv_file ));", "name": "CLEAR (wv_file)", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2934, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "6e6b3cc5a0bf548b20b5ebff896e0c18", "checker": {"name": "optin.portability.UnixAPI", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#optin-portability-unixapi"}, "analyzerName": "clangsa", "line": 3303, "column": 21, "message": "Call to 'malloc' has an allocation size of 0 bytes", "events": [{"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2874, "column": 27}, {"message": "Assuming 'out2filename' is not equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2877, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 9}, {"message": "Assuming 'import_id3' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 57}, {"message": "Assuming 'worker_threads' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2904, "column": 9}, {"message": "Calling 'WavpackOpenFileInput'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2909, "column": 14}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/src/open_filename.c", "line": 274, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/src/open_filename.c", "line": 276, "column": 24}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 285, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 294, "column": 14}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/src/open_filename.c", "line": 299, "column": 32}, {"message": "Returning pointer, which participates in a condition later", "fileId": "/project/WavPack/src/open_filename.c", "line": 310, "column": 5}, {"message": "Returning from 'WavpackOpenFileInput'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2909, "column": 14}, {"message": "Assuming 'infile' is non-null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2911, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2918, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2926, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 9}, {"message": "Assuming 'overwrite_all' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2974, "column": 25}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3014, "column": 16}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3017, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3034, "column": 17}, {"message": "Assuming 'testfile' is null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3045, "column": 21}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3081, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3096, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3119, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3122, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3125, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3136, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3151, "column": 13}, {"message": "Assuming 'result' is equal to WAVPACK_NO_ERROR", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3167, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3168, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3173, "column": 13}, {"message": "Assuming 'quantize_bits' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3178, "column": 45}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3198, "column": 18}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3206, "column": 39}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3254, "column": 39}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3262, "column": 41}, {"message": "Assuming 'i' is >= 'num_items'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3269, "column": 21}, {"message": "Assuming 'i' is < 'num_binary_items'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3298, "column": 21}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3298, "column": 21}, {"message": "Calling 'WavpackGetBinaryTagItem'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3302, "column": 25}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/src/tag_utils.c", "line": 101, "column": 1}, {"message": "Returning zero", "fileId": "/project/WavPack/src/tag_utils.c", "line": 111, "column": 9}, {"message": "Returning from 'WavpackGetBinaryTagItem'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3302, "column": 25}, {"message": "The value 0 is assigned to 'value_len'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3302, "column": 13}, {"message": "Call to 'malloc' has an allocation size of 0 bytes", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3303, "column": 21}], "macros": [{"message": "memset (&wv_file ,0,sizeof (wv_file ));", "name": "CLEAR (wv_file)", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2934, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "3d7222e5f682ede170371d3be0c00888", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 3629, "column": 13, "message": "Potential leak of memory pointed to by 'format_buffer'", "events": [{"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2874, "column": 27}, {"message": "Assuming 'out2filename' is equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2877, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 9}, {"message": "Assuming 'import_id3' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 57}, {"message": "Assuming 'worker_threads' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2904, "column": 9}, {"message": "Assuming 'infile' is non-null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2911, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2918, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2926, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 9}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3081, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3096, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3119, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3122, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3125, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3136, "column": 9}, {"message": "Calling 'repack_audio'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3163, "column": 14}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3551, "column": 1}, {"message": "Assuming 'worker_threads' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3564, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3567, "column": 16}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3567, "column": 16}, {"message": "Memory is allocated", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3571, "column": 25}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3574, "column": 13}, {"message": "Assuming 'quantize_bits' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3591, "column": 9}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3600, "column": 12}, {"message": "Assuming 'sample_count' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3603, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3628, "column": 13}, {"message": "Potential leak of memory pointed to by 'format_buffer'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3629, "column": 13}], "macros": [{"message": "memset (&wv_file ,0,sizeof (wv_file ));", "name": "CLEAR (wv_file)", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2934, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/project/WavPack/cli/wavpack.c", "reportHash": "3d7222e5f682ede170371d3be0c00888", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 3687, "column": 13, "message": "Potential leak of memory pointed to by 'dptr'", "events": [{"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2874, "column": 27}, {"message": "Assuming 'out2filename' is equal to NULL", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2877, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 9}, {"message": "Assuming 'import_id3' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2897, "column": 57}, {"message": "Assuming 'worker_threads' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2904, "column": 9}, {"message": "Assuming 'infile' is non-null", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2911, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2918, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2926, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2940, "column": 9}, {"message": "Assuming 'quiet_mode' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3081, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3096, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3119, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3122, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3125, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3136, "column": 9}, {"message": "Calling 'repack_audio'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3163, "column": 14}, {"message": "Entered call from 'repack_file'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3551, "column": 1}, {"message": "Assuming 'worker_threads' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3564, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3567, "column": 16}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3567, "column": 16}, {"message": "Memory is allocated", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3571, "column": 25}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3574, "column": 13}, {"message": "Assuming 'quantize_bits' is 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3591, "column": 9}, {"message": "Entering loop body", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3600, "column": 12}, {"message": "Assuming 'sample_count' is not equal to 0", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3603, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3628, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3638, "column": 17}, {"message": "Assuming the condition is false", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3642, "column": 21}, {"message": "Loop body executed 0 times", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3673, "column": 28}, {"message": "Assuming the condition is true", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3683, "column": 13}, {"message": "Potential leak of memory pointed to by 'dptr'", "fileId": "/project/WavPack/cli/wavpack.c", "line": 3687, "column": 13}], "macros": [{"message": "memset (&wv_file ,0,sizeof (wv_file ));", "name": "CLEAR (wv_file)", "fileId": "/project/WavPack/cli/wavpack.c", "line": 2934, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
